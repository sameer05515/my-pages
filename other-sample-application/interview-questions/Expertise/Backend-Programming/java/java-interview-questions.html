<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Java Intierview questions</title>
    <link rel="stylesheet" href="../../../lib/style.css">
    <script src="../../../lib/jquery-3.6.0.js"></script>
</head>

<body>

    <div class="borderSt">
        <b>Java 17 vs Java 8</b> 
        <a href="https://pretius.com/blog/java-17-features/" target="_blank" rel="noopener noreferrer">
            Java 17 features: A comparison between versions 8 and 17. What has changed over the years?
        </a> <br>

        <b>Java Version History</b>
        <a href="https://en.wikipedia.org/wiki/Java_version_history" target="_blank" rel="noopener noreferrer">
            Java version history
        </a>
    </div>

    <div class="borderSt">
        <div class="box-prem">
            <h1>300 Core Java Interview Questions</h1>

            <h2>Core Java: Basics of Java Interview Questions</h2>

            <h3>1) What is Java?</h3>

            <p><a href="https://www.javatpoint.com/java-tutorial">Java</a>&nbsp;is the high-level,&nbsp;<a
                    href="https://www.javatpoint.com/java-oops-concepts">object-oriented</a>, robust, secure programming
                language, platform-independent, high performance, Multithreaded, and portable programming language. It
                was developed by&nbsp;<strong><a href="https://www.javatpoint.com/james-gosling-father-of-java">James
                        Gosling</a></strong>in June 1991. It can also be known as the platform as it provides its own
                JRE and API.</p>

            <hr />
            <h3>2) What are the differences between C++ and Java?</h3>

            <p>The differences between&nbsp;<a href="https://www.javatpoint.com/cpp-tutorial">C++</a>&nbsp;and Java are
                given in the following table.</p>

            <table>
                <tbody>
                    <tr>
                        <th>Comparison Index</th>
                        <th>C++</th>
                        <th>Java</th>
                    </tr>
                    <tr>
                        <td><strong>Platform-independent</strong></td>
                        <td>C++ is platform-dependent.</td>
                        <td>Java is platform-independent.</td>
                    </tr>
                    <tr>
                        <td><strong>Mainly used for</strong></td>
                        <td>C++ is mainly used for system programming.</td>
                        <td>Java is mainly used for application programming. It is widely used in window, web-based,
                            enterprise and mobile applications.</td>
                    </tr>
                    <tr>
                        <td><strong>Design Goal</strong></td>
                        <td>C++ was designed for systems and applications programming. It was an extension of&nbsp;<a
                                href="https://www.javatpoint.com/c-programming-language-tutorial">C programming
                                language</a>.</td>
                        <td>Java was designed and created as an interpreter for printing systems but later extended as a
                            support network computing. It was designed with a goal of being easy to use and accessible
                            to a broader audience.</td>
                    </tr>
                    <tr>
                        <td><strong>Goto</strong></td>
                        <td>C++ supports the&nbsp;<a
                                href="https://www.javatpoint.com/cpp-goto-statement">goto</a>statement.</td>
                        <td>Java doesn&#39;t support the goto statement.</td>
                    </tr>
                    <tr>
                        <td><strong>Multiple inheritance</strong></td>
                        <td>C++ supports multiple inheritance.</td>
                        <td>Java doesn&#39;t support multiple inheritance through class. It can be achieved by&nbsp;<a
                                href="https://www.javatpoint.com/interface-in-java">interfaces in java</a>.</td>
                    </tr>
                    <tr>
                        <td><strong>Operator Overloading</strong></td>
                        <td>C++ supports&nbsp;<a href="https://www.javatpoint.com/cpp-overloading">operator
                                overloading</a>.</td>
                        <td>Java doesn&#39;t support operator overloading.</td>
                    </tr>
                    <tr>
                        <td><strong>Pointers</strong></td>
                        <td>C++ supports&nbsp;<a href="https://www.javatpoint.com/cpp-pointers">pointers</a>. You can
                            write pointer program in C++.</td>
                        <td>Java supports pointer internally. However, you can&#39;t write the pointer program in java.
                            It means java has restricted pointer support in Java.</td>
                    </tr>
                    <tr>
                        <td><strong>Compiler and Interpreter</strong></td>
                        <td>C++ uses compiler only. C++ is compiled and run using the compiler which converts source
                            code into machine code so, C++ is platform dependent.</td>
                        <td>Java uses compiler and interpreter both. Java source code is converted into bytecode at
                            compilation time. The interpreter executes this bytecode at runtime and produces output.
                            Java is interpreted that is why it is platform independent.</td>
                    </tr>
                    <tr>
                        <td><strong>Call by Value and Call by reference</strong></td>
                        <td>C++ supports both call by value and call by reference.</td>
                        <td>Java supports call by value only. There is no call by reference in java.</td>
                    </tr>
                    <tr>
                        <td><strong>Structure and Union</strong></td>
                        <td>C++ supports structures and unions.</td>
                        <td>Java doesn&#39;t support structures and unions.</td>
                    </tr>
                    <tr>
                        <td><strong>Thread Support</strong></td>
                        <td>C++ doesn&#39;t have built-in support for threads. It relies on third-party libraries for
                            thread support.</td>
                        <td>Java has built-in&nbsp;<a
                                href="https://www.javatpoint.com/multithreading-in-java">thread</a>support.</td>
                    </tr>
                    <tr>
                        <td><strong>Documentation comment</strong></td>
                        <td>C++ doesn&#39;t support documentation comment.</td>
                        <td>Java supports documentation comment (/** ... */) to create documentation for java source
                            code.</td>
                    </tr>
                    <tr>
                        <td><strong>Virtual Keyword</strong></td>
                        <td>C++ supports virtual keyword so that we can decide whether or not override a function.</td>
                        <td>Java has no virtual keyword. We can override all non-static methods by default. In other
                            words, non-static methods are virtual by default.</td>
                    </tr>
                    <tr>
                        <td><strong>unsigned right shift &gt;&gt;&gt;</strong></td>
                        <td>C++ doesn&#39;t support &gt;&gt;&gt; operator.</td>
                        <td>Java supports unsigned right shift &gt;&gt;&gt; operator that fills zero at the top for the
                            negative numbers. For positive numbers, it works same like &gt;&gt; operator.</td>
                    </tr>
                    <tr>
                        <td><strong>Inheritance Tree</strong></td>
                        <td>C++ creates a new inheritance tree always.</td>
                        <td>Java uses a single inheritance tree always because all classes are the child of Object class
                            in java. The object class is the root of the&nbsp;<a
                                href="https://www.javatpoint.com/inheritance-in-java">inheritance</a>tree in java.</td>
                    </tr>
                    <tr>
                        <td><strong>Hardware</strong></td>
                        <td>C++ is nearer to hardware.</td>
                        <td>Java is not so interactive with hardware.</td>
                    </tr>
                    <tr>
                        <td><strong>Object-oriented</strong></td>
                        <td>C++ is an object-oriented language. However, in C language, single root hierarchy is not
                            possible.</td>
                        <td>Java is also an&nbsp;<a
                                href="https://www.javatpoint.com/java-oops-concepts">object-oriented</a>language.
                            However, everything (except fundamental types) is an object in Java. It is a single root
                            hierarchy as everything gets derived from java.lang.Object.</td>
                    </tr>
                </tbody>
            </table>

            <hr />
            <h3>3) List the features of Java Programming language.</h3>

            <p>There are the following features in Java Programming Language.</p>

            <ul>
                <li><strong>Simple:</strong>&nbsp;Java is easy to learn. The syntax of Java is based on C++ which makes
                    easier to write the program in it.</li>
                <li><strong>Object-Oriented:</strong>&nbsp;Java follows the object-oriented paradigm which allows us to
                    maintain our code as the combination of different type of objects that incorporates both data and
                    behavior.</li>
                <li><strong>Portable:</strong>&nbsp;Java supports read-once-write-anywhere approach. We can execute the
                    Java program on every machine. Java program (.java) is converted to bytecode (.class) which can be
                    easily run on every machine.</li>
                <li><strong>Platform Independent:</strong>&nbsp;Java is a platform independent programming language. It
                    is different from other programming languages like C and C++ which needs a platform to be executed.
                    Java comes with its platform on which its code is executed. Java doesn&#39;t depend upon the
                    operating system to be executed.</li>
                <li><strong>Secured:</strong>&nbsp;Java is secured because it doesn&#39;t use explicit pointers. Java
                    also provides the concept of ByteCode and Exception handling which makes it more secured.</li>
                <li><strong>Robust:</strong>&nbsp;Java is a strong programming language as it uses strong memory
                    management. The concepts like Automatic garbage collection, Exception handling, etc. make it more
                    robust</li>
                <li><strong>Architecture Neutral:</strong>&nbsp;Java is architectural neutral as it is not dependent on
                    the architecture. In C, the size of data types may vary according to the architecture (32 bit or 64
                    bit) which doesn&#39;t exist in Java.</li>
                <li><strong>Interpreted:</strong>&nbsp;Java uses the Just-in-time (JIT) interpreter along with the
                    compiler for the program execution.</li>
                <li><strong>High Performance:</strong>&nbsp;Java is faster than other traditional interpreted
                    programming languages because Java bytecode is &quot;close&quot; to native code. It is still a
                    little bit slower than a compiled language (e.g., C++).</li>
                <li><strong>Multithreaded:</strong>&nbsp;We can write Java programs that deal with many tasks at once by
                    defining multiple threads. The main advantage of multi-threading is that it doesn&#39;t occupy
                    memory for each thread. It shares a common memory area. Threads are important for multi-media, Web
                    applications, etc.</li>
                <li><strong>Distributed:</strong>&nbsp;Java is distributed because it facilitates users to create
                    distributed applications in Java. RMI and EJB are used for creating distributed applications. This
                    feature of Java makes us able to access files by calling the methods from any machine on the
                    internet.</li>
                <li><strong>Dynamic:</strong>&nbsp;Java is a dynamic language. It supports dynamic loading of classes.
                    It means classes are loaded on demand. It also supports functions from its native languages, i.e., C
                    and C++.</li>
                <br />
                &nbsp;
            </ul>

            <hr />
            <h3>4) What do you understand by Java virtual machine?</h3>

            <p><a href="https://www.javatpoint.com/jvm-java-virtual-machine">Java Virtual Machine</a>&nbsp;is a virtual
                machine that enables the computer to run the Java program. JVM acts like a run-time engine which calls
                the main method present in the Java code. JVM is the specification which must be implemented in the
                computer system. The Java code is compiled by JVM to be a Bytecode which is machine independent and
                close to the native code.</p>

            <hr />
            <h3>5) What is the difference between JDK, JRE, and JVM?</h3>

            <h3>JVM</h3>

            <p>JVM is an acronym for Java Virtual Machine; it is an abstract machine which provides the runtime
                environment in which Java bytecode can be executed. It is a specification which specifies the working of
                Java Virtual Machine. Its implementation has been provided by Oracle and other companies. Its
                implementation is known as JRE.</p>

            <p>JVMs are available for many hardware and software platforms (so JVM is platform dependent). It is a
                runtime instance which is created when we run the Java class. There are three notions of the JVM:
                specification, implementation, and instance.</p>

            <h3>JRE</h3>

            <p>JRE stands for Java Runtime Environment. It is the implementation of JVM. The Java Runtime Environment is
                a set of software tools which are used for developing Java applications. It is used to provide the
                runtime environment. It is the implementation of JVM. It physically exists. It contains a set of
                libraries + other files that JVM uses at runtime.</p>

            <h3>JDK</h3>

            <p>JDK is an acronym for Java Development Kit. It is a software development environment which is used to
                develop Java applications and applets. It physically exists. It contains JRE + development tools. JDK is
                an implementation of any one of the below given Java Platforms released by Oracle Corporation:</p>

            <ul>
                <li>Standard Edition Java Platform</li>
                <li>Enterprise Edition Java Platform</li>
                <li>Micro Edition Java Platform</li>
            </ul>

            <p><a href="https://www.javatpoint.com/difference-between-jdk-jre-and-jvm">More Details.</a></p>

            <hr />
            <h3>6) How many types of memory areas are allocated by JVM?</h3>

            <p>Many types:</p>

            <ol>
                <li><strong>Class(Method) Area:</strong>&nbsp;Class Area stores per-class structures such as the runtime
                    constant pool, field, method data, and the code for methods.</li>
                <li><strong>Heap:</strong>&nbsp;It is the runtime data area in which the memory is allocated to the
                    objects</li>
                <li><strong>Stack:</strong>&nbsp;Java Stack stores frames. It holds local variables and partial results,
                    and plays a part in method invocation and return. Each thread has a private JVM stack, created at
                    the same time as the thread. A new frame is created each time a method is invoked. A frame is
                    destroyed when its method invocation completes.</li>
                <li><strong>Program Counter Register:</strong>&nbsp;PC (program counter) register contains the address
                    of the Java virtual machine instruction currently being executed.</li>
                <li><strong>Native Method Stack:</strong>&nbsp;It contains all the native methods used in the
                    application.</li>
            </ol>

            <p><a href="https://www.javatpoint.com/internal-details-of-jvm">More Details.</a></p>

            <hr />
            <h3>7) What is JIT compiler?</h3>

            <p><strong>Just-In-Time(JIT) compiler:</strong>&nbsp;It is used to improve the performance. JIT compiles
                parts of the bytecode that have similar functionality at the same time, and hence reduces the amount of
                time needed for compilation. Here the term &ldquo;compiler&rdquo; refers to a translator from the
                instruction set of a Java virtual machine (JVM) to the instruction set of a specific CPU.</p>

            <hr />
            <h3>8) What is the platform?</h3>

            <p>A platform is the hardware or software environment in which a piece of software is executed. There are
                two types of platforms, software-based and hardware-based. Java provides the software-based platform.
            </p>

            <hr />
            <h3>9) What are the main differences between the Java platform and other platforms?</h3>

            <p>There are the following differences between the Java platform and other platforms.</p>

            <ul>
                <li>Java is the software-based platform whereas other platforms may be the hardware platforms or
                    software-based platforms.</li>
                <li>Java is executed on the top of other hardware platforms whereas other platforms can only have the
                    hardware components.</li>
            </ul>

            <hr />
            <h3>10) What gives Java its &#39;write once and run anywhere&#39; nature?</h3>

            <p>The bytecode. Java compiler converts the Java programs into the class file (Byte Code) which is the
                intermediate language between source code and machine code. This bytecode is not platform specific and
                can be executed on any computer.</p>

            <hr />
            <h3>11) What is classloader?</h3>

            <p>Classloader is a subsystem of JVM which is used to load class files. Whenever we run the java program, it
                is loaded first by the classloader. There are three built-in classloaders in Java.</p>

            <ol>
                <li><strong>Bootstrap ClassLoader</strong>: This is the first classloader which is the superclass of
                    Extension classloader. It loads the&nbsp;<em>rt.jar</em>&nbsp;file which contains all class files of
                    Java Standard Edition like java.lang package classes, java.net package classes, java.util package
                    classes, java.io package classes, java.sql package classes, etc.</li>
                <li><strong>Extension ClassLoader</strong>: This is the child classloader of Bootstrap and parent
                    classloader of System classloader. It loads the jar files located
                    inside&nbsp;<em>$JAVA_HOME/jre/lib/ext</em>&nbsp;directory.</li>
                <li><strong>System/Application ClassLoader</strong>: This is the child classloader of Extension
                    classloader. It loads the class files from the classpath. By default, the classpath is set to the
                    current directory. You can change the classpath using &quot;-cp&quot; or &quot;-classpath&quot;
                    switch. It is also known as Application classloader.</li>
            </ol>

            <hr />
            <h3>12) Is Empty .java file name a valid source file name?</h3>

            <p>Yes, Java allows to save our java file by&nbsp;<strong>.java</strong>&nbsp;only, we need to compile it
                by&nbsp;<strong>javac .java</strong>&nbsp;and run by&nbsp;<strong>java classname</strong>&nbsp;Let&#39;s
                take a simple example:</p>

            <ol start="1">
                <li>//save&nbsp;by&nbsp;.java&nbsp;only&nbsp;&nbsp;</li>
                <li>class&nbsp;A{&nbsp;&nbsp;</li>
                <li>public&nbsp;static&nbsp;void&nbsp;main(String&nbsp;args[]){&nbsp;&nbsp;</li>
                <li>System.out.println(&quot;Hello&nbsp;java&quot;);&nbsp;&nbsp;</li>
                <li>}&nbsp;&nbsp;</li>
                <li>}&nbsp;&nbsp;</li>
                <li>//compile&nbsp;by&nbsp;javac&nbsp;.java&nbsp;&nbsp;</li>
                <li>//run&nbsp;by&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;java&nbsp;A&nbsp;&nbsp;</li>
            </ol>

            <p>compile it by&nbsp;<strong>javac .java</strong></p>

            <p>run it by&nbsp;<strong>java A</strong></p>

            <hr />
            <h3>13) Is delete, next, main, exit or null keyword in java?</h3>

            <p>No.</p>

            <hr />
            <h3>14) If I don&#39;t provide any arguments on the command line, then what will the value stored in the
                String array passed into the main() method, empty or NULL?</h3>

            <p>It is empty, but not null.</p>

            <hr />
            <h3>15) What if I write static public void instead of public static void?</h3>

            <p>The program compiles and runs correctly because the order of specifiers doesn&#39;t matter in Java.</p>

            <hr />
            <h3>16) What is the default value of the local variables?</h3>

            <p>The local variables are not initialized to any default value, neither primitives nor object references.
            </p>

            <hr />
            <h3>17) What are the various access specifiers in Java?</h3>

            <p>In Java, access specifiers are the keywords which are used to define the access scope of the method,
                class, or a variable. In Java, there are four access specifiers given below.</p>

            <ul>
                <li><strong>Public</strong>&nbsp;The classes, methods, or variables which are defined as public, can be
                    accessed by any class or method.</li>
                <li><strong>Protected</strong>&nbsp;Protected can be accessed by the class of the same package, or by
                    the sub-class of this class, or within the same class.</li>
                <li><strong>Default</strong>&nbsp;Default are accessible within the package only. By default, all the
                    classes, methods, and variables are of default scope.</li>
                <li><strong>Private</strong>&nbsp;The private class, methods, or variables defined as private can be
                    accessed within the class only.</li>
            </ul>

            <hr />
            <h3>18) What is the purpose of static methods and variables?</h3>

            <p>The methods or variables defined as static are shared among all the objects of the class. The static is
                the part of the class and not of the object. The static variables are stored in the class area, and we
                do not need to create the object to access such variables. Therefore, static is used in the case, where
                we need to define variables or methods which are common to all the objects of the class.</p>

            <p>For example, In the class simulating the collection of the students in a college, the name of the college
                is the common attribute to all the students. Therefore, the college name will be defined
                as&nbsp;<strong>static</strong>.</p>

            <hr />
            <h3>19) What are the advantages of Packages in Java?</h3>

            <p>There are various advantages of defining packages in Java.</p>

            <ul>
                <li>Packages avoid the name clashes.</li>
                <li>The Package provides easier access control.</li>
                <li>We can also have the hidden classes that are not visible outside and used by the package.</li>
                <li>It is easier to locate the related classes.</li>
            </ul>

            <hr />
            <h3>20) What is the output of the following Java program?</h3>

            <ol start="1">
                <li>class&nbsp;Test&nbsp;&nbsp;&nbsp;</li>
                <li>{&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;void&nbsp;main&nbsp;(String&nbsp;args[])&nbsp;&nbsp;&nbsp;
                </li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(10&nbsp;+&nbsp;20&nbsp;+&nbsp;&quot;Javatpoint&quot;);&nbsp;&nbsp;&nbsp;
                </li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(&quot;Javatpoint&quot;&nbsp;+&nbsp;10&nbsp;+&nbsp;20);&nbsp;&nbsp;
                </li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</li>
                <li>}&nbsp;&nbsp;</li>
            </ol>

            <p>The output of the above code will be</p>

            <pre>
30Javatpoint
Javatpoint1020
</pre>

            <p><strong>Explanation</strong></p>

            <p>In the first case, 10 and 20 are treated as numbers and added to be 30. Now, their sum 30 is treated as
                the string and concatenated with the string&nbsp;<strong>Javatpoint</strong>. Therefore, the output will
                be&nbsp;<strong>30Javatpoint</strong>.</p>

            <p>In the second case, the string Javatpoint is concatenated with 10 to be the
                string&nbsp;<strong>Javatpoint10</strong>&nbsp;which will then be concatenated with 20 to
                be&nbsp;<strong>Javatpoint1020</strong>.</p>

            <hr />
            <h3>21) What is the output of the following Java program?</h3>

            <ol start="1">
                <li>class&nbsp;Test&nbsp;&nbsp;&nbsp;</li>
                <li>{&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;void&nbsp;main&nbsp;(String&nbsp;args[])&nbsp;&nbsp;&nbsp;
                </li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(10&nbsp;*&nbsp;20&nbsp;+&nbsp;&quot;Javatpoint&quot;);&nbsp;&nbsp;&nbsp;
                </li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(&quot;Javatpoint&quot;&nbsp;+&nbsp;10&nbsp;*&nbsp;20);&nbsp;&nbsp;
                </li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</li>
                <li>}&nbsp;&nbsp;</li>
            </ol>

            <p>The output of the above code will be</p>

            <pre>
200Javatpoint
Javatpoint200
</pre>

            <p><strong>Explanation</strong></p>

            <p>In the first case, The numbers 10 and 20 will be multiplied first and then the result 200 is treated as
                the string and concatenated with the string&nbsp;<strong>Javatpoint</strong>&nbsp;to produce the
                output&nbsp;<strong>200Javatpoint</strong>.</p>

            <p>In the second case, The numbers 10 and 20 will be multiplied first to be 200 because the precedence of
                the multiplication is higher than addition. The result 200 will be treated as the string and
                concatenated with the string&nbsp;<strong>Javatpoint</strong>to produce the output
                as&nbsp;<strong>Javatpoint200</strong>.</p>

            <hr />
            <h3>22) What is the output of the following Java program?</h3>

            <ol start="1">
                <li>class&nbsp;Test&nbsp;&nbsp;&nbsp;</li>
                <li>{&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;void&nbsp;main&nbsp;(String&nbsp;args[])&nbsp;&nbsp;&nbsp;
                </li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for(int&nbsp;i=0;&nbsp;0;&nbsp;i++)&nbsp;&nbsp;&nbsp;
                </li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(&quot;Hello&nbsp;Javatpoint&quot;);&nbsp;&nbsp;
                </li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</li>
                <li>}&nbsp;&nbsp;</li>
            </ol>

            <p>The above code will give the compile-time error because the for loop demands a boolean value in the
                second part and we are providing an integer value, i.e., 0.</p>

            <hr />
            <h2><strong>Core Java - OOPs Concepts: Initial OOPs Interview Questions</strong></h2>

            <p>There is given more than 50 OOPs (Object-Oriented Programming and System) interview questions. However,
                they have been categorized in many sections such as constructor interview questions, static interview
                questions, Inheritance Interview questions, Abstraction interview question, Polymorphism interview
                questions, etc. for better understanding.</p>

            <hr />
            <h3>23) What is object-oriented paradigm?</h3>

            <p>It is a programming paradigm based on objects having data and methods defined in the class to which it
                belongs. Object-oriented paradigm aims to incorporate the advantages of modularity and reusability.
                Objects are the instances of classes which interacts with one another to design applications and
                programs. There are the following features of the object-oriented paradigm.</p>

            <ul>
                <li>Follows the bottom-up approach in program design.</li>
                <li>Focus on data with methods to operate upon the object&#39;s data</li>
                <li>Includes the concept like Encapsulation and abstraction which hides the complexities from the user
                    and show only functionality.</li>
                <li>Implements the real-time approach like inheritance, abstraction, etc.</li>
                <li>The examples of the object-oriented paradigm are C++, Simula, Smalltalk, Python, C#, etc.</li>
            </ul>

            <hr />
            <h3>24) What is an object?</h3>

            <p>The Object is the real-time entity having some state and behavior. In Java, Object is an instance of the
                class having the instance variables as the state of the object and the methods as the behavior of the
                object. The object of a class can be created by using the&nbsp;<strong>new</strong>&nbsp;keyword.</p>

            <hr />
            <h3>25) What is the difference between an object-oriented programming language and object-based programming
                language?</h3>

            <p>There are the following basic differences between the object-oriented language and object-based language.
            </p>

            <ul>
                <li>Object-oriented languages follow all the concepts of OOPs whereas, the object-based language
                    doesn&#39;t follow all the concepts of OOPs like inheritance and polymorphism.</li>
                <li>Object-oriented languages do not have the inbuilt objects whereas Object-based languages have the
                    inbuilt objects, for example, JavaScript has window object.</li>
                <li>Examples of object-oriented programming are Java, C#, Smalltalk, etc. whereas the examples of
                    object-based languages are JavaScript, VBScript, etc.</li>
            </ul>

            <hr />
            <h3>26) What will be the initial value of an object reference which is defined as an instance variable?</h3>

            <p>All object references are initialized to null in Java.</p>

            <hr />
            <h2><strong>Core Java - OOPs Concepts: Constructor Interview Questions</strong></h2>

            <hr />
            <h3>27) What is the constructor?</h3>

            <p>The constructor can be defined as the special type of method that is used to initialize the state of an
                object. It is invoked when the class is instantiated, and the memory is allocated for the object. Every
                time, an object is created using the&nbsp;<strong>new</strong>&nbsp;keyword, the default constructor of
                the class is called. The name of the constructor must be similar to the class name. The constructor must
                not have an explicit return type.</p>

            <p><a href="https://www.javatpoint.com/constructor">More Details.</a></p>

            <hr />
            <h3>28) How many types of constructors are used in Java?</h3>

            <p>Based on the parameters passed in the constructors, there are two types of constructors in Java.</p>

            <ul>
                <li><strong>Default Constructor:</strong>&nbsp;default constructor is the one which does not accept any
                    value. The default constructor is mainly used to initialize the instance variable with the default
                    values. It can also be used for performing some useful task on object creation. A default
                    constructor is invoked implicitly by the compiler if there is no constructor defined in the class.
                </li>
                <li><strong>Parameterized Constructor:</strong>&nbsp;The parameterized constructor is the one which can
                    initialize the instance variables with the given values. In other words, we can say that the
                    constructors which can accept the arguments are called parameterized constructors.</li>
            </ul>

            <p><img alt="Java Constructors" src="https://static.javatpoint.com/images/core/java-constructor.png" /></p>

            <hr />
            <h3>29) What is the purpose of a default constructor?</h3>

            <p>The purpose of the default constructor is to assign the default value to the objects. The java compiler
                creates a default constructor implicitly if there is no constructor in the class.</p>

            <ol start="1">
                <li>class&nbsp;Student3{&nbsp;&nbsp;</li>
                <li>int&nbsp;id;&nbsp;&nbsp;</li>
                <li>String&nbsp;name;&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;</li>
                <li>void&nbsp;display(){System.out.println(id+&quot;&nbsp;&quot;+name);}&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;</li>
                <li>public&nbsp;static&nbsp;void&nbsp;main(String&nbsp;args[]){&nbsp;&nbsp;</li>
                <li>Student3&nbsp;s1=new&nbsp;Student3();&nbsp;&nbsp;</li>
                <li>Student3&nbsp;s2=new&nbsp;Student3();&nbsp;&nbsp;</li>
                <li>s1.display();&nbsp;&nbsp;</li>
                <li>s2.display();&nbsp;&nbsp;</li>
                <li>}&nbsp;&nbsp;</li>
                <li>}&nbsp;&nbsp;</li>
            </ol>

            <p><a href="https://www.javatpoint.com/opr/test.jsp?filename=Student3" target="_blank">Test it Now</a></p>

            <p>Output:</p>

            <pre>
0 null
0 null
</pre>

            <p><strong>Explanation:</strong>&nbsp;In the above class, you are not creating any constructor, so compiler
                provides you a default constructor. Here 0 and null values are provided by default constructor.</p>

            <p><img alt="Java default constructor"
                    src="https://static.javatpoint.com/images/default-constructor1.png" /><br />
                <a href="https://www.javatpoint.com/constructor">More Details.</a>
            </p>

            <hr />
            <h3>30) Does constructor return any value?</h3>

            <p><strong>Ans:</strong>&nbsp;yes, The constructor implicitly returns the current instance of the class (You
                can&#39;t use an explicit return type with the constructor).<a
                    href="https://www.javatpoint.com/constructor">&nbsp;More Details.</a></p>

            <hr />
            <h3>31)Is constructor inherited?</h3>

            <p>No, The constructor is not inherited.</p>

            <hr />
            <h3>32) Can you make a constructor final?</h3>

            <p>No, the constructor can&#39;t be final.</p>

            <hr />
            <h3>33) Can we overload the constructors?</h3>

            <p>Yes, the constructors can be overloaded by changing the number of arguments accepted by the constructor
                or by changing the data type of the parameters. Consider the following example.</p>

            <ol start="1">
                <li>class&nbsp;Test&nbsp;&nbsp;&nbsp;</li>
                <li>{&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;i;&nbsp;&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;Test(int&nbsp;k)&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;i=k;&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;Test(int&nbsp;k,&nbsp;int&nbsp;m)&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(&quot;Hi&nbsp;I&nbsp;am&nbsp;assigning&nbsp;the&nbsp;value&nbsp;max(k,&nbsp;m)&nbsp;to&nbsp;i&quot;);&nbsp;&nbsp;
                </li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(k&gt;m)&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;i=k;&nbsp;&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else&nbsp;&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;i=m;&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</li>
                <li>}&nbsp;&nbsp;</li>
                <li>public&nbsp;class&nbsp;Main&nbsp;&nbsp;&nbsp;</li>
                <li>{&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;void&nbsp;main&nbsp;(String&nbsp;args[])&nbsp;&nbsp;&nbsp;
                </li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Test&nbsp;test1&nbsp;=&nbsp;new&nbsp;Test(10);&nbsp;&nbsp;
                </li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Test&nbsp;test2&nbsp;=&nbsp;new&nbsp;Test(12,&nbsp;15);&nbsp;&nbsp;
                </li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(test1.i);&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(test2.i);&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</li>
                <li>}&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</li>
            </ol>

            <p>In the above program, The constructor Test is overloaded with another constructor. In the first call to
                the constructor, The constructor with one argument is called, and i will be initialized with the value
                10. However, In the second call to the constructor, The constructor with the 2 arguments is called, and
                i will be initialized with the value 15.</p>

            <hr />
            <h3>34) What do you understand by copy constructor in Java?</h3>

            <p>There is no copy constructor in java. However, we can copy the values from one object to another like
                copy constructor in C++.</p>

            <p>There are many ways to copy the values of one object into another in java. They are:</p>

            <ul>
                <li>By constructor</li>
                <li>By assigning the values of one object into another</li>
                <li>By clone() method of Object class</li>
            </ul>

            <p>In this example, we are going to copy the values of one object into another using java constructor.</p>

            <ol start="1">
                <li>//Java&nbsp;program&nbsp;to&nbsp;initialize&nbsp;the&nbsp;values&nbsp;from&nbsp;one&nbsp;object&nbsp;to&nbsp;another&nbsp;&nbsp;
                </li>
                <li>class&nbsp;Student6{&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;id;&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;String&nbsp;name;&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;//constructor&nbsp;to&nbsp;initialize&nbsp;integer&nbsp;and&nbsp;string&nbsp;&nbsp;
                </li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;Student6(int&nbsp;i,String&nbsp;n){&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;id&nbsp;=&nbsp;i;&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;name&nbsp;=&nbsp;n;&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;//constructor&nbsp;to&nbsp;initialize&nbsp;another&nbsp;object&nbsp;&nbsp;
                </li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;Student6(Student6&nbsp;s){&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;id&nbsp;=&nbsp;s.id;&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;name&nbsp;=s.name;&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;void&nbsp;display(){System.out.println(id+&quot;&nbsp;&quot;+name);}&nbsp;&nbsp;
                </li>
                <li>&nbsp;&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;void&nbsp;main(String&nbsp;args[]){&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;Student6&nbsp;s1&nbsp;=&nbsp;new&nbsp;Student6(111,&quot;Karan&quot;);&nbsp;&nbsp;
                </li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;Student6&nbsp;s2&nbsp;=&nbsp;new&nbsp;Student6(s1);&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;s1.display();&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;s2.display();&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</li>
                <li>}&nbsp;&nbsp;</li>
            </ol>

            <p><a href="https://www.javatpoint.com/opr/test.jsp?filename=Student6" target="_blank">Test it Now</a></p>

            <p>Output:</p>

            <p>&nbsp;</p>

            <pre>
111 Karan
111 Karan
</pre>

            <hr />
            <h3>35) What are the differences between the constructors and methods?</h3>

            <p>There are many differences between constructors and methods. They are given below.</p>

            <table>
                <tbody>
                    <tr>
                        <th>Java Constructor</th>
                        <th>Java Method</th>
                    </tr>
                    <tr>
                        <td>A constructor is used to initialize the state of an object.</td>
                        <td>A method is used to expose the behavior of an object.</td>
                    </tr>
                    <tr>
                        <td>A constructor must not have a return type.</td>
                        <td>A method must have a return type.</td>
                    </tr>
                    <tr>
                        <td>The constructor is invoked implicitly.</td>
                        <td>The method is invoked explicitly.</td>
                    </tr>
                    <tr>
                        <td>The Java compiler provides a default constructor if you don&#39;t have any constructor in a
                            class.</td>
                        <td>The method is not provided by the compiler in any case.</td>
                    </tr>
                    <tr>
                        <td>The constructor name must be same as the class name.</td>
                        <td>The method name may or may not be same as class name.</td>
                    </tr>
                </tbody>
            </table>

            <p><br />
                <img alt="Java Constructors vs Methods"
                    src="https://static.javatpoint.com/images/constructor-vs-method-in-java.jpg" />
            </p>

            <hr />
            <h3>36) What is the output of the following Java program?</h3>

            <ol start="1">
                <li>public&nbsp;class&nbsp;Test&nbsp;&nbsp;&nbsp;</li>
                <li>{&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;Test(int&nbsp;a,&nbsp;int&nbsp;b)&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(&quot;a&nbsp;=&nbsp;&quot;+a+&quot;&nbsp;b&nbsp;=&nbsp;&quot;+b);&nbsp;&nbsp;
                </li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;Test(int&nbsp;a,&nbsp;float&nbsp;b)&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(&quot;a&nbsp;=&nbsp;&quot;+a+&quot;&nbsp;b&nbsp;=&nbsp;&quot;+b);&nbsp;&nbsp;
                </li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;void&nbsp;main&nbsp;(String&nbsp;args[])&nbsp;&nbsp;
                </li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;byte&nbsp;a&nbsp;=&nbsp;10;&nbsp;&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;byte&nbsp;b&nbsp;=&nbsp;15;&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Test&nbsp;test&nbsp;=&nbsp;new&nbsp;Test(a,b);&nbsp;&nbsp;
                </li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</li>
                <li>}&nbsp;&nbsp;</li>
            </ol>

            <p>The output of the following program is:</p>

            <pre>
a = 10 b = 15
</pre>

            <p>Here, the data type of the variables a and b, i.e., byte gets promoted to int, and the first
                parameterized constructor with the two integer parameters is called.</p>

            <hr />
            <h3>37) What is the output of the following Java program?</h3>

            <ol start="1">
                <li>class&nbsp;Test&nbsp;&nbsp;&nbsp;</li>
                <li>{&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;i;&nbsp;&nbsp;&nbsp;</li>
                <li>}&nbsp;&nbsp;</li>
                <li>public&nbsp;class&nbsp;Main&nbsp;&nbsp;&nbsp;</li>
                <li>{&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;void&nbsp;main&nbsp;(String&nbsp;args[])&nbsp;&nbsp;&nbsp;
                </li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Test&nbsp;test&nbsp;=&nbsp;new&nbsp;Test();&nbsp;&nbsp;&nbsp;
                </li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(test.i);&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</li>
                <li>}&nbsp;&nbsp;</li>
            </ol>

            <p>The output of the program is 0 because the variable i is initialized to 0 internally. As we know that a
                default constructor is invoked implicitly if there is no constructor in the class, the variable i is
                initialized to 0 since there is no constructor in the class.</p>

            <hr />
            <h3>38) What is the output of the following Java program?</h3>

            <ol start="1">
                <li>class&nbsp;Test&nbsp;&nbsp;&nbsp;</li>
                <li>{&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;test_a,&nbsp;test_b;&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;Test(int&nbsp;a,&nbsp;int&nbsp;b)&nbsp;&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;test_a&nbsp;=&nbsp;a;&nbsp;&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;test_b&nbsp;=&nbsp;b;&nbsp;&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;void&nbsp;main&nbsp;(String&nbsp;args[])&nbsp;&nbsp;&nbsp;
                </li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Test&nbsp;test&nbsp;=&nbsp;new&nbsp;Test();&nbsp;&nbsp;&nbsp;
                </li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(test.test_a+&quot;&nbsp;&quot;+test.test_b);&nbsp;&nbsp;
                </li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</li>
                <li>}&nbsp;&nbsp;</li>
            </ol>

            <p>There is a&nbsp;<strong>compiler error</strong>&nbsp;in the program because there is a call to the
                default constructor in the main method which is not present in the class. However, there is only one
                parameterized constructor in the class Test. Therefore, no default constructor is invoked by the
                constructor implicitly.</p>

            <hr />
            <h2><strong>Core Java - OOPs Concepts: static keyword Interview Questions</strong></h2>

            <hr />
            <h3>39) What is the static variable?</h3>

            <p>The static variable is used to refer to the common property of all objects (that is not unique for each
                object), e.g., The company name of employees, college name of students, etc. Static variable gets memory
                only once in the class area at the time of class loading. Using a static variable makes your program
                more memory efficient (it saves memory). Static variable belongs to the class rather than the object.
            </p>

            <ol start="1">
                <li>//Program&nbsp;of&nbsp;static&nbsp;variable&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;</li>
                <li>class&nbsp;Student8{&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;int&nbsp;rollno;&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;String&nbsp;name;&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;static&nbsp;String&nbsp;college&nbsp;=&quot;ITS&quot;;&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;Student8(int&nbsp;r,String&nbsp;n){&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;rollno&nbsp;=&nbsp;r;&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;name&nbsp;=&nbsp;n;&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</li>
                <li>&nbsp;void&nbsp;display&nbsp;(){System.out.println(rollno+&quot;&nbsp;&quot;+name+&quot;&nbsp;&quot;+college);}&nbsp;&nbsp;
                </li>
                <li>&nbsp;&nbsp;</li>
                <li>&nbsp;public&nbsp;static&nbsp;void&nbsp;main(String&nbsp;args[]){&nbsp;&nbsp;</li>
                <li>&nbsp;Student8&nbsp;s1&nbsp;=&nbsp;new&nbsp;Student8(111,&quot;Karan&quot;);&nbsp;&nbsp;</li>
                <li>&nbsp;Student8&nbsp;s2&nbsp;=&nbsp;new&nbsp;Student8(222,&quot;Aryan&quot;);&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;</li>
                <li>&nbsp;s1.display();&nbsp;&nbsp;</li>
                <li>&nbsp;s2.display();&nbsp;&nbsp;</li>
                <li>&nbsp;}&nbsp;&nbsp;</li>
                <li>}&nbsp;&nbsp;</li>
            </ol>

            <p><a href="https://www.javatpoint.com/opr/test.jsp?filename=Student8" target="_blank">Test it Now</a></p>

            <pre>
Output:111 Karan ITS
       222 Aryan ITS
</pre>

            <p><img alt="Static Variable" src="https://static.javatpoint.com/images/staticvariable.JPG" /><br />
                <a href="https://www.javatpoint.com/static-keyword-in-java">More Details.</a>
            </p>

            <hr />
            <h3>40) What is the static method?</h3>

            <ul>
                <li>A static method belongs to the class rather than the object.</li>
                <li>There is no need to create the object to call the static methods.</li>
                <li>A static method can access and change the value of the static variable.</li>
            </ul>

            <p><a href="https://www.javatpoint.com/static-keyword-in-java">More Details.</a></p>

            <hr />
            <h3>41) What are the restrictions that are applied to the Java static methods?</h3>

            <p>Two main restrictions are applied to the static methods.</p>

            <ul>
                <li>The static method can not use non-static data member or call the non-static method directly.</li>
                <li>this and super cannot be used in static context as they are non-static.</li>
            </ul>

            <hr />
            <h3>42) Why is the main method static?</h3>

            <p>Because the object is not required to call the static method. If we make the main method non-static, JVM
                will have to create its object first and then call main() method which will lead to the extra memory
                allocation.<a href="https://www.javatpoint.com/static-keyword-in-java">&nbsp;More Details.</a></p>

            <hr />
            <h3>43) Can we override the static methods?</h3>

            <p>No, we can&#39;t override static methods.</p>

            <h3>44) What is the static block?</h3>

            <p>Static block is used to initialize the static data member. It is executed before the main method, at the
                time of classloading.</p>

            <ol start="1">
                <li>class&nbsp;A2{&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;static{System.out.println(&quot;static&nbsp;block&nbsp;is&nbsp;invoked&quot;);}&nbsp;&nbsp;
                </li>
                <li>&nbsp;&nbsp;public&nbsp;static&nbsp;void&nbsp;main(String&nbsp;args[]){&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;System.out.println(&quot;Hello&nbsp;main&quot;);&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;}&nbsp;&nbsp;</li>
                <li>}&nbsp;&nbsp;</li>
            </ol>

            <p><a href="https://www.javatpoint.com/opr/test.jsp?filename=A2" target="_blank">Test it Now</a></p>

            <pre>
Output: static block is invoked
       Hello main
</pre>

            <p><br />
                <a href="https://www.javatpoint.com/static-keyword-in-java">More Details.</a>
            </p>

            <hr />
            <h3>45) Can we execute a program without main() method?</h3>

            <p>Ans) No, It was possible before JDK 1.7 using the static block. Since JDK 1.7, it is not
                possible.&nbsp;<a href="https://www.javatpoint.com/static-keyword-in-java">More Details.</a></p>

            <hr />
            <h3>46) What if the static modifier is removed from the signature of the main method?</h3>

            <p>Program compiles. However, at runtime, It throws an error &quot;NoSuchMethodError.&quot;</p>

            <hr />
            <h3>47) What is the difference between static (class) method and instance method?</h3>

            <table>
                <tbody>
                    <tr>
                        <th>static or class method</th>
                        <th>instance method</th>
                    </tr>
                    <tr>
                        <td>1)A method that is declared as static is known as the static method.</td>
                        <td>A method that is not declared as static is known as the instance method.</td>
                    </tr>
                    <tr>
                        <td>2)We don&#39;t need to create the objects to call the static methods.</td>
                        <td>The object is required to call the instance methods.</td>
                    </tr>
                    <tr>
                        <td>3)Non-static (instance) members cannot be accessed in the static context (static method,
                            static block, and static nested class) directly.</td>
                        <td>Static and non-static variables both can be accessed in instance methods.</td>
                    </tr>
                    <tr>
                        <td>4)For example: public static int cube(int n){ return n*n*n;}</td>
                        <td>For example: public void msg(){...}.</td>
                    </tr>
                </tbody>
            </table>

            <hr />
            <h3>48) Can we make constructors static?</h3>

            <p>As we know that the static context (method, block, or variable) belongs to the class, not the object.
                Since Constructors are invoked only when the object is created, there is no sense to make the
                constructors static. However, if you try to do so, the compiler will show the compiler error.</p>

            <hr />
            <h3>49) Can we make the abstract methods static in Java?</h3>

            <p>In Java, if we make the abstract methods static, It will become the part of the class, and we can
                directly call it which is unnecessary. Calling an undefined method is completely useless therefore it is
                not allowed.</p>

            <hr />
            <h3>50) Can we declare the static variables and methods in an abstract class?</h3>

            <p>Yes, we can declare static variables and methods in an abstract method. As we know that there is no
                requirement to make the object to access the static context, therefore, we can access the static context
                declared inside the abstract class by using the name of the abstract class. Consider the following
                example.</p>

            <ol start="1">
                <li>abstract&nbsp;class&nbsp;Test&nbsp;&nbsp;</li>
                <li>{&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;static&nbsp;int&nbsp;i&nbsp;=&nbsp;102;&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;static&nbsp;void&nbsp;TestMethod()&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(&quot;hi&nbsp;!!&nbsp;I&nbsp;am&nbsp;good&nbsp;!!&quot;);&nbsp;&nbsp;
                </li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</li>
                <li>}&nbsp;&nbsp;</li>
                <li>public&nbsp;class&nbsp;TestClass&nbsp;extends&nbsp;Test&nbsp;&nbsp;&nbsp;</li>
                <li>{&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;void&nbsp;main&nbsp;(String&nbsp;args[])&nbsp;&nbsp;
                </li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Test.TestMethod();&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(&quot;i&nbsp;=&nbsp;&quot;+Test.i);&nbsp;&nbsp;
                </li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</li>
                <li>}&nbsp;&nbsp;</li>
            </ol>

            <p><strong>Output</strong></p>

            <pre>
hi !! I am good !!
i = 102
</pre>

            <hr />
            <h2><strong>Core Java - OOPs Concepts: Inheritance Interview Questions</strong></h2>

            <hr />
            <h3>51) What is&nbsp;<strong>this</strong>&nbsp;keyword in java?</h3>

            <p>The&nbsp;<strong>this</strong>&nbsp;keyword is a reference variable that refers to the current object.
                There are the various uses of this keyword in Java. It can be used to refer to current class properties
                such as instance methods, variable, constructors, etc. It can also be passed as an argument into the
                methods or constructors. It can also be returned from the method as the current class instance.</p>

            <p><img alt="java this keyword" src="https://static.javatpoint.com/images/thisr.jpg" /><br />
                <a href="https://www.javatpoint.com/this-keyword">More Details.</a>
            </p>

            <hr />
            <h3>52) What are the main uses of this keyword?</h3>

            <p>There are the following uses of&nbsp;<strong>this</strong>&nbsp;keyword.</p>

            <ul>
                <li><strong>this</strong>&nbsp;can be used to refer to the current class instance variable.</li>
                <li><strong>this</strong>&nbsp;can be used to invoke current class method (implicitly)</li>
                <li><strong>this()</strong>&nbsp;can be used to invoke the current class constructor.</li>
                <li><strong>this</strong>&nbsp;can be passed as an argument in the method call.</li>
                <li><strong>this</strong>&nbsp;can be passed as an argument in the constructor call.</li>
                <li><strong>this</strong>&nbsp;can be used to return the current class instance from the method.</li>
            </ul>

            <hr />
            <h3>53) Can we assign the reference to&nbsp;<strong>this</strong>&nbsp;variable?</h3>

            <p>No, this cannot be assigned to any value because it always points to the current class object and this is
                the final reference in Java. However, if we try to do so, the compiler error will be shown. Consider the
                following example.</p>

            <ol start="1">
                <li>public&nbsp;class&nbsp;Test&nbsp;&nbsp;</li>
                <li>{&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;Test()&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this&nbsp;=&nbsp;null;&nbsp;&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(&quot;Test&nbsp;class&nbsp;constructor&nbsp;called&quot;);&nbsp;&nbsp;
                </li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;void&nbsp;main&nbsp;(String&nbsp;args[])&nbsp;&nbsp;
                </li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Test&nbsp;t&nbsp;=&nbsp;new&nbsp;Test();&nbsp;&nbsp;
                </li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</li>
                <li>}&nbsp;&nbsp;</li>
            </ol>

            <p><strong>Output</strong></p>

            <pre>
Test.java:5: error: cannot assign a value to final variable this
        this = null; 
        ^
1 error
</pre>

            <hr />
            <h3>54) Can&nbsp;<strong>this</strong>&nbsp;keyword be used to refer static members?</h3>

            <p>Yes, It is possible to use this keyword to refer static members because this is just a reference variable
                which refers to the current class object. However, as we know that, it is unnecessary to access static
                variables through objects, therefore, it is not the best practice to use this to refer static members.
                Consider the following example.</p>

            <ol start="1">
                <li>public&nbsp;class&nbsp;Test&nbsp;&nbsp;&nbsp;</li>
                <li>{&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;static&nbsp;int&nbsp;i&nbsp;=&nbsp;10;&nbsp;&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;Test&nbsp;()&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(this.i);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
                </li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;void&nbsp;main&nbsp;(String&nbsp;args[])&nbsp;&nbsp;
                </li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Test&nbsp;t&nbsp;=&nbsp;new&nbsp;Test();&nbsp;&nbsp;
                </li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</li>
                <li>}&nbsp;&nbsp;</li>
            </ol>

            <p><strong>Output</strong></p>

            <pre>
10
</pre>

            <hr />
            <h3>55) How can constructor chaining be done using this keyword?</h3>

            <p>Constructor chaining enables us to call one constructor from another constructor of the class with
                respect to the current class object. We can use this keyword to perform constructor chaining within the
                same class. Consider the following example which illustrates how can we use this keyword to achieve
                constructor chaining.</p>

            <ol start="1">
                <li>public&nbsp;class&nbsp;Employee&nbsp;&nbsp;</li>
                <li>{&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;id,age;&nbsp;&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;String&nbsp;name,&nbsp;address;&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;Employee&nbsp;(int&nbsp;age)&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.age&nbsp;=&nbsp;age;&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;Employee(int&nbsp;id,&nbsp;int&nbsp;age)&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this(age);&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.id&nbsp;=&nbsp;id;&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;Employee(int&nbsp;id,&nbsp;int&nbsp;age,&nbsp;String&nbsp;name,&nbsp;String&nbsp;address)&nbsp;&nbsp;
                </li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this(id,&nbsp;age);&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.name&nbsp;=&nbsp;name;&nbsp;&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.address&nbsp;=&nbsp;address;&nbsp;&nbsp;&nbsp;
                </li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;void&nbsp;main&nbsp;(String&nbsp;args[])&nbsp;&nbsp;
                </li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Employee&nbsp;emp&nbsp;=&nbsp;new&nbsp;Employee(105,&nbsp;22,&nbsp;&quot;Vikas&quot;,&nbsp;&quot;Delhi&quot;);&nbsp;&nbsp;
                </li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(&quot;ID:&nbsp;&quot;+emp.id+&quot;&nbsp;Name:&quot;+emp.name+&quot;&nbsp;age:&quot;+emp.age+&quot;&nbsp;address:&nbsp;&quot;+emp.address);&nbsp;&nbsp;
                </li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</li>
                <li>}&nbsp;&nbsp;</li>
            </ol>

            <p><strong>Output</strong></p>

            <pre>
ID: 105 Name:Vikas age:22 address: Delhi
</pre>

            <hr />
            <h3>56) What are the advantages of passing this into a method instead of the current class object itself?
            </h3>

            <p>As we know, that this refers to the current class object, therefore, it must be similar to the current
                class object. However, there can be two main advantages of passing this into a method instead of the
                current class object.</p>

            <ul>
                <li>this is a final variable. Therefore, this cannot be assigned to any new value whereas the current
                    class object might not be final and can be changed.</li>
                <li>this can be used in the synchronized block.</li>
            </ul>

            <hr />
            <h3>57) What is the Inheritance?</h3>

            <p>Inheritance is a mechanism by which one object acquires all the properties and behavior of another object
                of another class. It is used for Code Reusability and Method Overriding. The idea behind inheritance in
                Java is that you can create new classes that are built upon existing classes. When you inherit from an
                existing class, you can reuse methods and fields of the parent class. Moreover, you can add new methods
                and fields in your current class also. Inheritance represents the IS-A relationship which is also known
                as a parent-child relationship.</p>

            <p>There are five types of inheritance in Java.</p>

            <ul>
                <li>Single-level inheritance</li>
                <li>Multi-level inheritance</li>
                <li>Multiple Inheritance</li>
                <li>Hierarchical Inheritance</li>
                <li>Hybrid Inheritance</li>
            </ul>

            <p>Multiple inheritance is not supported in Java through class.</p>

            <p><a href="https://www.javatpoint.com/inheritance-in-java">More Details.</a></p>

            <hr />
            <h3>58) Why is Inheritance used in Java?</h3>

            <p>There are various advantages of using inheritance in Java that is given below.</p>

            <ul>
                <li>Inheritance provides code reusability. The derived class does not need to redefine the method of
                    base class unless it needs to provide the specific implementation of the method.</li>
                <li>Runtime polymorphism cannot be achieved without using inheritance.</li>
                <li>We can simulate the inheritance of classes with the real-time objects which makes OOPs more
                    realistic.</li>
                <li>Inheritance provides data hiding. The base class can hide some data from the derived class by making
                    it private.</li>
                <li>Method overriding cannot be achieved without inheritance. By method overriding, we can give a
                    specific implementation of some basic method contained by the base class.</li>
            </ul>

            <hr />
            <h3>59) Which class is the superclass for all the classes?</h3>

            <p>The object class is the superclass of all other classes in Java.</p>

            <hr />
            <h3>60) Why is multiple inheritance not supported in java?</h3>

            <p>To reduce the complexity and simplify the language, multiple inheritance is not supported in java.
                Consider a scenario where A, B, and C are three classes. The C class inherits A and B classes. If A and
                B classes have the same method and you call it from child class object, there will be ambiguity to call
                the method of A or B class.</p>

            <p>Since the compile-time errors are better than runtime errors, Java renders compile-time error if you
                inherit 2 classes. So whether you have the same method or different, there will be a compile time error.
            </p>

            <ol start="1">
                <li>class&nbsp;A{&nbsp;&nbsp;</li>
                <li>void&nbsp;msg(){System.out.println(&quot;Hello&quot;);}&nbsp;&nbsp;</li>
                <li>}&nbsp;&nbsp;</li>
                <li>class&nbsp;B{&nbsp;&nbsp;</li>
                <li>void&nbsp;msg(){System.out.println(&quot;Welcome&quot;);}&nbsp;&nbsp;</li>
                <li>}&nbsp;&nbsp;</li>
                <li>class&nbsp;C&nbsp;extends&nbsp;A,B{//suppose&nbsp;if&nbsp;it&nbsp;were&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;</li>
                <li>&nbsp;Public&nbsp;Static&nbsp;void&nbsp;main(String&nbsp;args[]){&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;C&nbsp;obj=new&nbsp;C();&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;obj.msg();//Now&nbsp;which&nbsp;msg()&nbsp;method&nbsp;would&nbsp;be&nbsp;invoked?&nbsp;&nbsp;
                </li>
                <li>}&nbsp;&nbsp;</li>
                <li>}&nbsp;&nbsp;</li>
            </ol>

            <p><a href="https://www.javatpoint.com/opr/test.jsp?filename=C" target="_blank">Test it Now</a></p>

            <pre>
 Compile Time Error
</pre>

            <hr />
            <h3>61) What is aggregation?</h3>

            <p>Aggregation can be defined as the relationship between two classes where the aggregate class contains a
                reference to the class it owns. Aggregation is best described as
                a&nbsp;<strong>has-a</strong>&nbsp;relationship. For example, The aggregate class Employee having
                various fields such as age, name, and salary also contains an object of Address class having various
                fields such as Address-Line 1, City, State, and pin-code. In other words, we can say that Employee
                (class) has an object of Address class. Consider the following example.</p>

            <p><strong>Address.java</strong></p>

            <ol start="1">
                <li>public&nbsp;class&nbsp;Address&nbsp;{&nbsp;&nbsp;</li>
                <li>String&nbsp;city,state,country;&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;</li>
                <li>public&nbsp;Address(String&nbsp;city,&nbsp;String&nbsp;state,&nbsp;String&nbsp;country)&nbsp;{&nbsp;&nbsp;
                </li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;this.city&nbsp;=&nbsp;city;&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;this.state&nbsp;=&nbsp;state;&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;this.country&nbsp;=&nbsp;country;&nbsp;&nbsp;</li>
                <li>}&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;</li>
                <li>}&nbsp;&nbsp;</li>
            </ol>

            <p><strong>Employee.java</strong></p>

            <p>&nbsp;</p>

            <ol start="1">
                <li>public&nbsp;class&nbsp;Emp&nbsp;{&nbsp;&nbsp;</li>
                <li>int&nbsp;id;&nbsp;&nbsp;</li>
                <li>String&nbsp;name;&nbsp;&nbsp;</li>
                <li>Address&nbsp;address;&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;</li>
                <li>public&nbsp;Emp(int&nbsp;id,&nbsp;String&nbsp;name,Address&nbsp;address)&nbsp;{&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;this.id&nbsp;=&nbsp;id;&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;this.name&nbsp;=&nbsp;name;&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;this.address=address;&nbsp;&nbsp;</li>
                <li>}&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;</li>
                <li>void&nbsp;display(){&nbsp;&nbsp;</li>
                <li>System.out.println(id+&quot;&nbsp;&quot;+name);&nbsp;&nbsp;</li>
                <li>System.out.println(address.city+&quot;&nbsp;&quot;+address.state+&quot;&nbsp;&quot;+address.country);&nbsp;&nbsp;
                </li>
                <li>}&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;</li>
                <li>public&nbsp;static&nbsp;void&nbsp;main(String[]&nbsp;args)&nbsp;{&nbsp;&nbsp;</li>
                <li>Address&nbsp;address1=new&nbsp;Address(&quot;gzb&quot;,&quot;UP&quot;,&quot;india&quot;);&nbsp;&nbsp;
                </li>
                <li>Address&nbsp;address2=new&nbsp;Address(&quot;gno&quot;,&quot;UP&quot;,&quot;india&quot;);&nbsp;&nbsp;
                </li>
                <li>&nbsp;&nbsp;</li>
                <li>Emp&nbsp;e=new&nbsp;Emp(111,&quot;varun&quot;,address1);&nbsp;&nbsp;</li>
                <li>Emp&nbsp;e2=new&nbsp;Emp(112,&quot;arun&quot;,address2);&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</li>
                <li>e.display();&nbsp;&nbsp;</li>
                <li>e2.display();&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</li>
                <li>}&nbsp;&nbsp;</li>
                <li>}&nbsp;&nbsp;</li>
            </ol>

            <p><strong>Output</strong></p>

            <pre>
111 varun
gzb UP india
112 arun
gno UP india 
</pre>

            <hr />
            <h3>62) What is composition?</h3>

            <p>Holding the reference of a class within some other class is known as composition. When an object contains
                the other object, if the contained object cannot exist without the existence of container object, then
                it is called composition. In other words, we can say that composition is the particular case of
                aggregation which represents a stronger relationship between two objects. Example: A class contains
                students. A student cannot exist without a class. There exists composition between class and students.
            </p>

            <hr />
            <h3>63) What is the difference between aggregation and composition?</h3>

            <p>Aggregation represents the weak relationship whereas composition represents the strong relationship. For
                example, the bike has an indicator (aggregation), but the bike has an engine (composition).</p>

            <hr />
            <h3>64) Why does Java not support pointers?</h3>

            <p>The pointer is a variable that refers to the memory address. They are not used in Java because they are
                unsafe(unsecured) and complex to understand.</p>

            <hr />
            <h3>65) What is super in java?</h3>

            <p>The&nbsp;<strong>super</strong>&nbsp;keyword in Java is a reference variable that is used to refer to the
                immediate parent class object. Whenever you create the instance of the subclass, an instance of the
                parent class is created implicitly which is referred by super reference variable. The super() is called
                in the class constructor implicitly by the compiler if there is no super or this.</p>

            <ol start="1">
                <li>class&nbsp;Animal{&nbsp;&nbsp;</li>
                <li>Animal(){System.out.println(&quot;animal&nbsp;is&nbsp;created&quot;);}&nbsp;&nbsp;</li>
                <li>}&nbsp;&nbsp;</li>
                <li>class&nbsp;Dog&nbsp;extends&nbsp;Animal{&nbsp;&nbsp;</li>
                <li>Dog(){&nbsp;&nbsp;</li>
                <li>System.out.println(&quot;dog&nbsp;is&nbsp;created&quot;);&nbsp;&nbsp;</li>
                <li>}&nbsp;&nbsp;</li>
                <li>}&nbsp;&nbsp;</li>
                <li>class&nbsp;TestSuper4{&nbsp;&nbsp;</li>
                <li>public&nbsp;static&nbsp;void&nbsp;main(String&nbsp;args[]){&nbsp;&nbsp;</li>
                <li>Dog&nbsp;d=new&nbsp;Dog();&nbsp;&nbsp;</li>
                <li>}&nbsp;&nbsp;</li>
                <li>}&nbsp;&nbsp;</li>
            </ol>

            <p><a href="https://www.javatpoint.com/opr/test.jsp?filename=TestSuper4" target="_blank">Test it Now</a></p>

            <p>Output:</p>

            <pre>
animal is created
dog is created
</pre>

            <p><a href="https://www.javatpoint.com/super-keyword">More Details.</a></p>

            <hr />
            <h3>66) How can constructor chaining be done by using the super keyword?</h3>

            <p>&nbsp;</p>

            <ol start="1">
                <li>class&nbsp;Person&nbsp;&nbsp;</li>
                <li>{&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;String&nbsp;name,address;&nbsp;&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;age;&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;Person(int&nbsp;age,&nbsp;String&nbsp;name,&nbsp;String&nbsp;address)&nbsp;&nbsp;
                </li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.age&nbsp;=&nbsp;age;&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.name&nbsp;=&nbsp;name;&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.address&nbsp;=&nbsp;address;&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</li>
                <li>}&nbsp;&nbsp;</li>
                <li>class&nbsp;Employee&nbsp;extends&nbsp;Person&nbsp;&nbsp;&nbsp;</li>
                <li>{&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;float&nbsp;salary;&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;Employee(int&nbsp;age,&nbsp;String&nbsp;name,&nbsp;String&nbsp;address,&nbsp;float&nbsp;salary)&nbsp;&nbsp;
                </li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;super(age,name,address);&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.salary&nbsp;=&nbsp;salary;&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</li>
                <li>}&nbsp;&nbsp;</li>
                <li>public&nbsp;class&nbsp;Test&nbsp;&nbsp;&nbsp;</li>
                <li>{&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;void&nbsp;main&nbsp;(String&nbsp;args[])&nbsp;&nbsp;
                </li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Employee&nbsp;e&nbsp;=&nbsp;new&nbsp;Employee(22,&nbsp;&quot;Mukesh&quot;,&nbsp;&quot;Delhi&quot;,&nbsp;90000);&nbsp;&nbsp;
                </li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(&quot;Name:&nbsp;&quot;+e.name+&quot;&nbsp;Salary:&nbsp;&quot;+e.salary+&quot;&nbsp;Age:&nbsp;&quot;+e.age+&quot;&nbsp;Address:&nbsp;&quot;+e.address);&nbsp;&nbsp;
                </li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</li>
                <li>}&nbsp;&nbsp;</li>
            </ol>

            <p><strong>Output</strong></p>

            <pre>
Name: Mukesh Salary: 90000.0 Age: 22 Address: Delhi
</pre>

            <hr />
            <h3>67) What are the main uses of the super keyword?</h3>

            <p>There are the following uses of super keyword.</p>

            <ul>
                <li>super can be used to refer to the immediate parent class instance variable.</li>
                <li>super can be used to invoke the immediate parent class method.</li>
                <li>super() can be used to invoke immediate parent class constructor.</li>
            </ul>

            <hr />
            <h3>68) What are the differences between this and super keyword?</h3>

            <p>There are the following differences between this and super keyword.</p>

            <ul>
                <li>The super keyword always points to the parent class contexts whereas this keyword always points to
                    the current class context.</li>
                <li>The super keyword is primarily used for initializing the base class variables within the derived
                    class constructor whereas this keyword primarily used to differentiate between local and instance
                    variables when passed in the class constructor.</li>
                <li>The super and this must be the first statement inside constructor otherwise the compiler will throw
                    an error.</li>
            </ul>

            <hr />
            <h3>69) What is the output of the following Java program?</h3>

            <ol start="1">
                <li>class&nbsp;Person&nbsp;&nbsp;&nbsp;</li>
                <li>{&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;Person()&nbsp;&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(&quot;Person&nbsp;class&nbsp;constructor&nbsp;called&quot;);&nbsp;&nbsp;
                </li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</li>
                <li>}&nbsp;&nbsp;</li>
                <li>public&nbsp;class&nbsp;Employee&nbsp;extends&nbsp;Person&nbsp;&nbsp;&nbsp;</li>
                <li>{&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;Employee()&nbsp;&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(&quot;Employee&nbsp;class&nbsp;constructor&nbsp;called&quot;);&nbsp;&nbsp;
                </li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;void&nbsp;main&nbsp;(String&nbsp;args[])&nbsp;&nbsp;
                </li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Employee&nbsp;e&nbsp;=&nbsp;new&nbsp;Employee();&nbsp;&nbsp;
                </li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</li>
                <li>}&nbsp;&nbsp;</li>
            </ol>

            <p><strong>Output</strong></p>

            <pre>
Person class constructor called
Employee class constructor called
</pre>

            <p><strong>Explanation</strong></p>

            <p>The super() is implicitly invoked by the compiler if no super() or this() is included explicitly within
                the derived class constructor. Therefore, in this case, The Person class constructor is called first and
                then the Employee class constructor is called.</p>

            <hr />
            <h3>70) Can you use this() and super() both in a constructor?</h3>

            <p>No, because this() and super() must be the first statement in the class constructor.</p>

            <p><strong>Example:</strong></p>

            <ol start="1">
                <li>public&nbsp;class&nbsp;Test{&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;Test()&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;super();&nbsp;&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this();&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(&quot;Test&nbsp;class&nbsp;object&nbsp;is&nbsp;created&quot;);&nbsp;&nbsp;
                </li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;void&nbsp;main(String&nbsp;[]args){&nbsp;&nbsp;
                </li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Test&nbsp;t&nbsp;=&nbsp;new&nbsp;Test();&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</li>
                <li>}&nbsp;&nbsp;</li>
            </ol>

            <p>Output:</p>

            <pre>
Test.java:5: error: call to this must be first statement in constructor
</pre>

            <hr />
            <h3>71)What is object cloning?</h3>

            <p>The object cloning is used to create the exact copy of an object. The clone() method of the Object class
                is used to clone an object. The&nbsp;<strong>java.lang.Cloneable</strong>&nbsp;interface must be
                implemented by the class whose object clone we want to create. If we don&#39;t implement Cloneable
                interface, clone() method generates CloneNotSupportedException.</p>

            <ol start="1">
                <li>protected&nbsp;Object&nbsp;clone()&nbsp;throws&nbsp;CloneNotSupportedException&nbsp;&nbsp;&nbsp;&nbsp;
                </li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</li>
            </ol>

            <p><a href="https://www.javatpoint.com/object-cloning">More Details.</a></p>

            <hr />
            <h2><strong>Core Java - OOPs Concepts: Method Overloading Interview Questions</strong></h2>

            <hr />
            <h3>72) What is method overloading?</h3>

            <p>Method overloading is the polymorphism technique which allows us to create multiple methods with the same
                name but different signature. We can achieve method overloading in two ways.</p>

            <ul>
                <li>By Changing the number of arguments</li>
                <li>By Changing the data type of arguments</li>
            </ul>

            <p>Method overloading increases the readability of the program. Method overloading is performed to figure
                out the program quickly.</p>

            <p><a href="https://www.javatpoint.com/method-overloading-in-java">More Details.</a></p>

            <hr />
            <h3>73) Why is method overloading not possible by changing the return type in java?</h3>

            <p>In Java, method overloading is not possible by changing the return type of the program due to avoid the
                ambiguity.</p>

            <ol start="1">
                <li>class&nbsp;Adder{&nbsp;&nbsp;</li>
                <li>static&nbsp;int&nbsp;add(int&nbsp;a,int&nbsp;b){return&nbsp;a+b;}&nbsp;&nbsp;</li>
                <li>static&nbsp;double&nbsp;add(int&nbsp;a,int&nbsp;b){return&nbsp;a+b;}&nbsp;&nbsp;</li>
                <li>}&nbsp;&nbsp;</li>
                <li>class&nbsp;TestOverloading3{&nbsp;&nbsp;</li>
                <li>public&nbsp;static&nbsp;void&nbsp;main(String[]&nbsp;args){&nbsp;&nbsp;</li>
                <li>System.out.println(Adder.add(11,11));//ambiguity&nbsp;&nbsp;</li>
                <li>}}&nbsp;&nbsp;</li>
            </ol>

            <p><a href="https://www.javatpoint.com/opr/test.jsp?filename=TestOverloading3" target="_blank">Test it
                    Now</a></p>

            <p>Output:</p>

            <pre>
Compile Time Error: method add(int, int) is already defined in class Adder
</pre>

            <p><a href="https://www.javatpoint.com/method-overloading-in-java">More Details.</a></p>

            <hr />
            <h3>74) Can we overload the methods by making them static?</h3>

            <p>No, We cannot overload the methods by just applying the static keyword to them(number of parameters and
                types are the same). Consider the following example.</p>

            <ol start="1">
                <li>public&nbsp;class&nbsp;Animal&nbsp;&nbsp;</li>
                <li>{&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;void&nbsp;consume(int&nbsp;a)&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(a+&quot;&nbsp;consumed!!&quot;);&nbsp;&nbsp;
                </li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;static&nbsp;void&nbsp;consume(int&nbsp;a)&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(&quot;consumed&nbsp;static&nbsp;&quot;+a);&nbsp;&nbsp;
                </li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;void&nbsp;main&nbsp;(String&nbsp;args[])&nbsp;&nbsp;
                </li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Animal&nbsp;a&nbsp;=&nbsp;new&nbsp;Animal();&nbsp;&nbsp;
                </li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;a.consume(10);&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Animal.consume(20);&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</li>
                <li>}&nbsp;&nbsp;&nbsp;&nbsp;</li>
            </ol>

            <p><strong>Output</strong></p>

            <pre>
Animal.java:7: error: method consume(int) is already defined in class Animal
    static void consume(int a)
                ^
Animal.java:15: error: non-static method consume(int) cannot be referenced from a static context
        Animal.consume(20);
              ^
2 errors
</pre>

            <hr />
            <h3>75) Can we overload the main() method?</h3>

            <p>Yes, we can have any number of main methods in a Java program by using method overloading.</p>

            <p><a href="https://www.javatpoint.com/method-overloading-in-java">More Details.</a></p>

            <hr />
            <h3>76) What is method overloading with type promotion?</h3>

            <p>By Type promotion is method overloading, we mean that one data type can be promoted to another implicitly
                if no exact matching is found.</p>

            <p><img alt="Java Method Overloading with Type Promotion"
                    src="https://static.javatpoint.com/images/java-type-promotion.png" /></p>

            <p>As displayed in the above diagram, the byte can be promoted to short, int, long, float or double. The
                short datatype can be promoted to int, long, float or double. The char datatype can be promoted to int,
                long, float or double and so on. Consider the following example.</p>

            <ol start="1">
                <li>class&nbsp;OverloadingCalculation1{&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;void&nbsp;sum(int&nbsp;a,long&nbsp;b){System.out.println(a+b);}&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;void&nbsp;sum(int&nbsp;a,int&nbsp;b,int&nbsp;c){System.out.println(a+b+c);}&nbsp;&nbsp;
                </li>
                <li>&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;public&nbsp;static&nbsp;void&nbsp;main(String&nbsp;args[]){&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;OverloadingCalculation1&nbsp;obj=new&nbsp;OverloadingCalculation1();&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;obj.sum(20,20);//now&nbsp;second&nbsp;int&nbsp;literal&nbsp;will&nbsp;be&nbsp;promoted&nbsp;to&nbsp;long&nbsp;&nbsp;
                </li>
                <li>&nbsp;&nbsp;obj.sum(20,20,20);&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;}&nbsp;&nbsp;</li>
                <li>}&nbsp;&nbsp;</li>
            </ol>

            <p><a href="https://www.javatpoint.com/opr/test.jsp?filename=OverloadingCalculation1" target="_blank">Test
                    it Now</a></p>

            <p><strong>Output</strong></p>

            <pre>
40
60
</pre>

            <hr />
            <h3>77) What is the output of the following Java program?</h3>

            <ol start="1">
                <li>class&nbsp;OverloadingCalculation3{&nbsp;&nbsp;&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;void&nbsp;sum(int&nbsp;a,long&nbsp;b){System.out.println(&quot;a&nbsp;method&nbsp;invoked&quot;);}&nbsp;&nbsp;&nbsp;&nbsp;
                </li>
                <li>&nbsp;&nbsp;void&nbsp;sum(long&nbsp;a,int&nbsp;b){System.out.println(&quot;b&nbsp;method&nbsp;invoked&quot;);}&nbsp;&nbsp;&nbsp;&nbsp;
                </li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;public&nbsp;static&nbsp;void&nbsp;main(String&nbsp;args[]){&nbsp;&nbsp;&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;OverloadingCalculation3&nbsp;obj=new&nbsp;OverloadingCalculation3();&nbsp;&nbsp;&nbsp;&nbsp;
                </li>
                <li>&nbsp;&nbsp;obj.sum(20,20);//now&nbsp;ambiguity&nbsp;&nbsp;&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;</li>
                <li>}&nbsp;&nbsp;&nbsp;&nbsp;</li>
            </ol>

            <p><strong>Output</strong></p>

            <pre>
OverloadingCalculation3.java:7: error: reference to sum is ambiguous
obj.sum(20,20);//now ambiguity  
     ^ 
      both method sum(int,long) in OverloadingCalculation3 
      and method sum(long,int) in OverloadingCalculation3 match
1 error
</pre>

            <p><strong>Explanation</strong></p>

            <p>There are two methods defined with the same name, i.e., sum. The first method accepts the integer and
                long type whereas the second method accepts long and the integer type. The parameter passed that are a =
                20, b = 20. We can not tell that which method will be called as there is no clear differentiation
                mentioned between integer literal and long literal. This is the case of ambiguity. Therefore, the
                compiler will throw an error.</p>

            <hr />
            <h2><strong>Core Java - OOPs Concepts: Method Overriding Interview Questions</strong></h2>

            <hr />
            <h3>78) What is method overriding:</h3>

            <p>If a subclass provides a specific implementation of a method that is already provided by its parent
                class, it is known as Method Overriding. It is used for runtime polymorphism and to implement the
                interface methods.</p>

            <p><strong>Rules for Method overriding</strong></p>

            <ul>
                <li>The method must have the same name as in the parent class.</li>
                <li>The method must have the same signature as in the parent class.</li>
                <li>Two classes must have an IS-A relationship between them.</li>
            </ul>

            <p><a href="https://www.javatpoint.com/method-overriding-in-java">More Details.</a></p>

            <p>&nbsp;</p>

            <hr />
            <h3>79) Can we override the static method?</h3>

            <p>No, you can&#39;t override the static method because they are the part of the class, not the object.</p>

            <hr />
            <h3>80) Why can we not override static method?</h3>

            <p>It is because the static method is the part of the class, and it is bound with class whereas instance
                method is bound with the object, and static gets memory in class area, and instance gets memory in a
                heap.</p>

            <hr />
            <h3>81) Can we override the overloaded method?</h3>

            <p>Yes.</p>

            <hr />
            <h3>82) Difference between method Overloading and Overriding.</h3>

            <table>
                <tbody>
                    <tr>
                        <th>Method Overloading</th>
                        <th>Method Overriding</th>
                    </tr>
                    <tr>
                        <td>1) Method overloading increases the readability of the program.</td>
                        <td>Method overriding provides the specific implementation of the method that is already
                            provided by its superclass.</td>
                    </tr>
                    <tr>
                        <td>2) Method overloading occurs within the class.</td>
                        <td>Method overriding occurs in two classes that have IS-A relationship between them.</td>
                    </tr>
                    <tr>
                        <td>3) In this case, the parameters must be different.</td>
                        <td>In this case, the parameters must be the same.</td>
                    </tr>
                </tbody>
            </table>

            <hr />
            <h3>83) Can we override the private methods?</h3>

            <p>No, we cannot override the private methods because the scope of private methods is limited to the class
                and we cannot access them outside of the class.</p>

            <hr />
            <h3>84) Can we change the scope of the overridden method in the subclass?</h3>

            <p>Yes, we can change the scope of the overridden method in the subclass. However, we must notice that we
                cannot decrease the accessibility of the method. The following point must be taken care of while
                changing the accessibility of the method.</p>

            <ul>
                <li>The private can be changed to protected, public, or default.</li>
                <li>The protected can be changed to public or default.</li>
                <li>The default can be changed to public.</li>
                <li>The public will always remain public.</li>
            </ul>

            <hr />
            <h3>85) Can we modify the throws clause of the superclass method while overriding it in the subclass?</h3>

            <p>Yes, we can modify the throws clause of the superclass method while overriding it in the subclass.
                However, there are some rules which are to be followed while overriding in case of exception handling.
            </p>

            <ul>
                <li>If the superclass method does not declare an exception, subclass overridden method cannot declare
                    the checked exception, but it can declare the unchecked exception.</li>
                <li>If the superclass method declares an exception, subclass overridden method can declare same,
                    subclass exception or no exception but cannot declare parent exception.</li>
            </ul>

            <hr />
            <h3>86) What is the output of the following Java program?</h3>

            <ol start="1">
                <li>class&nbsp;Base&nbsp;&nbsp;</li>
                <li>{&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;void&nbsp;method(int&nbsp;a)&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(&quot;Base&nbsp;class&nbsp;method&nbsp;called&nbsp;with&nbsp;integer&nbsp;a&nbsp;=&nbsp;&quot;+a);&nbsp;&nbsp;
                </li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;void&nbsp;method(double&nbsp;d)&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(&quot;Base&nbsp;class&nbsp;method&nbsp;called&nbsp;with&nbsp;double&nbsp;d&nbsp;=&quot;+d);&nbsp;&nbsp;
                </li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</li>
                <li>}&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;</li>
                <li>class&nbsp;Derived&nbsp;extends&nbsp;Base&nbsp;&nbsp;</li>
                <li>{&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;@Override&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;void&nbsp;method(double&nbsp;d)&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(&quot;Derived&nbsp;class&nbsp;method&nbsp;called&nbsp;with&nbsp;double&nbsp;d&nbsp;=&quot;+d);&nbsp;&nbsp;
                </li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</li>
                <li>}&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;</li>
                <li>public&nbsp;class&nbsp;Main&nbsp;&nbsp;</li>
                <li>{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;void&nbsp;main(String[]&nbsp;args)&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;new&nbsp;Derived().method(10);&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</li>
                <li>}&nbsp;&nbsp;</li>
            </ol>

            <p><strong>Output</strong></p>

            <pre>
Base class method called with integer a = 10
</pre>

            <p><strong>Explanation</strong></p>

            <p>The method() is overloaded in class Base whereas it is derived in class Derived with the double type as
                the parameter. In the method call, the integer is passed.</p>

            <h3>87) Can you have virtual functions in Java?</h3>

            <p>Yes, all functions in Java are virtual by default.</p>

            <hr />
            <h3>88) What is covariant return type?</h3>

            <p>Now, since java5, it is possible to override any method by changing the return type if the return type of
                the subclass overriding method is subclass type. It is known as covariant return type. The covariant
                return type specifies that the return type may vary in the same direction as the subclass.</p>

            <ol start="1">
                <li>class&nbsp;A{&nbsp;&nbsp;</li>
                <li>A&nbsp;get(){return&nbsp;this;}&nbsp;&nbsp;</li>
                <li>}&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;</li>
                <li>class&nbsp;B1&nbsp;extends&nbsp;A{&nbsp;&nbsp;</li>
                <li>B1&nbsp;get(){return&nbsp;this;}&nbsp;&nbsp;</li>
                <li>void&nbsp;message(){System.out.println(&quot;welcome&nbsp;to&nbsp;covariant&nbsp;return&nbsp;type&quot;);}&nbsp;&nbsp;
                </li>
                <li>&nbsp;&nbsp;</li>
                <li>public&nbsp;static&nbsp;void&nbsp;main(String&nbsp;args[]){&nbsp;&nbsp;</li>
                <li>new&nbsp;B1().get().message();&nbsp;&nbsp;</li>
                <li>}&nbsp;&nbsp;</li>
                <li>}&nbsp;&nbsp;</li>
            </ol>

            <p><a href="https://www.javatpoint.com/opr/test.jsp?filename=B1" target="_blank">Test it Now</a></p>

            <pre>
Output: welcome to covariant return type
</pre>

            <p><a href="https://www.javatpoint.com/covariant-return-type">More Details.</a></p>

            <hr />
            <h3>89) What is the output of the following Java program?</h3>

            <ol start="1">
                <li>class&nbsp;Base&nbsp;&nbsp;&nbsp;</li>
                <li>{&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;baseMethod()&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(&quot;BaseMethod&nbsp;called&nbsp;...&quot;);&nbsp;&nbsp;
                </li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</li>
                <li>}&nbsp;&nbsp;</li>
                <li>class&nbsp;Derived&nbsp;extends&nbsp;Base&nbsp;&nbsp;&nbsp;</li>
                <li>{&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;baseMethod()&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(&quot;Derived&nbsp;method&nbsp;called&nbsp;...&quot;);&nbsp;&nbsp;
                </li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</li>
                <li>}&nbsp;&nbsp;</li>
                <li>public&nbsp;class&nbsp;Test&nbsp;&nbsp;&nbsp;</li>
                <li>{&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;void&nbsp;main&nbsp;(String&nbsp;args[])&nbsp;&nbsp;
                </li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Base&nbsp;b&nbsp;=&nbsp;new&nbsp;Derived();&nbsp;&nbsp;
                </li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;b.baseMethod();&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</li>
                <li>}&nbsp;&nbsp;</li>
            </ol>

            <hr />
            <p><strong>Output</strong></p>

            <pre>
Derived method called ...
</pre>

            <p><strong>Explanation</strong></p>

            <p>The method of Base class, i.e., baseMethod() is overridden in Derived class. In Test class, the reference
                variable b (of type Base class) refers to the instance of the Derived class. Here, Runtime polymorphism
                is achieved between class Base and Derived. At compile time, the presence of method baseMethod checked
                in Base class, If it presence then the program compiled otherwise the compiler error will be shown. In
                this case, baseMethod is present in Base class; therefore, it is compiled successfully. However, at
                runtime, It checks whether the baseMethod has been overridden by Derived class, if so then the Derived
                class method is called otherwise Base class method is called. In this case, the Derived class overrides
                the baseMethod; therefore, the Derived class method is called.</p>

            <hr />
            <h2>Core Java - OOPs Concepts: final keyword Interview Questions</h2>

            <hr />
            <h3>90) What is the final variable?</h3>

            <p>In Java, the final variable is used to restrict the user from updating it. If we initialize the final
                variable, we can&#39;t change its value. In other words, we can say that the final variable once
                assigned to a value, can never be changed after that. The final variable which is not assigned to any
                value can only be assigned through the class constructor.</p>

            <p><img alt="final keyword in java" src="https://static.javatpoint.com/images/core/final.jpg" /></p>

            <ol start="1">
                <li>class&nbsp;Bike9{&nbsp;&nbsp;</li>
                <li>&nbsp;final&nbsp;int&nbsp;speedlimit=90;//final&nbsp;variable&nbsp;&nbsp;</li>
                <li>&nbsp;void&nbsp;run(){&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;speedlimit=400;&nbsp;&nbsp;</li>
                <li>&nbsp;}&nbsp;&nbsp;</li>
                <li>&nbsp;public&nbsp;static&nbsp;void&nbsp;main(String&nbsp;args[]){&nbsp;&nbsp;</li>
                <li>&nbsp;Bike9&nbsp;obj=new&nbsp;&nbsp;Bike9();&nbsp;&nbsp;</li>
                <li>&nbsp;obj.run();&nbsp;&nbsp;</li>
                <li>&nbsp;}&nbsp;&nbsp;</li>
                <li>}//end&nbsp;of&nbsp;class&nbsp;&nbsp;</li>
            </ol>

            <p><a href="https://www.javatpoint.com/opr/test.jsp?filename=Bike9" target="_blank">Test it Now</a></p>

            <pre>
Output:Compile Time Error
</pre>

            <p><a href="https://www.javatpoint.com/final-keyword">More Details.</a></p>

            <hr />
            <h3>91) What is the final method?</h3>

            <p>If we change any method to a final method, we can&#39;t override it.&nbsp;<a
                    href="https://www.javatpoint.com/final-keyword">More Details.</a></p>

            <ol start="1">
                <li>class&nbsp;Bike{&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;final&nbsp;void&nbsp;run(){System.out.println(&quot;running&quot;);}&nbsp;&nbsp;</li>
                <li>}&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</li>
                <li>class&nbsp;Honda&nbsp;extends&nbsp;Bike{&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;void&nbsp;run(){System.out.println(&quot;running&nbsp;safely&nbsp;with&nbsp;100kmph&quot;);}&nbsp;&nbsp;
                </li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;void&nbsp;main(String&nbsp;args[]){&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;Honda&nbsp;honda=&nbsp;new&nbsp;Honda();&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;honda.run();&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</li>
                <li>}&nbsp;&nbsp;</li>
            </ol>

            <p><a href="https://www.javatpoint.com/opr/test.jsp?filename=Honda" target="_blank">Test it Now</a></p>

            <pre>
Output:Compile Time Error
</pre>

            <hr />
            <h3>92) What is the final class?</h3>

            <p>If we make any class final, we can&#39;t inherit it into any of the subclasses.</p>

            <ol start="1">
                <li>final&nbsp;class&nbsp;Bike{}&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;</li>
                <li>class&nbsp;Honda1&nbsp;extends&nbsp;Bike{&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;void&nbsp;run(){System.out.println(&quot;running&nbsp;safely&nbsp;with&nbsp;100kmph&quot;);}&nbsp;&nbsp;
                </li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;public&nbsp;static&nbsp;void&nbsp;main(String&nbsp;args[]){&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;Honda1&nbsp;honda=&nbsp;new&nbsp;Honda1();&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;honda.run();&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;}&nbsp;&nbsp;</li>
                <li>}&nbsp;&nbsp;</li>
            </ol>

            <p><a href="https://www.javatpoint.com/opr/test.jsp?filename=Honda1" target="_blank">Test it Now</a></p>

            <pre>
Output:Compile Time Error
</pre>

            <p><a href="https://www.javatpoint.com/final-keyword">More Details.</a></p>

            <hr />
            <h3>93) What is the final blank variable?</h3>

            <p>A final variable, not initialized at the time of declaration, is known as the final blank variable. We
                can&#39;t initialize the final blank variable directly. Instead, we have to initialize it by using the
                class constructor. It is useful in the case when the user has some data which must not be changed by
                others, for example, PAN Number. Consider the following example:</p>

            <ol start="1">
                <li>class&nbsp;Student{&nbsp;&nbsp;</li>
                <li>int&nbsp;id;&nbsp;&nbsp;</li>
                <li>String&nbsp;name;&nbsp;&nbsp;</li>
                <li>final&nbsp;String&nbsp;PAN_CARD_NUMBER;&nbsp;&nbsp;</li>
                <li>...&nbsp;&nbsp;</li>
                <li>}&nbsp;&nbsp;</li>
            </ol>

            <p><a href="https://www.javatpoint.com/final-keyword">More Details.</a></p>

            <hr />
            <h3>94) Can we initialize the final blank variable?</h3>

            <p>Yes, if it is not static, we can initialize it in the constructor. If it is static blank final variable,
                it can be initialized only in the static block.<a
                    href="https://www.javatpoint.com/final-keyword">&nbsp;More Details.</a></p>

            <hr />
            <h3>95) Can you declare the main method as final?</h3>

            <p>Yes, We can declare the main method as public static final void main(String[] args){}.</p>

            <hr />
            <h3>96) What is the output of the following Java program?</h3>

            <ol start="1">
                <li>class&nbsp;Main&nbsp;{&nbsp;&nbsp;</li>
                <li>&nbsp;public&nbsp;static&nbsp;void&nbsp;main(String&nbsp;args[]){&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;final&nbsp;int&nbsp;i;&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;i&nbsp;=&nbsp;20;&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;System.out.println(i);&nbsp;&nbsp;</li>
                <li>&nbsp;}&nbsp;&nbsp;</li>
                <li>}&nbsp;&nbsp;</li>
            </ol>

            <p><strong>Output</strong></p>

            <pre>
20
</pre>

            <p><strong>Explanation</strong></p>

            <p>Since i is the blank final variable. It can be initialized only once. We have initialized it to 20.
                Therefore, 20 will be printed.</p>

            <hr />
            <h3>97) What is the output of the following Java program?</h3>

            <ol start="1">
                <li>class&nbsp;Base&nbsp;&nbsp;&nbsp;</li>
                <li>{&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;protected&nbsp;final&nbsp;void&nbsp;getInfo()&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(&quot;method&nbsp;of&nbsp;Base&nbsp;class&quot;);&nbsp;&nbsp;
                </li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</li>
                <li>}&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;</li>
                <li>public&nbsp;class&nbsp;Derived&nbsp;extends&nbsp;Base&nbsp;&nbsp;</li>
                <li>{&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;protected&nbsp;final&nbsp;void&nbsp;getInfo()&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(&quot;method&nbsp;of&nbsp;Derived&nbsp;class&quot;);&nbsp;&nbsp;
                </li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;void&nbsp;main(String[]&nbsp;args)&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Base&nbsp;obj&nbsp;=&nbsp;new&nbsp;Base();&nbsp;&nbsp;
                </li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;obj.getInfo();&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</li>
                <li>}&nbsp;&nbsp;</li>
            </ol>

            <p><strong>Output</strong></p>

            <pre>
	Derived.java:11: error: getInfo() in Derived cannot override getInfo() in Base
    protected final void getInfo()
                         ^
  overridden method is final
1 error
</pre>

            <p><strong>Explanation</strong></p>

            <p>The getDetails() method is final; therefore it can not be overridden in the subclass.</p>

            <hr />
            <h3>98) Can we declare a constructor as final?</h3>

            <p>The constructor can never be declared as final because it is never inherited. Constructors are not
                ordinary methods; therefore, there is no sense to declare constructors as final. However, if you try to
                do so, The compiler will throw an error.</p>

            <hr />
            <h3>99) Can we declare an interface as final?</h3>

            <p>No, we cannot declare an interface as final because the interface must be implemented by some class to
                provide its definition. Therefore, there is no sense to make an interface final. However, if you try to
                do so, the compiler will show an error.</p>

            <hr />
            <h3>100) What is the difference between the final method and abstract method?</h3>

            <p>The main difference between the final method and abstract method is that the abstract method cannot be
                final as we need to override them in the subclass to give its definition.</p>

        </div>
        <div class="box-prem">
            <h2>Core Java - OOPs: Polymorphism Interview Questions</h2>

            <hr />
            <h3>101) What is the difference between compile-time polymorphism and runtime polymorphism?</h3>

            <p>There are the following differences between compile-time polymorphism and runtime polymorphism.</p>

            <table>
                <tbody>
                    <tr>
                        <th>SN</th>
                        <th>compile-time polymorphism</th>
                        <th>Runtime polymorphism</th>
                    </tr>
                    <tr>
                        <td>1</td>
                        <td>In compile-time polymorphism, call to a method is resolved at compile-time.</td>
                        <td>In runtime polymorphism, call to an overridden method is resolved at runtime.</td>
                    </tr>
                    <tr>
                        <td>2</td>
                        <td>It is also known as static binding, early binding, or overloading.</td>
                        <td>It is also known as dynamic binding, late binding, overriding, or dynamic method dispatch.
                        </td>
                    </tr>
                    <tr>
                        <td>3</td>
                        <td>Overloading is a way to achieve compile-time polymorphism in which, we can define multiple
                            methods or constructors with different signatures.</td>
                        <td>Overriding is a way to achieve runtime polymorphism in which, we can redefine some
                            particular method or variable in the derived class. By using overriding, we can give some
                            specific implementation to the base class properties in the derived class.</td>
                    </tr>
                    <tr>
                        <td>4</td>
                        <td>It provides fast execution because the type of an object is determined at compile-time.</td>
                        <td>It provides slower execution as compare to compile-time because the type of an object is
                            determined at run-time.</td>
                    </tr>
                    <tr>
                        <td>5</td>
                        <td>Compile-time polymorphism provides less flexibility because all the things are resolved at
                            compile-time.</td>
                        <td>Run-time polymorphism provides more flexibility because all the things are resolved at
                            runtime.</td>
                    </tr>
                </tbody>
            </table>

            <hr />
            <h3>102) What is Runtime Polymorphism?</h3>

            <p>Runtime polymorphism or dynamic method dispatch is a process in which a call to an overridden method is
                resolved at runtime rather than at compile-time. In this process, an overridden method is called through
                the reference variable of a superclass. The determination of the method to be called is based on the
                object being referred to by the reference variable.</p>

            <ol start="1">
                <li>class&nbsp;Bike{&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;void&nbsp;run(){System.out.println(&quot;running&quot;);}&nbsp;&nbsp;</li>
                <li>}&nbsp;&nbsp;</li>
                <li>class&nbsp;Splendor&nbsp;extends&nbsp;Bike{&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;void&nbsp;run(){System.out.println(&quot;running&nbsp;safely&nbsp;with&nbsp;60km&quot;);}&nbsp;&nbsp;
                </li>
                <li>&nbsp;&nbsp;public&nbsp;static&nbsp;void&nbsp;main(String&nbsp;args[]){&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;Bike&nbsp;b&nbsp;=&nbsp;new&nbsp;Splendor();//upcasting&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;b.run();&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;}&nbsp;&nbsp;</li>
                <li>}&nbsp;&nbsp;</li>
            </ol>

            <p><a href="https://www.javatpoint.com/opr/test.jsp?filename=Splender" target="_blank">Test it Now</a></p>

            <p>Output:</p>

            <pre>
            running safely with 60km.
            </pre>

            <p>In this process, an overridden method is called through the reference variable of a superclass. The
                determination of the method to be called is based on the object being referred to by the reference
                variable.</p>

            <p>&nbsp;</p>

            <p>&nbsp;</p>

            <p>32.2M</p>

            <p>619</p>

            <p>Java Try Catch</p>

            <p><a href="https://www.javatpoint.com/runtime-polymorphism-in-java">More details.</a></p>

            <hr />
            <h3>103) Can you achieve Runtime Polymorphism by data members?</h3>

            <p>No, because method overriding is used to achieve runtime polymorphism and data members cannot be
                overridden. We can override the member functions but not the data members. Consider the example given
                below.</p>

            <ol start="1">
                <li>class&nbsp;Bike{&nbsp;&nbsp;</li>
                <li>&nbsp;int&nbsp;speedlimit=90;&nbsp;&nbsp;</li>
                <li>}&nbsp;&nbsp;</li>
                <li>class&nbsp;Honda3&nbsp;extends&nbsp;Bike{&nbsp;&nbsp;</li>
                <li>&nbsp;int&nbsp;speedlimit=150;&nbsp;&nbsp;</li>
                <li>&nbsp;public&nbsp;static&nbsp;void&nbsp;main(String&nbsp;args[]){&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;Bike&nbsp;obj=new&nbsp;Honda3();&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;System.out.println(obj.speedlimit);//90&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</li>
            </ol>

            <p><a href="https://www.javatpoint.com/opr/test.jsp?filename=Honda3" target="_blank">Test it Now</a></p>

            <p>Output:</p>

            <pre>
            90
            </pre>

            <p><a href="https://www.javatpoint.com/runtime-polymorphism-in-java">More details.</a></p>

            <hr />
            <h3>104) What is the difference between static binding and dynamic binding?</h3>

            <p>In case of the static binding, the type of the object is determined at compile-time whereas, in the
                dynamic binding, the type of the object is determined at runtime.</p>

            <p><strong>Static Binding</strong></p>

            <ol start="1">
                <li>class&nbsp;Dog{&nbsp;&nbsp;</li>
                <li>&nbsp;private&nbsp;void&nbsp;eat(){System.out.println(&quot;dog&nbsp;is&nbsp;eating...&quot;);}&nbsp;&nbsp;
                </li>
                <li>&nbsp;&nbsp;</li>
                <li>&nbsp;public&nbsp;static&nbsp;void&nbsp;main(String&nbsp;args[]){&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;Dog&nbsp;d1=new&nbsp;Dog();&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;d1.eat();&nbsp;&nbsp;</li>
                <li>&nbsp;}&nbsp;&nbsp;</li>
                <li>}&nbsp;&nbsp;</li>
            </ol>

            <p><strong>Dynamic Binding</strong></p>

            <ol start="1">
                <li>class&nbsp;Animal{&nbsp;&nbsp;</li>
                <li>&nbsp;void&nbsp;eat(){System.out.println(&quot;animal&nbsp;is&nbsp;eating...&quot;);}&nbsp;&nbsp;
                </li>
                <li>}&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;</li>
                <li>class&nbsp;Dog&nbsp;extends&nbsp;Animal{&nbsp;&nbsp;</li>
                <li>&nbsp;void&nbsp;eat(){System.out.println(&quot;dog&nbsp;is&nbsp;eating...&quot;);}&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;</li>
                <li>&nbsp;public&nbsp;static&nbsp;void&nbsp;main(String&nbsp;args[]){&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;Animal&nbsp;a=new&nbsp;Dog();&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;a.eat();&nbsp;&nbsp;</li>
                <li>&nbsp;}&nbsp;&nbsp;</li>
                <li>}&nbsp;&nbsp;</li>
            </ol>

            <p><a href="https://www.javatpoint.com/static-binding-and-dynamic-binding">More details.</a></p>

            <hr />
            <h3>105) What is the output of the following Java program?</h3>

            <ol start="1">
                <li>class&nbsp;BaseTest&nbsp;&nbsp;&nbsp;</li>
                <li>{&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;void&nbsp;print()&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;{&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(&quot;BaseTest:print()&nbsp;called&quot;);&nbsp;&nbsp;
                </li>
                <li>&nbsp;&nbsp;}&nbsp;&nbsp;</li>
                <li>}&nbsp;&nbsp;</li>
                <li>public&nbsp;class&nbsp;Test&nbsp;extends&nbsp;BaseTest&nbsp;&nbsp;&nbsp;</li>
                <li>{&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;void&nbsp;print()&nbsp;&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;{&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(&quot;Test:print()&nbsp;called&quot;);&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;}&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;public&nbsp;static&nbsp;void&nbsp;main&nbsp;(String&nbsp;args[])&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;{&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;BaseTest&nbsp;b&nbsp;=&nbsp;new&nbsp;Test();&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;b.print();&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;}&nbsp;&nbsp;</li>
                <li>}&nbsp;&nbsp;</li>
            </ol>

            <p><strong>Output</strong></p>

            <pre>
              Test:print() called
            </pre>

            <p><strong>Explanation</strong></p>

            <p>It is an example of Dynamic method dispatch. The type of reference variable b is determined at runtime.
                At compile-time, it is checked whether that method is present in the Base class. In this case, it is
                overridden in the child class, therefore, at runtime the derived class method is called.</p>

            <p>&nbsp;</p>

            <hr />
            <h3>106) What is Java instanceOf operator?</h3>

            <p>The instanceof in Java is also known as type comparison operator because it compares the instance with
                type. It returns either true or false. If we apply the instanceof operator with any variable that has a
                null value, it returns false. Consider the following example.</p>

            <ol start="1">
                <li>class&nbsp;Simple1{&nbsp;&nbsp;</li>
                <li>&nbsp;public&nbsp;static&nbsp;void&nbsp;main(String&nbsp;args[]){&nbsp;&nbsp;</li>
                <li>&nbsp;Simple1&nbsp;s=new&nbsp;Simple1();&nbsp;&nbsp;</li>
                <li>&nbsp;System.out.println(s&nbsp;instanceof&nbsp;Simple1);//true&nbsp;&nbsp;</li>
                <li>&nbsp;}&nbsp;&nbsp;</li>
                <li>}&nbsp;&nbsp;</li>
            </ol>

            <p><a href="https://www.javatpoint.com/opr/test.jsp?filename=Simple1" target="_blank">Test it Now</a></p>

            <p><strong>Output</strong></p>

            <pre>
            true
            </pre>

            <hr />
            <p>An object of subclass type is also a type of parent class. For example, if Dog extends Animal then object
                of Dog can be referred by either Dog or Animal class.</p>

            <hr />
            <h2>Core Java - OOPs Concepts: Abstraction Interview Questions</h2>

            <hr />
            <h3>107) What is the abstraction?</h3>

            <p>Abstraction is a process of hiding the implementation details and showing only functionality to the user.
                It displays just the essential things to the user and hides the internal information, for example,
                sending SMS where you type the text and send the message. You don&#39;t know the internal processing
                about the message delivery. Abstraction enables you to focus on what the object does instead of how it
                does it. Abstraction lets you focus on what the object does instead of how it does it.</p>

            <p>In Java, there are two ways to achieve the abstraction.</p>

            <p>&nbsp;</p>

            <ul>
                <li>Abstract Class</li>
                <li>Interface</li>
            </ul>

            <p><a href="https://www.javatpoint.com/abstract-class-in-java">More details.</a></p>

            <hr />
            <h3>108) What is the difference between abstraction and encapsulation?</h3>

            <p>Abstraction hides the implementation details whereas encapsulation wraps code and data into a single
                unit.</p>

            <p><a href="https://www.javatpoint.com/abstract-class-in-java">More details.</a></p>

            <hr />
            <h3>109) What is the abstract class?</h3>

            <p>A class that is declared as abstract is known as an abstract class. It needs to be extended and its
                method implemented. It cannot be instantiated. It can have abstract methods, non-abstract methods,
                constructors, and static methods. It can also have the final methods which will force the subclass not
                to change the body of the method. Consider the following example.</p>

            <ol start="1">
                <li>abstract&nbsp;class&nbsp;Bike{&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;abstract&nbsp;void&nbsp;run();&nbsp;&nbsp;</li>
                <li>}&nbsp;&nbsp;</li>
                <li>class&nbsp;Honda4&nbsp;extends&nbsp;Bike{&nbsp;&nbsp;</li>
                <li>void&nbsp;run(){System.out.println(&quot;running&nbsp;safely&quot;);}&nbsp;&nbsp;</li>
                <li>public&nbsp;static&nbsp;void&nbsp;main(String&nbsp;args[]){&nbsp;&nbsp;</li>
                <li>&nbsp;Bike&nbsp;obj&nbsp;=&nbsp;new&nbsp;Honda4();&nbsp;&nbsp;</li>
                <li>&nbsp;obj.run();&nbsp;&nbsp;</li>
                <li>}&nbsp;&nbsp;</li>
                <li>}&nbsp;&nbsp;</li>
            </ol>

            <p><a href="https://www.javatpoint.com/opr/test.jsp?filename=Honda4" target="_blank">Test it Now</a></p>

            <p><strong>Output</strong></p>

            <p>&nbsp;</p>

            <pre>
            running safely
            </pre>

            <p><a href="https://www.javatpoint.com/abstract-class-in-java">More details.</a></p>

            <hr />
            <h3>110) Can there be an abstract method without an abstract class?</h3>

            <p>No, if there is an abstract method in a class, that class must be abstract.</p>

            <hr />
            <h3>111) Is the following program written correctly? If yes then what will be the output of the program?
            </h3>

            <ol start="1">
                <li>abstract&nbsp;class&nbsp;Calculate&nbsp;&nbsp;</li>
                <li>{&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;abstract&nbsp;int&nbsp;multiply(int&nbsp;a,&nbsp;int&nbsp;b);&nbsp;&nbsp;
                </li>
                <li>}&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;</li>
                <li>public&nbsp;class&nbsp;Main&nbsp;&nbsp;</li>
                <li>{&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;void&nbsp;main(String[]&nbsp;args)&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;result&nbsp;=&nbsp;new&nbsp;Calculate()&nbsp;&nbsp;
                </li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;@Override&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;multiply(int&nbsp;a,&nbsp;int&nbsp;b)&nbsp;&nbsp;
                </li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;a*b;&nbsp;&nbsp;
                </li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}.multiply(12,32);&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(&quot;result&nbsp;=&nbsp;&quot;+result);&nbsp;&nbsp;
                </li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</li>
                <li>}&nbsp;&nbsp;</li>
            </ol>

            <p>Yes, the program is written correctly. The Main class provides the definition of abstract method multiply
                declared in abstract class Calculation. The output of the program will be:</p>

            <p><strong>Output</strong></p>

            <pre>
            384
            </pre>

            <hr />
            <h3>112) Can you use abstract and final both with a method?</h3>

            <p>No, because we need to override the abstract method to provide its implementation, whereas we can&#39;t
                override the final method.</p>

            <hr />
            <h3>113) Is it possible to instantiate the abstract class?</h3>

            <p>No, the abstract class can never be instantiated even if it contains a constructor and all of its methods
                are implemented.</p>

            <hr />
            <h3>114) What is the interface?</h3>

            <p>The interface is a blueprint for a class that has static constants and abstract methods. It can be used
                to achieve full abstraction and multiple inheritance. It is a mechanism to achieve abstraction. There
                can be only abstract methods in the Java interface, not method body. It is used to achieve abstraction
                and multiple inheritance in Java. In other words, you can say that interfaces can have abstract methods
                and variables. Java Interface also represents the IS-A relationship. It cannot be instantiated just like
                the abstract class. However, we need to implement it to define its methods. Since Java 8, we can have
                the default, static, and private methods in an interface.</p>

            <p><a href="https://www.javatpoint.com/interface-in-java">More details.</a></p>

            <hr />
            <h3>115) Can you declare an interface method static?</h3>

            <p>No, because methods of an interface are abstract by default, and we can not use static and abstract
                together.</p>

            <hr />
            <h3>116) Can the Interface be final?</h3>

            <p>No, because an interface needs to be implemented by the other class and if it is final, it can&#39;t be
                implemented by any class.</p>

            <hr />
            <h3>117) What is a marker interface?</h3>

            <p>A Marker interface can be defined as the interface which has no data member and member functions. For
                example, Serializable, Cloneable are marker interfaces. The marker interface can be declared as follows.
            </p>

            <p>&nbsp;</p>

            <ol start="1">
                <li>public&nbsp;interface&nbsp;Serializable{&nbsp;&nbsp;&nbsp;&nbsp;</li>
                <li>}&nbsp;&nbsp;&nbsp;&nbsp;</li>
            </ol>

            <hr />
            <h3>118) What are the differences between abstract class and interface?</h3>

            <table>
                <tbody>
                    <tr>
                        <th>Abstract class</th>
                        <th>Interface</th>
                    </tr>
                    <tr>
                        <td>An abstract class can have a method body (non-abstract methods).</td>
                        <td>The interface has only abstract methods.</td>
                    </tr>
                    <tr>
                        <td>An abstract class can have instance variables.</td>
                        <td>An interface cannot have instance variables.</td>
                    </tr>
                    <tr>
                        <td>An abstract class can have the constructor.</td>
                        <td>The interface cannot have the constructor.</td>
                    </tr>
                    <tr>
                        <td>An abstract class can have static methods.</td>
                        <td>The interface cannot have static methods.</td>
                    </tr>
                    <tr>
                        <td>You can extend one abstract class.</td>
                        <td>You can implement multiple interfaces.</td>
                    </tr>
                    <tr>
                        <td>The abstract class&nbsp;<strong>can provide the implementation of the interface</strong>.
                        </td>
                        <td>The Interface&nbsp;<strong>can&#39;t provide the implementation of the abstract
                                class</strong>.</td>
                    </tr>
                    <tr>
                        <td>The&nbsp;<strong>abstract keyword</strong>&nbsp;is used to declare an abstract class.</td>
                        <td>The&nbsp;<strong>interface keyword</strong>&nbsp;is used to declare an interface.</td>
                    </tr>
                    <tr>
                        <td>An&nbsp;<strong>abstract class</strong>&nbsp;can extend another Java class and implement
                            multiple Java interfaces.</td>
                        <td>An&nbsp;<strong>interface</strong>&nbsp;can extend another Java interface only.</td>
                    </tr>
                    <tr>
                        <td>An&nbsp;<strong>abstract class</strong>&nbsp;can be extended using
                            keyword&nbsp;<strong>extends</strong></td>
                        <td>An&nbsp;<strong>interface class</strong>&nbsp;can be implemented using
                            keyword&nbsp;<strong>implements</strong></td>
                    </tr>
                    <tr>
                        <td>A Java<strong>&nbsp;abstract class</strong>&nbsp;can have class members like private,
                            protected, etc.</td>
                        <td>Members of a Java interface are public by default.</td>
                    </tr>
                    <tr>
                        <td><strong>Example:</strong><br />
                            public abstract class Shape{<br />
                            public abstract void draw();<br />
                            }</td>
                        <td><strong>Example:</strong><br />
                            public interface Drawable{<br />
                            void draw();<br />
                            }</td>
                    </tr>
                </tbody>
            </table>

            <hr />
            <h3>119) Can we define private and protected modifiers for the members in interfaces?</h3>

            <p>No, they are implicitly public.</p>

            <hr />
            <h3>120) When can an object reference be cast to an interface reference?</h3>

            <p>An object reference can be cast to an interface reference when the object implements the referenced
                interface.</p>

            <hr />
            <h3>121) How to make a read-only class in Java?</h3>

            <p>A class can be made read-only by making all of the fields private. The read-only class will have only
                getter methods which return the private property of the class to the main method. We cannot modify this
                property because there is no setter method available in the class. Consider the following example.</p>

            <ol start="1">
                <li>&nbsp;&nbsp;//A&nbsp;Java&nbsp;class&nbsp;which&nbsp;has&nbsp;only&nbsp;getter&nbsp;methods.&nbsp;&nbsp;&nbsp;&nbsp;
                </li>
                <li>public&nbsp;class&nbsp;Student{&nbsp;&nbsp;&nbsp;&nbsp;</li>
                <li>//private&nbsp;data&nbsp;member&nbsp;&nbsp;&nbsp;&nbsp;</li>
                <li>private&nbsp;String&nbsp;college=&quot;AKG&quot;;&nbsp;&nbsp;&nbsp;&nbsp;</li>
                <li>//getter&nbsp;method&nbsp;for&nbsp;college&nbsp;&nbsp;&nbsp;&nbsp;</li>
                <li>public&nbsp;String&nbsp;getCollege(){&nbsp;&nbsp;&nbsp;&nbsp;</li>
                <li>return&nbsp;college;&nbsp;&nbsp;&nbsp;&nbsp;</li>
                <li>}&nbsp;&nbsp;&nbsp;&nbsp;</li>
                <li>}&nbsp;&nbsp;&nbsp;&nbsp;</li>
            </ol>

            <hr />
            <h3>122) How to make a write-only class in Java?</h3>

            <p>A class can be made write-only by making all of the fields private. The write-only class will have only
                setter methods which set the value passed from the main method to the private fields. We cannot read the
                properties of the class because there is no getter method in this class. Consider the following example.
            </p>

            <ol start="1">
                <li>&nbsp;&nbsp;//A&nbsp;Java&nbsp;class&nbsp;which&nbsp;has&nbsp;only&nbsp;setter&nbsp;methods.&nbsp;&nbsp;&nbsp;&nbsp;
                </li>
                <li>public&nbsp;class&nbsp;Student{&nbsp;&nbsp;&nbsp;&nbsp;</li>
                <li>//private&nbsp;data&nbsp;member&nbsp;&nbsp;&nbsp;&nbsp;</li>
                <li>private&nbsp;String&nbsp;college;&nbsp;&nbsp;&nbsp;&nbsp;</li>
                <li>//getter&nbsp;method&nbsp;for&nbsp;college&nbsp;&nbsp;&nbsp;&nbsp;</li>
                <li>public&nbsp;void&nbsp;setCollege(String&nbsp;college){&nbsp;&nbsp;&nbsp;&nbsp;</li>
                <li>this.college=college;&nbsp;&nbsp;&nbsp;&nbsp;</li>
                <li>}&nbsp;&nbsp;&nbsp;&nbsp;</li>
                <li>}&nbsp;&nbsp;&nbsp;&nbsp;</li>
            </ol>

            <hr />
            <h3>123) What are the advantages of Encapsulation in Java?</h3>

            <p>There are the following advantages of Encapsulation in Java?</p>

            <ul>
                <li>By providing only the setter or getter method, you can make the class read-only or write-only. In
                    other words, you can skip the getter or setter methods.</li>
                <li>It provides you the control over the data. Suppose you want to set the value of id which should be
                    greater than 100 only, you can write the logic inside the setter method. You can write the logic not
                    to store the negative numbers in the setter methods.</li>
                <li>It is a way to achieve data hiding in Java because other class will not be able to access the data
                    through the private data members.</li>
                <li>The encapsulate class is easy to test. So, it is better for unit testing.</li>
                <li>The standard IDE&#39;s are providing the facility to generate the getters and setters. So, it is
                    easy and fast to create an encapsulated class in Java.</li>
            </ul>

            <hr />
            <h2>Core Java - OOPs Concepts: Package Interview Questions</h2>

            <hr />
            <h3>124) What is the package?</h3>

            <p>A package is a group of similar type of classes, interfaces, and sub-packages. It provides access
                protection and removes naming collision. The packages in Java can be categorized into two forms, inbuilt
                package, and user-defined package. There are many built-in packages such as Java, lang, awt, javax,
                swing, net, io, util, sql, etc. Consider the following example to create a package in Java.</p>

            <ol start="1">
                <li>//save&nbsp;as&nbsp;Simple.java&nbsp;&nbsp;</li>
                <li>package&nbsp;mypack;&nbsp;&nbsp;</li>
                <li>public&nbsp;class&nbsp;Simple{&nbsp;&nbsp;</li>
                <li>&nbsp;public&nbsp;static&nbsp;void&nbsp;main(String&nbsp;args[]){&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(&quot;Welcome&nbsp;to&nbsp;package&quot;);&nbsp;&nbsp;
                </li>
                <li>&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</li>
                <li>}&nbsp;&nbsp;</li>
            </ol>

            <p><br />
                <img alt="package in java" src="https://static.javatpoint.com/images/package.JPG"
                    title="package" /><br />
                <a href="https://www.javatpoint.com/package">More details.</a>
            </p>

            <hr />
            <h3>125) What are the advantages of defining packages in Java?</h3>

            <p>By defining packages, we can avoid the name conflicts between the same class names defined in different
                packages. Packages also enable the developer to organize the similar classes more effectively. For
                example, one can clearly understand that the classes present in java.io package are used to perform io
                related operations.</p>

            <hr />
            <h3>126) How to create packages in Java?</h3>

            <p>If you are using the programming IDEs like Eclipse, NetBeans, MyEclipse, etc. click
                on&nbsp;<strong>file-&gt;new-&gt;project</strong>&nbsp;and eclipse will ask you to enter the name of the
                package. It will create the project package containing various directories such as src, etc. If you are
                using an editor like notepad for java programming, use the following steps to create the package.</p>

            <ol start="1">
                <li>javac&nbsp;-d&nbsp;.&nbsp;your_class_name.java&nbsp;&nbsp;</li>
            </ol>

            <p>The above command creates the package with the name&nbsp;<strong>package_name</strong>&nbsp;in the
                present working directory.</p>

            <ol start="1">
                <li>java&nbsp;package_name.class_name&nbsp;&nbsp;</li>
            </ol>

            <ul>
                <li>Define a package&nbsp;<strong>package_name</strong>. Create the class with the
                    name&nbsp;<strong>class_name</strong>&nbsp;and save this file
                    with&nbsp;<strong>your_class_name.java</strong>.</li>
                <br />
                <li>Now compile the file by running the following command on the terminal.</li>
                <li>Now, run the class file by using the absolute class file name, like following.</li>
            </ul>

            <hr />
            <h3>127) How can we access some class in another class in Java?</h3>

            <p>There are two ways to access a class in another class.</p>

            <ul>
                <li><strong>By using the fully qualified name:</strong>&nbsp;To access a class in a different package,
                    either we must use the fully qualified name of that class, or we must import the package containing
                    that class.</li>
                <li><strong>By using the relative path</strong>, We can use the path of the class that is related to the
                    package that contains our class. It can be the same or subpackage.</li>
            </ul>

            <hr />
            <h3>128) Do I need to import java.lang package any time? Why?</h3>

            <p>No. It is by default loaded internally by the JVM.</p>

            <hr />
            <h3>129) Can I import same package/class twice? Will the JVM load the package twice at runtime?</h3>

            <p>One can import the same package or the same class multiple times. Neither compiler nor JVM complains
                about it. However, the JVM will internally load the class only once no matter how many times you import
                the same class.</p>

            <hr />
            <h3>130) What is the static import?</h3>

            <p>By static import, we can access the static members of a class directly, and there is no to qualify it
                with the class name.</p>

            <p><a href="https://www.javatpoint.com/static-import-in-java">More details.</a></p>

            <hr />
            <h2>Java: Exception Handling Interview Questions</h2>

            <p>There is given a list of exception handling interview questions with answers. If you know any exception
                handling interview question, kindly post it in the comment section.</p>

            <hr />
            <h3>131) How many types of exception can occur in a Java program?</h3>

            <p>There are mainly two types of exceptions: checked and unchecked. Here, an error is considered as the
                unchecked exception. According to Oracle, there are three types of exceptions:</p>

            <ul>
                <li><strong>Checked Exception:</strong>&nbsp;Checked exceptions are the one which are checked at
                    compile-time. For example, SQLException, ClassNotFoundException, etc.</li>
                <br />
                <li><strong>Unchecked Exception:</strong>&nbsp;Unchecked exceptions are the one which are handled at
                    runtime because they can not be checked at compile-time. For example, ArithmaticException,
                    NullPointerException, ArrayIndexOutOfBoundsException, etc.</li>
                <br />
                <li><strong>Error:</strong>&nbsp;Error cause the program to exit since they are not recoverable. For
                    Example, OutOfMemoryError, AssertionError, etc.</li>
            </ul>

            <hr />
            <h3>132) What is Exception Handling?</h3>

            <p>Exception Handling is a mechanism that is used to handle runtime errors. It is used primarily to handle
                checked exceptions. Exception handling maintains the normal flow of the program. There are mainly two
                types of exceptions: checked and unchecked. Here, the error is considered as the unchecked exception.
            </p>

            <p><a href="https://www.javatpoint.com/exception-handling-and-checked-and-unchecked-exception">More
                    details.</a></p>

            <hr />
            <h3>133) Explain the hierarchy of Java Exception classes?</h3>

            <p>The java.lang.Throwable class is the root class of Java Exception hierarchy which is inherited by two
                subclasses: Exception and Error. A hierarchy of Java Exception classes are given below:</p>

            <p><img alt="hierarchy of exception handling" src="https://static.javatpoint.com/images/throwable.png" />
            </p>

            <hr />
            <h3>134) What is the difference between Checked Exception and Unchecked Exception?</h3>

            <h3>1) Checked Exception</h3>

            <p>The classes that extend Throwable class except RuntimeException and Error are known as checked
                exceptions, e.g., IOException, SQLException, etc. Checked exceptions are checked at compile-time.</p>

            <h3>2) Unchecked Exception</h3>

            <p>The classes that extend RuntimeException are known as unchecked exceptions, e.g., ArithmeticException,
                NullPointerException, etc. Unchecked exceptions are not checked at compile-time.</p>

            <p><a href="https://www.javatpoint.com/exception-handling-and-checked-and-unchecked-exception">More
                    details.</a></p>

            <hr />
            <h3>135) What is the base class for Error and Exception?</h3>

            <p>The Throwable class is the base class for Error and Exception.</p>

            <hr />
            <h3>136) Is it necessary that each try block must be followed by a catch block?</h3>

            <p>It is not necessary that each try block must be followed by a catch block. It should be followed by
                either a catch block OR a finally block. So whatever exceptions are likely to be thrown should be
                declared in the throws clause of the method. Consider the following example.</p>

            <ol start="1">
                <li>public&nbsp;class&nbsp;Main{&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;void&nbsp;main(String&nbsp;[]args){&nbsp;&nbsp;
                </li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;try{&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;a&nbsp;=&nbsp;1;&nbsp;&nbsp;&nbsp;
                </li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(a/0);&nbsp;&nbsp;
                </li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;finally&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(&quot;rest&nbsp;of&nbsp;the&nbsp;code...&quot;);&nbsp;&nbsp;
                </li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</li>
                <li>}&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</li>
            </ol>

            <p><strong>Output:</strong></p>

            <pre>
            Exception in thread main java.lang.ArithmeticException:/ by zero
            rest of the code...
            </pre>

            <hr />
            <h3>137) What is the output of the following Java program?</h3>

            <ol start="1">
                <li>public&nbsp;class&nbsp;ExceptionHandlingExample&nbsp;{&nbsp;&nbsp;</li>
                <li>public&nbsp;static&nbsp;void&nbsp;main(String&nbsp;args[])&nbsp;&nbsp;</li>
                <li>{&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;try&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;a&nbsp;=&nbsp;1/0;&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(&quot;a&nbsp;=&nbsp;&quot;+a);&nbsp;&nbsp;
                </li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;catch(Exception&nbsp;e){System.out.println(e);}&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;catch(ArithmeticException&nbsp;ex){System.out.println(ex);}&nbsp;&nbsp;&nbsp;&nbsp;
                </li>
                <li>}&nbsp;&nbsp;</li>
                <li>}&nbsp;&nbsp;</li>
            </ol>

            <p><strong>Output</strong></p>

            <pre>
            ExceptionHandlingExample.java:10: error: exception ArithmeticException has already been caught
                catch(ArithmeticException ex){System.out.println(ex);}	
                ^
            1 error
            </pre>

            <p><strong>Explanation</strong></p>

            <p>ArithmaticException is the subclass of Exception. Therefore, it can not be used after Exception. Since
                Exception is the base class for all the exceptions, therefore, it must be used at last to handle the
                exception. No class can be used after this.</p>

            <hr />
            <h3>138) What is finally block?</h3>

            <p>The &quot;finally&quot; block is used to execute the important code of the program. It is executed
                whether an exception is handled or not. In other words, we can say that finally block is the block which
                is always executed. Finally block follows try or catch block. If you don&#39;t handle the exception,
                before terminating the program, JVM runs finally block, (if any). The finally block is mainly used to
                place the cleanup code such as closing a file or closing a connection. Here, we must know that for each
                try block there can be zero or more catch blocks, but only one finally block. The finally block will not
                be executed if program exits(either by calling System.exit() or by causing a fatal error that causes the
                process to abort).</p>

            <p><img alt="java finally" src="https://static.javatpoint.com/images/finally.JPG" /><br />
                <a href="https://www.javatpoint.com/finally-block-in-exception-handling">More details.</a>
            </p>

            <hr />
            <h3>139) Can finally block be used without a catch?</h3>

            <p>Yes, According to the definition of finally block, it must be followed by a try or catch block,
                therefore, we can use try block instead of catch.<a
                    href="https://www.javatpoint.com/finally-block-in-exception-handling">&nbsp;More details.</a></p>

            <p>&nbsp;</p>

            <hr />
            <h3>140) Is there any case when finally will not be executed?</h3>

            <p>Finally block will not be executed if program exits(either by calling System.exit() or by causing a fatal
                error that causes the process to abort).<a
                    href="https://www.javatpoint.com/finally-block-in-exception-handling">More details.</a></p>

            <hr />
            <h3>141) What is the difference between throw and throws?</h3>

            <table>
                <tbody>
                    <tr>
                        <th>throw keyword</th>
                        <th>throws keyword</th>
                    </tr>
                    <tr>
                        <td>1) The&nbsp;<strong>throw</strong>&nbsp;keyword is used to throw an exception explicitly.
                        </td>
                        <td>The&nbsp;<strong>throws</strong>&nbsp;keyword is used to declare an exception.</td>
                    </tr>
                    <tr>
                        <td>2) The checked exceptions cannot be propagated with throw only.</td>
                        <td>The checked exception can be propagated with throws</td>
                    </tr>
                    <tr>
                        <td>3) The&nbsp;<strong>throw</strong>&nbsp;keyword is followed by an instance.</td>
                        <td>The&nbsp;<strong>throws</strong>&nbsp;keyword is followed by class.</td>
                    </tr>
                    <tr>
                        <td>4) The&nbsp;<strong>throw</strong>&nbsp;keyword is used within the method.</td>
                        <td>The&nbsp;<strong>throws</strong>&nbsp;keyword is used with the method signature.</td>
                    </tr>
                    <tr>
                        <td>5) You cannot throw multiple exceptions.</td>
                        <td>You can declare multiple exceptions, e.g., public void method()throws IOException,
                            SQLException.</td>
                    </tr>
                </tbody>
            </table>

            <p><a href="https://www.javatpoint.com/throws-keyword-and-difference-between-throw-and-throws">More
                    details.</a></p>

            <hr />
            <h3>142) What is the output of the following Java program?</h3>

            <ol start="1">
                <li>&nbsp;&nbsp;public&nbsp;class&nbsp;Main{&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;void&nbsp;main(String&nbsp;[]args){&nbsp;&nbsp;
                </li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;try&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;throw&nbsp;90;&nbsp;&nbsp;&nbsp;
                </li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;catch(int&nbsp;e){&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(&quot;Caught&nbsp;the&nbsp;exception&nbsp;&quot;+e);&nbsp;&nbsp;
                </li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</li>
                <li>}&nbsp;&nbsp;</li>
            </ol>

            <p><strong>Output</strong></p>

            <pre>
            Main.java:6: error: incompatible types: int cannot be converted to Throwable
                        throw 90; 
                        ^
            Main.java:8: error: unexpected type
                    catch(int e){
                          ^
              required: class
              found:    int
            2 errors
            </pre>

            <p><strong>Explanation</strong></p>

            <p>In Java, the throwable objects can only be thrown. If we try to throw an integer object, The compiler
                will show an error since we can not throw basic data type from a block of code.</p>

            <hr />
            <h3>143) What is the output of the following Java program?</h3>

            <ol start="1">
                <li>class&nbsp;Calculation&nbsp;extends&nbsp;Exception&nbsp;&nbsp;</li>
                <li>{&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;Calculation()&nbsp;&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(&quot;Calculation&nbsp;class&nbsp;is&nbsp;instantiated&quot;);&nbsp;&nbsp;
                </li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;add(int&nbsp;a,&nbsp;int&nbsp;b)&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(&quot;The&nbsp;sum&nbsp;is&nbsp;&quot;+(a+b));&nbsp;&nbsp;
                </li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</li>
                <li>}&nbsp;&nbsp;</li>
                <li>public&nbsp;class&nbsp;Main{&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;void&nbsp;main(String&nbsp;[]args){&nbsp;&nbsp;
                </li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;try&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;throw&nbsp;new&nbsp;Calculation();&nbsp;&nbsp;&nbsp;
                </li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;catch(Calculation&nbsp;c){&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;c.add(10,20);&nbsp;&nbsp;
                </li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</li>
                <li>}&nbsp;&nbsp;&nbsp;</li>
            </ol>

            <p><strong>Output</strong></p>

            <pre>
            Calculation class is instantiated
            The sum is 30
            </pre>

            <p><strong>Explanation</strong></p>

            <p>The object of Calculation is thrown from the try block which is caught in the catch block. The add() of
                Calculation class is called with the integer values 10 and 20 by using the object of this class.
                Therefore there sum 30 is printed. The object of the Main class can only be thrown in the case when the
                type of the object is throwable. To do so, we need to extend the throwable class.</p>

            <hr />
            <h3>144) Can an exception be rethrown?</h3>

            <p>Yes.</p>

            <hr />
            <h3>145) Can subclass overriding method declare an exception if parent class method doesn&#39;t throw an
                exception?</h3>

            <p>Yes but only unchecked exception not checked.</p>

            <p><a href="https://www.javatpoint.com/exception-handling-with-method-overriding">More details.</a></p>

            <hr />
            <h3>146) What is exception propagation?</h3>

            <p>An exception is first thrown from the top of the stack and if it is not caught, it drops down the call
                stack to the previous method, If not caught there, the exception again drops down to the previous
                method, and so on until they are caught or until they reach the very bottom of the call stack. This
                procedure is called exception propagation. By default, checked exceptions are not propagated.</p>

            <ol start="1">
                <li>class&nbsp;TestExceptionPropagation1{&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;void&nbsp;m(){&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;data=50/0;&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;}&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;void&nbsp;n(){&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;m();&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;}&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;void&nbsp;p(){&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;try{&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;n();&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;}catch(Exception&nbsp;e){System.out.println(&quot;exception&nbsp;handled&quot;);}&nbsp;&nbsp;
                </li>
                <li>&nbsp;&nbsp;}&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;public&nbsp;static&nbsp;void&nbsp;main(String&nbsp;args[]){&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;TestExceptionPropagation1&nbsp;obj=new&nbsp;TestExceptionPropagation1();&nbsp;&nbsp;
                </li>
                <li>&nbsp;&nbsp;&nbsp;obj.p();&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;System.out.println(&quot;normal&nbsp;flow...&quot;);&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;}&nbsp;&nbsp;</li>
                <li>}&nbsp;&nbsp;</li>
            </ol>

            <p><a href="https://www.javatpoint.com/opr/test.jsp?filename=TestExceptionPropagation1" target="_blank">Test
                    it Now</a></p>

            <p><strong>Output:</strong></p>

            <pre>
            exception handled
            normal flow...
            </pre>

            <p><img alt="exception propagation" src="https://static.javatpoint.com/images/propagation.JPG" /><br />
                <a href="https://www.javatpoint.com/exception-propagation">More details.</a>
            </p>

            <hr />
            <hr />
            <hr />
            <h3>147) What is the output of the following Java program?</h3>

            <ol start="1">
                <li>public&nbsp;class&nbsp;Main&nbsp;&nbsp;&nbsp;</li>
                <li>{&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;void&nbsp;a()&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;try{&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(&quot;a():&nbsp;Main&nbsp;called&quot;);&nbsp;&nbsp;
                </li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;b();&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}catch(Exception&nbsp;e)&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(&quot;Exception&nbsp;is&nbsp;caught&quot;);&nbsp;&nbsp;
                </li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;void&nbsp;b()&nbsp;throws&nbsp;Exception&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;try{&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(&quot;b():&nbsp;Main&nbsp;called&quot;);&nbsp;&nbsp;
                </li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;c();&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}catch(Exception&nbsp;e){&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;throw&nbsp;new&nbsp;Exception();&nbsp;&nbsp;
                </li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;finally&nbsp;&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(&quot;finally&nbsp;block&nbsp;is&nbsp;called&quot;);&nbsp;&nbsp;
                </li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;void&nbsp;c()&nbsp;throws&nbsp;Exception&nbsp;&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;throw&nbsp;new&nbsp;Exception();&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;void&nbsp;main&nbsp;(String&nbsp;args[])&nbsp;&nbsp;
                </li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Main&nbsp;m&nbsp;=&nbsp;new&nbsp;Main();&nbsp;&nbsp;
                </li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;m.a();&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</li>
                <li>}&nbsp;&nbsp;</li>
            </ol>

            <p><strong>Output</strong></p>

            <pre>
            a(): Main called
            b(): Main called
            finally block is called
            Exception is caught
            </pre>

            <p><strong>Explanation</strong></p>

            <p>In the main method, a() of Main is called which prints a message and call b(). The method b() prints some
                message and then call c(). The method c() throws an exception which is handled by the catch block of
                method b. However, It propagates this exception by using&nbsp;<strong>throw Exception()</strong>&nbsp;to
                be handled by the method a(). As we know, finally block is always executed therefore the finally block
                in the method b() is executed first and prints a message. At last, the exception is handled by the catch
                block of the method a().</p>

            <hr />
            <h3>148) What is the output of the following Java program?</h3>

            <ol start="1">
                <li>public&nbsp;class&nbsp;Calculation&nbsp;&nbsp;&nbsp;</li>
                <li>{&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;a;&nbsp;&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;Calculation(int&nbsp;a)&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.a&nbsp;=&nbsp;a;&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;int&nbsp;add()&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;a&nbsp;=&nbsp;a+10;&nbsp;&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;try&nbsp;&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;a&nbsp;=&nbsp;a+10;&nbsp;&nbsp;&nbsp;
                </li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;try&nbsp;&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;a&nbsp;=&nbsp;a*10;&nbsp;&nbsp;&nbsp;
                </li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;throw&nbsp;new&nbsp;Exception();&nbsp;&nbsp;&nbsp;
                </li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}catch(Exception&nbsp;e){&nbsp;&nbsp;
                </li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;a&nbsp;=&nbsp;a&nbsp;-&nbsp;10;&nbsp;&nbsp;
                </li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}catch(Exception&nbsp;e)&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;a&nbsp;=&nbsp;a&nbsp;-&nbsp;10;&nbsp;&nbsp;&nbsp;
                </li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;a;&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;void&nbsp;main&nbsp;(String&nbsp;args[])&nbsp;&nbsp;
                </li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Calculation&nbsp;c&nbsp;=&nbsp;new&nbsp;Calculation(10);&nbsp;&nbsp;
                </li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;result&nbsp;=&nbsp;c.add();&nbsp;&nbsp;
                </li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(&quot;result&nbsp;=&nbsp;&quot;+result);&nbsp;&nbsp;
                </li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</li>
                <li>}&nbsp;&nbsp;</li>
            </ol>

            <p><strong>Output</strong></p>

            <pre>
            result = 290
            </pre>

            <p><strong>Explanation</strong></p>

            <p>The instance variable a of class Calculation is initialized to 10 using the class constructor which is
                called while instantiating the class. The add method is called which returns an integer value result. In
                add() method, a is incremented by 10 to be 20. Then, in the first try block, 10 is again incremented by
                10 to be 30. In the second try block, a is multiplied by 10 to be 300. The second try block throws the
                exception which is caught by the catch block associated with this try block. The catch block again
                alters the value of a by decrementing it by 10 to make it 290. Thus the add() method returns 290 which
                is assigned to result. However, the catch block associated with the outermost try block will never be
                executed since there is no exception which can be handled by this catch block.</p>

            <hr />
            <h2>Java: String Handling Interview Questions</h2>

            <p>There is given a list of string handling interview questions with short and pointed answers. If you know
                any string handling interview question, kindly post it in the comment section.</p>

            <hr />
            <h3>149) What is String Pool?</h3>

            <p>String pool is the space reserved in the heap memory that can be used to store the strings. The main
                advantage of using the String pool is whenever we create a string literal; the JVM checks the
                &quot;string constant pool&quot; first. If the string already exists in the pool, a reference to the
                pooled instance is returned. If the string doesn&#39;t exist in the pool, a new string instance is
                created and placed in the pool. Therefore, it saves the memory by avoiding the duplicacy.</p>

            <p><img alt="Java string literal" src="https://static.javatpoint.com/images/string.JPG" /></p>

            <hr />
            <h3>150) What is the meaning of immutable regarding String?</h3>

            <p>The simple meaning of immutable is unmodifiable or unchangeable. In Java, String is immutable, i.e., once
                string object has been created, its value can&#39;t be changed. Consider the following example for
                better understanding.</p>

            <ol start="1">
                <li>class&nbsp;Testimmutablestring{&nbsp;&nbsp;</li>
                <li>&nbsp;public&nbsp;static&nbsp;void&nbsp;main(String&nbsp;args[]){&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;String&nbsp;s=&quot;Sachin&quot;;&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;s.concat(&quot;&nbsp;Tendulkar&quot;);//concat()&nbsp;method&nbsp;appends&nbsp;the&nbsp;string&nbsp;at&nbsp;the&nbsp;end&nbsp;&nbsp;
                </li>
                <li>&nbsp;&nbsp;&nbsp;System.out.println(s);//will&nbsp;print&nbsp;Sachin&nbsp;because&nbsp;strings&nbsp;are&nbsp;immutable&nbsp;objects&nbsp;&nbsp;
                </li>
                <li>&nbsp;}&nbsp;&nbsp;</li>
                <li>}&nbsp;&nbsp;</li>
            </ol>

            <p><a href="https://www.javatpoint.com/opr/test.jsp?filename=Testimmutablestring" target="_blank">Test it
                    Now</a></p>

            <p><strong>Output:</strong></p>

            <pre>
            Sachin
            </pre>

            <p><a href="https://www.javatpoint.com/immutable-string">More details.</a></p>

            <hr />
            <h3>151) Why are the objects immutable in java?</h3>

            <p>Because Java uses the concept of the string literal. Suppose there are five reference variables, all
                refer to one object &quot;sachin&quot;. If one reference variable changes the value of the object, it
                will be affected by all the reference variables. That is why string objects are immutable in java.</p>

            <p><img alt="Heap diagram" src="https://static.javatpoint.com/images/string2.JPG" /><br />
                <a href="https://www.javatpoint.com/immutable-string">More details.</a>
            </p>

            <hr />
            <h3>152) How many ways can we create the string object?</h3>

            <h3>1) String Literal</h3>

            <p>Java String literal is created by using double quotes. For Example:</p>

            <ol start="1">
                <li>String&nbsp;s=&quot;welcome&quot;;&nbsp;&nbsp;</li>
            </ol>

            <p>Each time you create a string literal, the JVM checks the &quot;string constant pool&quot; first. If the
                string already exists in the pool, a reference to the pooled instance is returned. If the string
                doesn&#39;t exist in the pool, a new string instance is created and placed in the pool. String objects
                are stored in a special memory area known as the&nbsp;<strong>string constant pool</strong>&nbsp;For
                example:</p>

            <ol start="1">
                <li>String&nbsp;s1=&quot;Welcome&quot;;&nbsp;&nbsp;</li>
                <li>String&nbsp;s2=&quot;Welcome&quot;;//It&nbsp;doesn&#39;t&nbsp;create&nbsp;a&nbsp;new&nbsp;instance&nbsp;&nbsp;
                </li>
            </ol>

            <h3>2) By new keyword</h3>

            <ol start="1">
                <li>String&nbsp;s=new&nbsp;String(&quot;Welcome&quot;);//creates&nbsp;two&nbsp;objects&nbsp;and&nbsp;one&nbsp;reference&nbsp;variable&nbsp;&nbsp;
                </li>
            </ol>

            <p>In such case, JVM will create a new string object in normal (non-pool) heap memory, and the literal
                &quot;Welcome&quot; will be placed in the constant string pool. The variable s will refer to the object
                in a heap (non-pool).</p>

            <hr />
            <h3>153) How many objects will be created in the following code?</h3>

            <ol start="1">
                <li>String&nbsp;s1=&quot;Welcome&quot;;&nbsp;&nbsp;</li>
                <li>String&nbsp;s2=&quot;Welcome&quot;;&nbsp;&nbsp;</li>
                <li>String&nbsp;s3=&quot;Welcome&quot;;&nbsp;&nbsp;</li>
            </ol>

            <p>Only one object will be created using the above code because strings in Java are immutable.</p>

            <p><a href="https://www.javatpoint.com/string-handling-in-java">More details.</a></p>

            <hr />
            <h3>154) Why java uses the concept of the string literal?</h3>

            <p>To make Java more memory efficient (because no new objects are created if it exists already in the string
                constant pool).</p>

            <p><a href="https://www.javatpoint.com/string-handling-in-java">More details.</a></p>

            <hr />
            <h3>155) How many objects will be created in the following code?</h3>

            <ol start="1">
                <li>String&nbsp;s&nbsp;=&nbsp;new&nbsp;String(&quot;Welcome&quot;);&nbsp;&nbsp;</li>
            </ol>

            <p>Two objects, one in string constant pool and other in non-pool(heap).</p>

            <p><a href="https://www.javatpoint.com/string-handling-in-java">More details.</a></p>

            <hr />
            <h3>156) What is the output of the following Java program?</h3>

            <ol start="1">
                <li>public&nbsp;class&nbsp;Test&nbsp;&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;public&nbsp;static&nbsp;void&nbsp;main&nbsp;(String&nbsp;args[])&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;{&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;String&nbsp;a&nbsp;=&nbsp;new&nbsp;String(&quot;Sharma&nbsp;is&nbsp;a&nbsp;good&nbsp;player&quot;);&nbsp;&nbsp;
                </li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;String&nbsp;b&nbsp;=&nbsp;&quot;Sharma&nbsp;is&nbsp;a&nbsp;good&nbsp;player&quot;;&nbsp;&nbsp;
                </li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(a&nbsp;==&nbsp;b)&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(&quot;a&nbsp;==&nbsp;b&quot;);&nbsp;&nbsp;
                </li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(a.equals(b))&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(&quot;a&nbsp;equals&nbsp;b&quot;);&nbsp;&nbsp;
                </li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;}&nbsp;&nbsp;</li>
            </ol>

            <p><strong>Output</strong></p>

            <pre>
              a equals b
            </pre>

            <p><strong>Explanation</strong></p>

            <p>The operator&nbsp;<strong>==</strong>&nbsp;also check whether the references of the two string objects
                are equal or not. Although both of the strings contain the same content, their references are not equal
                because both are created by different ways(Constructor and String literal) therefore,&nbsp;<strong>a ==
                    b</strong>&nbsp;is unequal. On the other hand, the equal() method always check for the content.
                Since their content is equal hence,&nbsp;<strong>a equals b</strong>&nbsp;is printed.</p>

            <hr />
            <h3>157) What is the output of the following Java program?</h3>

            <ol start="1">
                <li>public&nbsp;class&nbsp;Test&nbsp;&nbsp;&nbsp;</li>
                <li>{&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;void&nbsp;main&nbsp;(String&nbsp;args[])&nbsp;&nbsp;
                </li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;String&nbsp;s1&nbsp;=&nbsp;&quot;Sharma&nbsp;is&nbsp;a&nbsp;good&nbsp;player&quot;;&nbsp;&nbsp;
                </li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;String&nbsp;s2&nbsp;=&nbsp;new&nbsp;String(&quot;Sharma&nbsp;is&nbsp;a&nbsp;good&nbsp;player&quot;);&nbsp;&nbsp;
                </li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;s2&nbsp;=&nbsp;s2.intern();&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(s1&nbsp;==s2);&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</li>
                <li>}&nbsp;&nbsp;</li>
            </ol>

            <p><strong>Output</strong></p>

            <pre>
            true
            </pre>

            <p><strong>Explanation</strong></p>

            <p>The intern method returns the String object reference from the string pool. In this case, s1 is created
                by using string literal whereas, s2 is created by using the String pool. However, s2 is changed to the
                reference of s1, and the operator&nbsp;<strong>==</strong>&nbsp;returns true.</p>

            <hr />
            <h3>158) What are the differences between String and StringBuffer?</h3>

            <p>The differences between the String and StringBuffer is given in the table below.</p>

            <p>&nbsp;</p>

            <table>
                <tbody>
                    <tr>
                        <th>No.</th>
                        <th>String</th>
                        <th>StringBuffer</th>
                    </tr>
                    <tr>
                        <td>1)</td>
                        <td>The String class is immutable.</td>
                        <td>The StringBuffer class is mutable.</td>
                    </tr>
                    <tr>
                        <td>2)</td>
                        <td>The String is slow and consumes more memory when you concat too many strings because every
                            time it creates a new instance.</td>
                        <td>The StringBuffer is fast and consumes less memory when you cancat strings.</td>
                    </tr>
                    <tr>
                        <td>3)</td>
                        <td>The String class overrides the equals() method of Object class. So you can compare the
                            contents of two strings by equals() method.</td>
                        <td>The StringBuffer class doesn&#39;t override the equals() method of Object class.</td>
                    </tr>
                </tbody>
            </table>

            <hr />
            <h3>159) What are the differences between StringBuffer and StringBuilder?</h3>

            <p>The differences between the StringBuffer and StringBuilder is given below.</p>

            <table>
                <tbody>
                    <tr>
                        <th>No.</th>
                        <th>StringBuffer</th>
                        <th>StringBuilder</th>
                    </tr>
                    <tr>
                        <td>1)</td>
                        <td>StringBuffer is&nbsp;<em>synchronized</em>, i.e., thread safe. It means two threads
                            can&#39;t call the methods of StringBuffer simultaneously.</td>
                        <td>StringBuilder is&nbsp;<em>non-synchronized</em>,i.e., not thread safe. It means two threads
                            can call the methods of StringBuilder simultaneously.</td>
                    </tr>
                    <tr>
                        <td>2)</td>
                        <td>StringBuffer is&nbsp;<em>less efficient</em>&nbsp;than StringBuilder.</td>
                        <td>StringBuilder is&nbsp;<em>more efficient</em>&nbsp;than StringBuffer.</td>
                    </tr>
                </tbody>
            </table>

            <hr />
            <h3>160) How can we create an immutable class in Java?</h3>

            <p>We can create an immutable class by defining a final class having all of its members as final. Consider
                the following example.</p>

            <ol start="1">
                <li>public&nbsp;final&nbsp;class&nbsp;Employee{&nbsp;&nbsp;</li>
                <li>final&nbsp;String&nbsp;pancardNumber;&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;</li>
                <li>public&nbsp;Employee(String&nbsp;pancardNumber){&nbsp;&nbsp;</li>
                <li>this.pancardNumber=pancardNumber;&nbsp;&nbsp;</li>
                <li>}&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;</li>
                <li>public&nbsp;String&nbsp;getPancardNumber(){&nbsp;&nbsp;</li>
                <li>return&nbsp;pancardNumber;&nbsp;&nbsp;</li>
                <li>}&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;</li>
                <li>}&nbsp;&nbsp;</li>
            </ol>

            <p><a href="https://www.javatpoint.com/how-to-create-immutable-class">More details.</a></p>

            <hr />
            <h3>161) What is the purpose of toString() method in Java?</h3>

            <p>The toString() method returns the string representation of an object. If you print any object, java
                compiler internally invokes the toString() method on the object. So overriding the toString() method,
                returns the desired output, it can be the state of an object, etc. depending upon your implementation.
                By overriding the toString() method of the Object class, we can return the values of the object, so we
                don&#39;t need to write much code. Consider the following example.</p>

            <ol start="1">
                <li>class&nbsp;Student{&nbsp;&nbsp;</li>
                <li>&nbsp;int&nbsp;rollno;&nbsp;&nbsp;</li>
                <li>&nbsp;String&nbsp;name;&nbsp;&nbsp;</li>
                <li>&nbsp;String&nbsp;city;&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;</li>
                <li>&nbsp;Student(int&nbsp;rollno,&nbsp;String&nbsp;name,&nbsp;String&nbsp;city){&nbsp;&nbsp;</li>
                <li>&nbsp;this.rollno=rollno;&nbsp;&nbsp;</li>
                <li>&nbsp;this.name=name;&nbsp;&nbsp;</li>
                <li>&nbsp;this.city=city;&nbsp;&nbsp;</li>
                <li>&nbsp;}&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;</li>
                <li>&nbsp;public&nbsp;String&nbsp;toString(){//overriding&nbsp;the&nbsp;toString()&nbsp;method&nbsp;&nbsp;
                </li>
                <li>&nbsp;&nbsp;return&nbsp;rollno+&quot;&nbsp;&quot;+name+&quot;&nbsp;&quot;+city;&nbsp;&nbsp;</li>
                <li>&nbsp;}&nbsp;&nbsp;</li>
                <li>&nbsp;public&nbsp;static&nbsp;void&nbsp;main(String&nbsp;args[]){&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;Student&nbsp;s1=new&nbsp;Student(101,&quot;Raj&quot;,&quot;lucknow&quot;);&nbsp;&nbsp;
                </li>
                <li>&nbsp;&nbsp;&nbsp;Student&nbsp;s2=new&nbsp;Student(102,&quot;Vijay&quot;,&quot;ghaziabad&quot;);&nbsp;&nbsp;
                </li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;System.out.println(s1);//compiler&nbsp;writes&nbsp;here&nbsp;s1.toString()&nbsp;&nbsp;
                </li>
                <li>&nbsp;&nbsp;&nbsp;System.out.println(s2);//compiler&nbsp;writes&nbsp;here&nbsp;s2.toString()&nbsp;&nbsp;
                </li>
                <li>&nbsp;}&nbsp;&nbsp;</li>
                <li>}&nbsp;&nbsp;</li>
            </ol>

            <p><strong>Output:</strong></p>

            <pre>
            101 Raj lucknow
            102 Vijay ghaziabad
            </pre>

            <p><a href="https://www.javatpoint.com/understanding-toString()-method">More details.</a></p>

            <hr />
            <h3>162) Why CharArray() is preferred over String to store the password?</h3>

            <p>String stays in the string pool until the garbage is collected. If we store the password into a string,
                it stays in the memory for a longer period, and anyone having the memory-dump can extract the password
                as clear text. On the other hand, Using CharArray allows us to set it to blank whenever we are done with
                the password. It avoids the security threat with the string by enabling us to control the memory.</p>

            <hr />
            <h3>163) Write a Java program to count the number of words present in a string?</h3>

            <p><strong>Program:</strong></p>

            <ol start="1">
                <li>&nbsp;&nbsp;public&nbsp;class&nbsp;Test&nbsp;&nbsp;&nbsp;</li>
                <li>{&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;void&nbsp;main&nbsp;(String&nbsp;args[])&nbsp;&nbsp;
                </li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;String&nbsp;s&nbsp;=&nbsp;&quot;Sharma&nbsp;is&nbsp;a&nbsp;good&nbsp;player&nbsp;and&nbsp;he&nbsp;is&nbsp;so&nbsp;punctual&quot;;&nbsp;&nbsp;
                </li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;String&nbsp;words[]&nbsp;=&nbsp;s.split(&quot;&nbsp;&quot;);&nbsp;&nbsp;
                </li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(&quot;The&nbsp;Number&nbsp;of&nbsp;words&nbsp;present&nbsp;in&nbsp;the&nbsp;string&nbsp;are&nbsp;:&nbsp;&quot;+words.length);&nbsp;&nbsp;
                </li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</li>
                <li>}&nbsp;&nbsp;</li>
            </ol>

            <p><strong>Output</strong></p>

            <pre>
            The Number of words present in the string are : 10
            </pre>

            <hr />
            <h3>164) Name some classes present in&nbsp;<strong>java.util.regex</strong>&nbsp;package.</h3>

            <p>There are the following classes and interfaces present in java.util.regex package.</p>

            <ul>
                <li>MatchResult Interface</li>
                <li>Matcher class</li>
                <li>Pattern class</li>
                <li>PatternSyntaxException class</li>
            </ul>

            <p><img alt="Java Regex API" src="https://static.javatpoint.com/images/java-regex-api.jpg" /></p>

            <hr />
            <h3>165) How the metacharacters are different from the ordinary characters?</h3>

            <p>Metacharacters have the special meaning to the regular expression engine. The metacharacters are ^, $, .,
                *, +, etc. The regular expression engine does not consider them as the regular characters. To enable the
                regular expression engine treating the metacharacters as ordinary characters, we need to escape the
                metacharacters with the backslash.</p>

            <hr />
            <h3>166) Write a regular expression to validate a password. A password must start with an alphabet and
                followed by alphanumeric characters; Its length must be in between 8 to 20.</h3>

            <p>The regular expression for the above criteria will
                be:&nbsp;<strong>^[a-zA-Z][a-zA-Z0-9]{8,19}</strong>&nbsp;where ^ represents the start of the regex,
                [a-zA-Z] represents that the first character must be an alphabet, [a-zA-Z0-9] represents the
                alphanumeric character, {8,19} represents that the length of the password must be in between 8 and 20.
            </p>

            <hr />
            <h3>167) What is the output of the following Java program?</h3>

            <ol start="1">
                <li>import&nbsp;java.util.regex.*;&nbsp;&nbsp;</li>
                <li>class&nbsp;RegexExample2{&nbsp;&nbsp;</li>
                <li>public&nbsp;static&nbsp;void&nbsp;main(String&nbsp;args[]){&nbsp;&nbsp;</li>
                <li>System.out.println(Pattern.matches(&quot;.s&quot;,&nbsp;&quot;as&quot;));&nbsp;//line&nbsp;4&nbsp;&nbsp;
                </li>
                <li>System.out.println(Pattern.matches(&quot;.s&quot;,&nbsp;&quot;mk&quot;));&nbsp;//line&nbsp;5&nbsp;&nbsp;&nbsp;
                </li>
                <li>System.out.println(Pattern.matches(&quot;.s&quot;,&nbsp;&quot;mst&quot;));&nbsp;//line&nbsp;6&nbsp;&nbsp;
                </li>
                <li>System.out.println(Pattern.matches(&quot;.s&quot;,&nbsp;&quot;amms&quot;));&nbsp;//line&nbsp;7&nbsp;&nbsp;
                </li>
                <li>System.out.println(Pattern.matches(&quot;..s&quot;,&nbsp;&quot;mas&quot;));&nbsp;//line&nbsp;8&nbsp;&nbsp;
                </li>
                <li>}}&nbsp;&nbsp;</li>
            </ol>

            <p><strong>Output</strong></p>

            <pre>
            true
            false 
            false
            false 
            true
            </pre>

            <p><strong>Explanation</strong></p>

            <p>line 4 prints true since the second character of string is s, line 5 prints false since the second
                character is not s, line 6 prints false since there are more than 3 characters in the string, line 7
                prints false since there are more than 2 characters in the string, and it contains more than 2
                characters as well, line 8 prints true since the third character of the string is s.</p>

            <hr />
            <h2>Core Java: Nested classes and Interfaces Interview Questions</h2>

            <hr />
            <h3>168) What are the advantages of Java inner classes?</h3>

            <p>There are two types of advantages of Java inner classes.</p>

            <ul>
                <li>Nested classes represent a special type of relationship that is it can access all the members (data
                    members and methods) of the outer class including private.</li>
                <li>Nested classes are used to develop a more readable and maintainable code because it logically groups
                    classes and interfaces in one place only.</li>
                <li><strong>Code Optimization:</strong>&nbsp;It requires less code to write.</li>
            </ul>

            <hr />
            <h3>169) What is a nested class?</h3>

            <p>The nested class can be defined as the class which is defined inside another class or interface. We use
                the nested class to logically group classes and interfaces in one place so that it can be more readable
                and maintainable. A nested class can access all the data members of the outer class including private
                data members and methods. The syntax of the nested class is defined below.</p>

            <ol start="1">
                <li>class&nbsp;Java_Outer_class{&nbsp;&nbsp;&nbsp;&nbsp;</li>
                <li>&nbsp;//code&nbsp;&nbsp;&nbsp;&nbsp;</li>
                <li>&nbsp;class&nbsp;Java_Nested_class{&nbsp;&nbsp;&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;//code&nbsp;&nbsp;&nbsp;&nbsp;</li>
                <li>&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;</li>
                <li>}&nbsp;&nbsp;&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</li>
            </ol>

            <p>There are two types of nested classes, static nested class, and non-static nested class. The non-static
                nested class can also be called as inner-class</p>

            <p><a href="https://www.javatpoint.com/difference-between-nested-classes-and-inner-classes">More
                    details.</a></p>

            <hr />
            <h3>170) What are the disadvantages of using inner classes?</h3>

            <p>There are the following main disadvantages of using inner classes.</p>

            <ul>
                <li>Inner classes increase the total number of classes used by the developer and therefore increases the
                    workload of JVM since it has to perform some routine operations for those extra classes which result
                    in slower performance.</li>
                <li>IDEs provide less support to the inner classes as compare to the top level classes and therefore it
                    annoys the developers while working with inner classes.</li>
            </ul>

            <hr />
            <h3>171) What are the types of inner classes (non-static nested class) used in Java?</h3>

            <p>There are mainly three types of inner classes used in Java.</p>

            <table>
                <tbody>
                    <tr>
                        <th>Type</th>
                        <th>Description</th>
                    </tr>
                    <tr>
                        <td><a href="https://www.javatpoint.com/member-inner-class">Member Inner Class</a></td>
                        <td>A class created within class and outside method.</td>
                    </tr>
                    <tr>
                        <td><a href="https://www.javatpoint.com/anonymous-inner-class">Anonymous Inner Class</a></td>
                        <td>A class created for implementing an interface or extending class. Its name is decided by the
                            java compiler.</td>
                    </tr>
                    <tr>
                        <td><a href="https://www.javatpoint.com/local-inner-class">Local Inner Class</a></td>
                        <td>A class created within the method.</td>
                    </tr>
                </tbody>
            </table>

            <hr />
            <h3>172) Is there any difference between nested classes and inner classes?</h3>

            <p>Yes, inner classes are non-static nested classes. In other words, we can say that inner classes are the
                part of nested classes.</p>

            <p><a href="https://www.javatpoint.com/difference-between-nested-classes-and-inner-classes">More
                    details.</a></p>

            <hr />
            <h3>173) Can we access the non-final local variable, inside the local inner class?</h3>

            <p>No, the local variable must be constant if you want to access it in the local inner class.</p>

            <p><a href="https://www.javatpoint.com/local-inner-class">More details.</a></p>

            <hr />
            <h3>174) How many class files are created on compiling the OuterClass in the following program?</h3>

            <ol start="1">
                <li>public&nbsp;class&nbsp;Person&nbsp;{&nbsp;&nbsp;</li>
                <li>String&nbsp;name,&nbsp;age,&nbsp;address;&nbsp;&nbsp;</li>
                <li>class&nbsp;Employee{&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;float&nbsp;salary=10000;&nbsp;&nbsp;</li>
                <li>}&nbsp;&nbsp;</li>
                <li>class&nbsp;BusinessMen{&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;final&nbsp;String&nbsp;gstin=&quot;&pound;4433drt3$&quot;;&nbsp;&nbsp;&nbsp;</li>
                <li>}&nbsp;&nbsp;</li>
                <li>public&nbsp;static&nbsp;void&nbsp;main&nbsp;(String&nbsp;args[])&nbsp;&nbsp;</li>
                <li>{&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;Person&nbsp;p&nbsp;=&nbsp;new&nbsp;Person();&nbsp;&nbsp;</li>
                <li>}&nbsp;&nbsp;</li>
                <li>}&nbsp;&nbsp;</li>
            </ol>

            <p>3 class-files will be created named as Person.class, Person$BusinessMen.class, and Person$Employee.class.
            </p>

            <hr />
            <h3>175) What are anonymous inner classes?</h3>

            <p>Anonymous inner classes are the classes that are automatically declared and instantiated within an
                expression. We cannot apply different access modifiers to them. Anonymous class cannot be static, and
                cannot define any static fields, method, or class. In other words, we can say that it a class without
                the name and can have only one object that is created by its definition. Consider the following example.
            </p>

            <ol start="1">
                <li>abstract&nbsp;class&nbsp;Person{&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;abstract&nbsp;void&nbsp;eat();&nbsp;&nbsp;</li>
                <li>}&nbsp;&nbsp;</li>
                <li>class&nbsp;TestAnonymousInner{&nbsp;&nbsp;</li>
                <li>&nbsp;public&nbsp;static&nbsp;void&nbsp;main(String&nbsp;args[]){&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;Person&nbsp;p=new&nbsp;Person(){&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;void&nbsp;eat(){System.out.println(&quot;nice&nbsp;fruits&quot;);}&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;};&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;p.eat();&nbsp;&nbsp;</li>
                <li>&nbsp;}&nbsp;&nbsp;</li>
                <li>}&nbsp;&nbsp;</li>
            </ol>

            <p><a href="https://www.javatpoint.com/opr/test.jsp?filename=TestAnnonymousInner" target="_blank">Test it
                    Now</a></p>

            <p>Output:</p>

            <pre>
            nice fruits
            </pre>

            <p>Consider the following example for the working of the anonymous class using interface.</p>

            <ol start="1">
                <li>interface&nbsp;Eatable{&nbsp;&nbsp;</li>
                <li>&nbsp;void&nbsp;eat();&nbsp;&nbsp;</li>
                <li>}&nbsp;&nbsp;</li>
                <li>class&nbsp;TestAnnonymousInner1{&nbsp;&nbsp;</li>
                <li>&nbsp;public&nbsp;static&nbsp;void&nbsp;main(String&nbsp;args[]){&nbsp;&nbsp;</li>
                <li>&nbsp;Eatable&nbsp;e=new&nbsp;Eatable(){&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;public&nbsp;void&nbsp;eat(){System.out.println(&quot;nice&nbsp;fruits&quot;);}&nbsp;&nbsp;
                </li>
                <li>&nbsp;};&nbsp;&nbsp;</li>
                <li>&nbsp;e.eat();&nbsp;&nbsp;</li>
                <li>&nbsp;}&nbsp;&nbsp;</li>
                <li>}&nbsp;&nbsp;</li>
            </ol>

            <p><a href="https://www.javatpoint.com/opr/test.jsp?filename=TestAnnonymousInner1" target="_blank">Test it
                    Now</a></p>

            <p>Output:</p>

            <pre>
            nice fruits
            </pre>

            <hr />
            <h3>176) What is the nested interface?</h3>

            <p>An Interface that is declared inside the interface or class is known as the nested interface. It is
                static by default. The nested interfaces are used to group related interfaces so that they can be easy
                to maintain. The external interface or class must refer to the nested interface. It can&#39;t be
                accessed directly. The nested interface must be public if it is declared inside the interface but it can
                have any access modifier if declared within the class. The syntax of the nested interface is given as
                follows.</p>

            <ol start="1">
                <li>interface&nbsp;interface_name{&nbsp;&nbsp;&nbsp;&nbsp;</li>
                <li>&nbsp;...&nbsp;&nbsp;&nbsp;&nbsp;</li>
                <li>&nbsp;interface&nbsp;nested_interface_name{&nbsp;&nbsp;&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;...&nbsp;&nbsp;&nbsp;&nbsp;</li>
                <li>&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;</li>
                <li>}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</li>
            </ol>

            <p><a href="https://www.javatpoint.com/nested-interface">More details.</a></p>

            <hr />
            <h3>177) Can a class have an interface?</h3>

            <p>Yes, an interface can be defined within the class. It is called a nested interface.</p>

            <p><a href="https://www.javatpoint.com/nested-interface">More details.</a></p>

            <hr />
            <h3>178) Can an Interface have a class?</h3>

            <p>Yes, they are static implicitly.</p>

            <p><a href="https://www.javatpoint.com/nested-interface">More details.</a></p>

            <h2>Garbage Collection Interview Questions</h2>

            <hr />
            <h3>179) What is Garbage Collection?</h3>

            <p>Garbage collection is a process of reclaiming the unused runtime objects. It is performed for memory
                management. In other words, we can say that It is the process of removing unused objects from the memory
                to free up space and make this space available for Java Virtual Machine. Due to garbage collection java
                gives 0 as output to a variable whose value is not set, i.e., the variable has been defined but not
                initialized. For this purpose, we were using free() function in the C language and delete() in C++. In
                Java, it is performed automatically. So, java provides better memory management.</p>

            <p><a href="https://www.javatpoint.com/Garbage-Collection">More details.</a></p>

            <hr />
            <h3>180) What is gc()?</h3>

            <p>The gc() method is used to invoke the garbage collector for cleanup processing. This method is found in
                System and Runtime classes. This function explicitly makes the Java Virtual Machine free up the space
                occupied by the unused objects so that it can be utilized or reused. Consider the following example for
                the better understanding of how the gc() method invoke the garbage collector.</p>

            <ol start="1">
                <li>public&nbsp;class&nbsp;TestGarbage1{&nbsp;&nbsp;</li>
                <li>&nbsp;public&nbsp;void&nbsp;finalize(){System.out.println(&quot;object&nbsp;is&nbsp;garbage&nbsp;collected&quot;);}&nbsp;&nbsp;
                </li>
                <li>&nbsp;public&nbsp;static&nbsp;void&nbsp;main(String&nbsp;args[]){&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;TestGarbage1&nbsp;s1=new&nbsp;TestGarbage1();&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;TestGarbage1&nbsp;s2=new&nbsp;TestGarbage1();&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;s1=null;&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;s2=null;&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;System.gc();&nbsp;&nbsp;</li>
                <li>&nbsp;}&nbsp;&nbsp;</li>
                <li>}&nbsp;&nbsp;</li>
            </ol>

            <p><a href="https://www.javatpoint.com/opr/test.jsp?filename=TestGarbage1" target="_blank">Test it Now</a>
            </p>

            <pre>
                   object is garbage collected
                   object is garbage collected
            </pre>

            <hr />
            <h3>181) How is garbage collection controlled?</h3>

            <p>Garbage collection is managed by JVM. It is performed when there is not enough space in the memory and
                memory is running low. We can externally call the System.gc() for the garbage collection. However, it
                depends upon the JVM whether to perform it or not.</p>

            <hr />
            <h3>182) How can an object be unreferenced?</h3>

            <p>There are many ways:</p>

            <ul>
                <li>By nulling the reference</li>
                <li>By assigning a reference to another</li>
                <li>By anonymous object etc.</li>
            </ul>

            <p><img alt="Java Garbage Collection Scenario"
                    src="https://static.javatpoint.com/images/java-garbage-collection-scenario.jpg" /></p>

            <h3>1) By nulling a reference:</h3>

            <ol start="1">
                <li>Employee&nbsp;e=new&nbsp;Employee();&nbsp;&nbsp;</li>
                <li>e=null;&nbsp;&nbsp;</li>
            </ol>

            <h3>2) By assigning a reference to another:</h3>

            <ol start="1">
                <li>Employee&nbsp;e1=new&nbsp;Employee();&nbsp;&nbsp;</li>
                <li>Employee&nbsp;e2=new&nbsp;Employee();&nbsp;&nbsp;</li>
                <li>e1=e2;//now&nbsp;the&nbsp;first&nbsp;object&nbsp;referred&nbsp;by&nbsp;e1&nbsp;is&nbsp;available&nbsp;for&nbsp;garbage&nbsp;collection&nbsp;&nbsp;
                </li>
            </ol>

            <h3>3) By anonymous object:</h3>

            <ol start="1">
                <li>new&nbsp;Employee();&nbsp;&nbsp;</li>
            </ol>

            <hr />
            <h3>183) What is the purpose of the finalize() method?</h3>

            <p>The finalize() method is invoked just before the object is garbage collected. It is used to perform
                cleanup processing. The Garbage collector of JVM collects only those objects that are created by new
                keyword. So if you have created an object without new, you can use the finalize method to perform
                cleanup processing (destroying remaining objects). The cleanup processing is the process to free up all
                the resources, network which was previously used and no longer needed. It is essential to remember that
                it is not a reserved keyword, finalize method is present in the object class hence it is available in
                every class as object class is the superclass of every class in java. Here, we must note that neither
                finalization nor garbage collection is guaranteed. Consider the following example.</p>

            <ol start="1">
                <li>public&nbsp;class&nbsp;FinalizeTest&nbsp;{&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;j=12;&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;void&nbsp;add()&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;j=j+12;&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(&quot;J=&quot;+j);&nbsp;&nbsp;
                </li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;finalize()&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(&quot;Object&nbsp;is&nbsp;garbage&nbsp;collected&quot;);&nbsp;&nbsp;
                </li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;void&nbsp;main(String[]&nbsp;args)&nbsp;{&nbsp;&nbsp;
                </li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;new&nbsp;FinalizeTest().add();&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.gc();&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;new&nbsp;FinalizeTest().add();&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</li>
                <li>}&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</li>
            </ol>

            <hr />
            <h3>184) Can an unreferenced object be referenced again?</h3>

            <p>Yes,</p>

            <hr />
            <h3>185) What kind of thread is the Garbage collector thread?</h3>

            <p>Daemon thread.</p>

            <hr />
            <h3>186) What is the difference between final, finally and finalize?</h3>

            <table>
                <tbody>
                    <tr>
                        <th>No.</th>
                        <th>final</th>
                        <th>finally</th>
                        <th>finalize</th>
                    </tr>
                    <tr>
                        <td>1)</td>
                        <td>Final is used to apply restrictions on class, method, and variable. The final class
                            can&#39;t be inherited, final method can&#39;t be overridden, and final variable value
                            can&#39;t be changed.</td>
                        <td>Finally is used to place important code, it will be executed whether an exception is handled
                            or not.</td>
                        <td>Finalize is used to perform clean up processing just before an object is garbage collected.
                        </td>
                    </tr>
                    <tr>
                        <td>2)</td>
                        <td>Final is a keyword.</td>
                        <td>Finally is a block.</td>
                        <td>Finalize is a method.</td>
                    </tr>
                </tbody>
            </table>

            <hr />
            <h3>187) What is the purpose of the Runtime class?</h3>

            <p>Java Runtime class is used to interact with a java runtime environment. Java Runtime class provides
                methods to execute a process, invoke GC, get total and free memory, etc. There is only one instance of
                java.lang.Runtime class is available for one java application. The Runtime.getRuntime() method returns
                the singleton instance of Runtime class.</p>

            <hr />
            <h3>188) How will you invoke any external process in Java?</h3>

            <p>By Runtime.getRuntime().exec(?) method. Consider the following example.</p>

            <ol start="1">
                <li>public&nbsp;class&nbsp;Runtime1{&nbsp;&nbsp;</li>
                <li>&nbsp;public&nbsp;static&nbsp;void&nbsp;main(String&nbsp;args[])throws&nbsp;Exception{&nbsp;&nbsp;
                </li>
                <li>&nbsp;&nbsp;Runtime.getRuntime().exec(&quot;notepad&quot;);//will&nbsp;open&nbsp;a&nbsp;new&nbsp;notepad&nbsp;&nbsp;
                </li>
                <li>&nbsp;}&nbsp;&nbsp;</li>
                <li>}&nbsp;&nbsp;</li>
            </ol>

            <hr />
            <h2>I/O Interview Questions</h2>

            <hr />
            <h3>189) Give the hierarchy of InputStream and OutputStream classes.</h3>

            <p><strong>OutputStream Hierarchy</strong></p>

            <p><img alt="Java output stream hierarchy"
                    src="https://www.javatpoint.com/java/javaio/images/java-outputstream.png" /></p>

            <p><strong>InputStream Hierarchy</strong></p>

            <p><img alt="Java input stream hierarchy"
                    src="https://www.javatpoint.com/java/javaio/images/java-inputstream.png" /></p>

            <hr />
            <h3>190) What do you understand by an IO stream?</h3>

            <p>The stream is a sequence of data that flows from source to destination. It is composed of bytes. In Java,
                three streams are created for us automatically.</p>

            <ul>
                <li>System.out: standard output stream</li>
                <li>System.in: standard input stream</li>
                <li>System.err: standard error stream</li>
            </ul>

            <hr />
            <h3>191) What is the difference between the Reader/Writer class hierarchy and the InputStream/OutputStream
                class hierarchy?</h3>

            <p>The Reader/Writer class hierarchy is character-oriented, and the InputStream/OutputStream class hierarchy
                is byte-oriented. The ByteStream classes are used to perform input-output of 8-bit bytes whereas the
                CharacterStream classes are used to perform the input/output for the 16-bit Unicode system. There are
                many classes in the ByteStream class hierarchy, but the most frequently used classes are FileInputStream
                and FileOutputStream. The most frequently used classes CharacterStream class hierarchy is FileReader and
                FileWriter.</p>

            <hr />
            <h3>192) What are the super most classes for all the streams?</h3>

            <p>All the stream classes can be divided into two types of classes that are ByteStream classes and
                CharacterStream Classes. The ByteStream classes are further divided into InputStream classes and
                OutputStream classes. CharacterStream classes are also divided into Reader classes and Writer classes.
                The SuperMost classes for all the InputStream classes is java.io.InputStream and for all the output
                stream classes is java.io.OutPutStream. Similarly, for all the reader classes, the super-most class is
                java.io.Reader, and for all the writer classes, it is java.io.Writer.</p>

            <hr />
            <h3>193) What are the FileInputStream and FileOutputStream?</h3>

            <p><strong>Java FileOutputStream</strong>&nbsp;is an output stream used for writing data to a file. If you
                have some primitive values to write into a file, use FileOutputStream class. You can write byte-oriented
                as well as character-oriented data through the FileOutputStream class. However, for character-oriented
                data, it is preferred to use FileWriter than FileOutputStream. Consider the following example of writing
                a byte into a file.</p>

            <ol start="1">
                <li>import&nbsp;java.io.FileOutputStream;&nbsp;&nbsp;&nbsp;&nbsp;</li>
                <li>public&nbsp;class&nbsp;FileOutputStreamExample&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;void&nbsp;main(String&nbsp;args[]){&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
                </li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;try{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
                </li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;FileOutputStream&nbsp;fout=new&nbsp;FileOutputStream(&quot;D:\\testout.txt&quot;);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
                </li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fout.write(65);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
                </li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fout.close();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
                </li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(&quot;success...&quot;);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
                </li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}catch(Exception&nbsp;e){System.out.println(e);}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
                </li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</li>
                <li>}&nbsp;&nbsp;&nbsp;&nbsp;</li>
            </ol>

            <p><strong>Java FileInputStream class&nbsp;</strong>obtains input bytes from a file. It is used for reading
                byte-oriented data (streams of raw bytes) such as image data, audio, video, etc. You can also read
                character-stream data. However, for reading streams of characters, it is recommended to use FileReader
                class. Consider the following example for reading bytes from a file.</p>

            <ol start="1">
                <li>import&nbsp;java.io.FileInputStream;&nbsp;&nbsp;&nbsp;&nbsp;</li>
                <li>public&nbsp;class&nbsp;DataStreamExample&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;void&nbsp;main(String&nbsp;args[]){&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
                </li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;try{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
                </li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;FileInputStream&nbsp;fin=new&nbsp;FileInputStream(&quot;D:\\testout.txt&quot;);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
                </li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;i=fin.read();&nbsp;&nbsp;&nbsp;&nbsp;
                </li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.print((char)i);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
                </li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fin.close();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
                </li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}catch(Exception&nbsp;e){System.out.println(e);}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
                </li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;</li>
            </ol>

            <hr />
            <h3>194) What is the purpose of using BufferedInputStream and BufferedOutputStream classes?</h3>

            <p>Java BufferedOutputStream class is used for buffering an output stream. It internally uses a buffer to
                store data. It adds more efficiency than to write data directly into a stream. So, it makes the
                performance fast. Whereas, Java BufferedInputStream class is used to read information from the stream.
                It internally uses the buffer mechanism to make the performance fast.</p>

            <hr />
            <h3>195) How to set the Permissions to a file in Java?</h3>

            <p>In Java, FilePermission class is used to alter the permissions set on a file. Java FilePermission class
                contains the permission related to a directory or file. All the permissions are related to the path. The
                path can be of two types:</p>

            <ul>
                <li>D:\\IO\\-: It indicates that the permission is associated with all subdirectories and files
                    recursively.</li>
                <li>D:\\IO\\*: It indicates that the permission is associated with all directory and files within this
                    directory excluding subdirectories.</li>
            </ul>

            <p>Let&#39;s see the simple example in which permission of a directory path is granted with read permission
                and a file of this directory is granted for write permission.</p>

            <ol start="1">
                <li>package&nbsp;com.javatpoint;&nbsp;&nbsp;</li>
                <li>import&nbsp;java.io.*;&nbsp;&nbsp;</li>
                <li>import&nbsp;java.security.PermissionCollection;&nbsp;&nbsp;</li>
                <li>public&nbsp;class&nbsp;FilePermissionExample{&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;void&nbsp;main(String[]&nbsp;args)&nbsp;throws&nbsp;IOException&nbsp;{&nbsp;&nbsp;
                </li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;String&nbsp;srg&nbsp;=&nbsp;&quot;D:\\IO&nbsp;Package\\java.txt&quot;;&nbsp;&nbsp;
                </li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;FilePermission&nbsp;file1&nbsp;=&nbsp;new&nbsp;FilePermission(&quot;D:\\IO&nbsp;Package\\-&quot;,&nbsp;&quot;read&quot;);&nbsp;&nbsp;
                </li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;PermissionCollection&nbsp;permission&nbsp;=&nbsp;file1.newPermissionCollection();&nbsp;&nbsp;
                </li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;permission.add(file1);&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;FilePermission&nbsp;file2&nbsp;=&nbsp;new&nbsp;FilePermission(srg,&nbsp;&quot;write&quot;);&nbsp;&nbsp;
                </li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;permission.add(file2);&nbsp;&nbsp;
                </li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(permission.implies(new&nbsp;FilePermission(srg,&nbsp;&quot;read,write&quot;)))&nbsp;{&nbsp;&nbsp;
                </li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(&quot;Read,&nbsp;Write&nbsp;permission&nbsp;is&nbsp;granted&nbsp;for&nbsp;the&nbsp;path&nbsp;&quot;+srg&nbsp;);&nbsp;&nbsp;
                </li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}else&nbsp;{&nbsp;&nbsp;
                </li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(&quot;No&nbsp;Read,&nbsp;Write&nbsp;permission&nbsp;is&nbsp;granted&nbsp;for&nbsp;the&nbsp;path&nbsp;&quot;+srg);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;
                </li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;</li>
                <li>}&nbsp;&nbsp;</li>
            </ol>

            <p>Output</p>

            <pre>
            Read, Write permission is granted for the path D:\IO Package\java.txt
            </pre>

            <hr />
            <h3>196) What are FilterStreams?</h3>

            <p><strong>FilterStream classes</strong>&nbsp;are used to add additional functionalities to the other stream
                classes. FilterStream classes act like an interface which read the data from a stream, filters it, and
                pass the filtered data to the caller. The FilterStream classes provide extra functionalities like adding
                line numbers to the destination file, etc.</p>

            <hr />
            <h3>197) What is an I/O filter?</h3>

            <p>An I/O filter is an object that reads from one stream and writes to another, usually altering the data in
                some way as it is passed from one stream to another. Many Filter classes that allow a user to make a
                chain using multiple input streams. It generates a combined effect on several filters.</p>

            <hr />
            <h3>198) In Java, How many ways you can take input from the console?</h3>

            <p>In Java, there are three ways by using which, we can take input from the console.</p>

            <ol start="1">
                <li>import&nbsp;java.io.BufferedReader;&nbsp;&nbsp;&nbsp;</li>
                <li>import&nbsp;java.io.IOException;&nbsp;&nbsp;&nbsp;</li>
                <li>import&nbsp;java.io.InputStreamReader;&nbsp;&nbsp;&nbsp;</li>
                <li>public&nbsp;class&nbsp;Person&nbsp;&nbsp;&nbsp;</li>
                <li>{&nbsp;&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;void&nbsp;main(String[]&nbsp;args)&nbsp;throws&nbsp;IOException&nbsp;&nbsp;&nbsp;&nbsp;
                </li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(&quot;Enter&nbsp;the&nbsp;name&nbsp;of&nbsp;the&nbsp;person&quot;);&nbsp;&nbsp;
                </li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;BufferedReader&nbsp;reader&nbsp;=&nbsp;new&nbsp;BufferedReader(new&nbsp;InputStreamReader(System.in));&nbsp;&nbsp;&nbsp;
                </li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;String&nbsp;name&nbsp;=&nbsp;reader.readLine();&nbsp;&nbsp;&nbsp;
                </li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(name);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
                </li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;</li>
                <li>}&nbsp;&nbsp;&nbsp;</li>
            </ol>

            <ol start="1">
                <li>import&nbsp;java.util.*;&nbsp;&nbsp;&nbsp;&nbsp;</li>
                <li>public&nbsp;class&nbsp;ScannerClassExample2&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;void&nbsp;main(String&nbsp;args[]){&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
                </li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;String&nbsp;str&nbsp;=&nbsp;&quot;Hello/This&nbsp;is&nbsp;JavaTpoint/My&nbsp;name&nbsp;is&nbsp;Abhishek.&quot;;&nbsp;&nbsp;&nbsp;&nbsp;
                </li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//Create&nbsp;scanner&nbsp;with&nbsp;the&nbsp;specified&nbsp;String&nbsp;Object&nbsp;&nbsp;&nbsp;&nbsp;
                </li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Scanner&nbsp;scanner&nbsp;=&nbsp;new&nbsp;Scanner(str);&nbsp;&nbsp;&nbsp;&nbsp;
                </li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(&quot;Boolean&nbsp;Result:&nbsp;&quot;+scanner.hasNextBoolean());&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
                </li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//Change&nbsp;the&nbsp;delimiter&nbsp;of&nbsp;this&nbsp;scanner&nbsp;&nbsp;&nbsp;&nbsp;
                </li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;scanner.useDelimiter(&quot;/&quot;);&nbsp;&nbsp;&nbsp;&nbsp;
                </li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//Printing&nbsp;the&nbsp;tokenized&nbsp;Strings&nbsp;&nbsp;&nbsp;&nbsp;
                </li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(&quot;---Tokenizes&nbsp;String---&quot;);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
                </li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;while(scanner.hasNext()){&nbsp;&nbsp;&nbsp;&nbsp;
                </li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(scanner.next());&nbsp;&nbsp;&nbsp;&nbsp;
                </li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//Display&nbsp;the&nbsp;new&nbsp;delimiter&nbsp;&nbsp;&nbsp;&nbsp;
                </li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(&quot;Delimiter&nbsp;used:&nbsp;&quot;&nbsp;+scanner.delimiter());&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
                </li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;scanner.close();&nbsp;&nbsp;&nbsp;&nbsp;
                </li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
                </li>
                <li>}&nbsp;&nbsp;&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;</li>
            </ol>

            <ol start="1">
                <li>import&nbsp;java.io.Console;&nbsp;&nbsp;&nbsp;&nbsp;</li>
                <li>class&nbsp;ReadStringTest{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</li>
                <li>public&nbsp;static&nbsp;void&nbsp;main(String&nbsp;args[]){&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</li>
                <li>Console&nbsp;c=System.console();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</li>
                <li>System.out.println(&quot;Enter&nbsp;your&nbsp;name:&nbsp;&quot;);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
                </li>
                <li>String&nbsp;n=c.readLine();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</li>
                <li>System.out.println(&quot;Welcome&nbsp;&quot;+n);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</li>
                <li>}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</li>
                <li>}&nbsp;&nbsp;&nbsp;&nbsp;</li>
            </ol>

            <ul>
                <li><strong>Using BufferedReader class:</strong>&nbsp;we can take input from the console by wrapping
                    System.in into an InputStreamReader and passing it into the BufferedReader. It provides an efficient
                    reading as the input gets buffered. Consider the following example.</li>
                <li><strong>Using Scanner class:</strong>&nbsp;The Java Scanner class breaks the input into tokens using
                    a delimiter that is whitespace by default. It provides many methods to read and parse various
                    primitive values. Java Scanner class is widely used to parse text for string and primitive types
                    using a regular expression. Java Scanner class extends Object class and implements Iterator and
                    Closeable interfaces. Consider the following example.</li>
                <li><strong>Using Console class:</strong>&nbsp;The Java Console class is used to get input from the
                    console. It provides methods to read texts and passwords. If you read the password using the Console
                    class, it will not be displayed to the user. The java.io.Console class is attached to the system
                    console internally. The Console class is introduced since 1.5. Consider the following example.</li>
            </ul>

            <hr />
            <h2>Serialization Interview Questions</h2>

            <hr />
            <h3>199) What is serialization?</h3>

            <p>Serialization in Java is a mechanism of writing the state of an object into a byte stream. It is used
                primarily in Hibernate, RMI, JPA, EJB and JMS technologies. It is mainly used to travel object&#39;s
                state on the network (which is known as marshaling). Serializable interface is used to perform
                serialization. It is helpful when you require to save the state of a program to storage such as the
                file. At a later point of time, the content of this file can be restored using deserialization. It is
                also required to implement RMI(Remote Method Invocation). With the help of RMI, it is possible to invoke
                the method of a Java object on one machine to another machine.</p>

            <p><img alt="java serialization"
                    src="https://static.javatpoint.com/images/core/java-serialization.png" />&nbsp;<a
                    href="https://www.javatpoint.com/serialization">More details.</a></p>

            <hr />
            <h3>200) How can you make a class serializable in Java?</h3>

            <p>A class can become serializable by implementing the Serializable interface.</p>

            <hr />
            <h3>201) How can you avoid serialization in child class if the base class is implementing the Serializable
                interface?</h3>

            <p>It is very tricky to prevent serialization of child class if the base class is intended to implement the
                Serializable interface. However, we cannot do it directly, but the serialization can be avoided by
                implementing the writeObject() or readObject() methods in the subclass and throw
                NotSerializableException from these methods. Consider the following example.</p>

            <ol start="1">
                <li>import&nbsp;java.io.FileInputStream;&nbsp;&nbsp;&nbsp;</li>
                <li>import&nbsp;java.io.FileOutputStream;&nbsp;&nbsp;&nbsp;</li>
                <li>import&nbsp;java.io.IOException;&nbsp;&nbsp;&nbsp;</li>
                <li>import&nbsp;java.io.NotSerializableException;&nbsp;&nbsp;&nbsp;</li>
                <li>import&nbsp;java.io.ObjectInputStream;&nbsp;&nbsp;&nbsp;</li>
                <li>import&nbsp;java.io.ObjectOutputStream;&nbsp;&nbsp;&nbsp;</li>
                <li>import&nbsp;java.io.Serializable;&nbsp;&nbsp;&nbsp;</li>
                <li>class&nbsp;Person&nbsp;implements&nbsp;Serializable&nbsp;&nbsp;&nbsp;</li>
                <li>{&nbsp;&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;String&nbsp;name&nbsp;=&nbsp;&quot;&nbsp;&quot;;&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;Person(String&nbsp;name)&nbsp;&nbsp;&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.name&nbsp;=&nbsp;name;&nbsp;&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</li>
                <li>}&nbsp;&nbsp;&nbsp;</li>
                <li>class&nbsp;Employee&nbsp;extends&nbsp;Person&nbsp;&nbsp;</li>
                <li>{&nbsp;&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;float&nbsp;salary;&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;Employee(String&nbsp;name,&nbsp;float&nbsp;salary)&nbsp;&nbsp;&nbsp;&nbsp;
                </li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;super(name);&nbsp;&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.salary&nbsp;=&nbsp;salary;&nbsp;&nbsp;&nbsp;
                </li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;private&nbsp;void&nbsp;writeObject(ObjectOutputStream&nbsp;out)&nbsp;throws&nbsp;IOException&nbsp;&nbsp;&nbsp;
                </li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;throw&nbsp;new&nbsp;NotSerializableException();&nbsp;&nbsp;&nbsp;
                </li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;private&nbsp;void&nbsp;readObject(ObjectInputStream&nbsp;in)&nbsp;throws&nbsp;IOException&nbsp;&nbsp;&nbsp;
                </li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;throw&nbsp;new&nbsp;NotSerializableException();&nbsp;&nbsp;&nbsp;
                </li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</li>
                <li>}&nbsp;&nbsp;&nbsp;</li>
                <li>public&nbsp;class&nbsp;Test&nbsp;&nbsp;&nbsp;</li>
                <li>{&nbsp;&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;void&nbsp;main(String[]&nbsp;args)&nbsp;&nbsp;&nbsp;&nbsp;
                </li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;throws&nbsp;Exception&nbsp;&nbsp;&nbsp;&nbsp;
                </li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Employee&nbsp;emp&nbsp;=&nbsp;new&nbsp;Employee(&quot;Sharma&quot;,&nbsp;10000);&nbsp;&nbsp;&nbsp;
                </li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(&quot;name&nbsp;=&nbsp;&quot;&nbsp;+&nbsp;emp.name);&nbsp;&nbsp;&nbsp;
                </li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(&quot;salary&nbsp;=&nbsp;&quot;&nbsp;+&nbsp;emp.salary);&nbsp;&nbsp;&nbsp;
                </li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;FileOutputStream&nbsp;fos&nbsp;=&nbsp;new&nbsp;FileOutputStream(&quot;abc.ser&quot;);&nbsp;&nbsp;&nbsp;
                </li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ObjectOutputStream&nbsp;oos&nbsp;=&nbsp;new&nbsp;ObjectOutputStream(fos);&nbsp;&nbsp;&nbsp;
                </li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
                </li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;oos.writeObject(emp);&nbsp;&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
                </li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;oos.close();&nbsp;&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fos.close();&nbsp;&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
                </li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(&quot;Object&nbsp;has&nbsp;been&nbsp;serialized&quot;);&nbsp;&nbsp;&nbsp;
                </li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;FileInputStream&nbsp;f&nbsp;=&nbsp;new&nbsp;FileInputStream(&quot;ab.txt&quot;);&nbsp;&nbsp;&nbsp;
                </li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ObjectInputStream&nbsp;o&nbsp;=&nbsp;new&nbsp;ObjectInputStream(f);&nbsp;&nbsp;&nbsp;
                </li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
                </li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Employee&nbsp;emp1&nbsp;=&nbsp;(Employee)o.readObject();&nbsp;&nbsp;&nbsp;
                </li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
                </li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;o.close();&nbsp;&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;f.close();&nbsp;&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
                </li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(&quot;Object&nbsp;has&nbsp;been&nbsp;deserialized&quot;);&nbsp;&nbsp;&nbsp;
                </li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(&quot;name&nbsp;=&nbsp;&quot;&nbsp;+&nbsp;emp1.name);&nbsp;&nbsp;&nbsp;
                </li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(&quot;salary&nbsp;=&nbsp;&quot;&nbsp;+&nbsp;emp1.salary);&nbsp;&nbsp;&nbsp;
                </li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;</li>
                <li>}&nbsp;&nbsp;&nbsp;</li>
            </ol>

            <hr />
            <h3>202) Can a Serialized object be transferred via network?</h3>

            <p>Yes, we can transfer a serialized object via network because the serialized object is stored in the
                memory in the form of bytes and can be transmitted over the network. We can also write the serialized
                object to the disk or the database.</p>

            <hr />
            <h3>203) What is Deserialization?</h3>

            <p>Deserialization is the process of reconstructing the object from the serialized state. It is the reverse
                operation of serialization. An ObjectInputStream deserializes objects and primitive data written using
                an ObjectOutputStream.</p>

            <ol start="1">
                <li>import&nbsp;java.io.*;&nbsp;&nbsp;</li>
                <li>class&nbsp;Depersist{&nbsp;&nbsp;</li>
                <li>&nbsp;public&nbsp;static&nbsp;void&nbsp;main(String&nbsp;args[])throws&nbsp;Exception{&nbsp;&nbsp;
                </li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;ObjectInputStream&nbsp;in=new&nbsp;ObjectInputStream(new&nbsp;FileInputStream(&quot;f.txt&quot;));&nbsp;&nbsp;
                </li>
                <li>&nbsp;&nbsp;Student&nbsp;s=(Student)in.readObject();&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;System.out.println(s.id+&quot;&nbsp;&quot;+s.name);&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;in.close();&nbsp;&nbsp;</li>
                <li>&nbsp;}&nbsp;&nbsp;</li>
                <li>}&nbsp;&nbsp;</li>
            </ol>

            <pre>
            211 ravi
            </pre>

            <hr />
            <h3>204) What is the transient keyword?</h3>

            <p>If you define any data member as transient, it will not be serialized. By determining transient keyword,
                the value of variable need not persist when it is restored.&nbsp;<a
                    href="https://www.javatpoint.com/serialization">More details.</a></p>

            <hr />
            <h3>205) What is Externalizable?</h3>

            <p>The Externalizable interface is used to write the state of an object into a byte stream in a compressed
                format. It is not a marker interface.</p>

            <hr />
            <h3>206) What is the difference between Serializable and Externalizable interface?</h3>

            <p>&nbsp;</p>

            <table>
                <tbody>
                    <tr>
                        <th>No.</th>
                        <th>Serializable</th>
                        <th>Externalizable</th>
                    </tr>
                    <tr>
                        <td>1)</td>
                        <td>The Serializable interface does not have any method, i.e., it is a marker interface.</td>
                        <td>The Externalizable interface contains is not a marker interface, It contains two methods,
                            i.e., writeExternal() and readExternal().</td>
                    </tr>
                    <tr>
                        <td>2)</td>
                        <td>It is used to &quot;mark&quot; Java classes so that objects of these classes may get the
                            certain capability.</td>
                        <td>The Externalizable interface provides control of the serialization logic to the programmer.
                        </td>
                    </tr>
                    <tr>
                        <td>3)</td>
                        <td>It is easy to implement but has the higher performance cost.</td>
                        <td>It is used to perform the serialization and often result in better performance.</td>
                    </tr>
                    <tr>
                        <td>4)</td>
                        <td>No class constructor is called in serialization.</td>
                        <td>We must call a public default constructor while using this interface.</td>
                    </tr>
                </tbody>
            </table>

            <p>.</p>

            <p>&nbsp;</p>

            <hr />
            <h2>Networking Interview Questions</h2>

            <hr />
            <h3>207) Give a brief description of Java socket programming?</h3>

            <p>Java Socket programming is used for communication between the applications running on different JRE. Java
                Socket programming can be connection-oriented or connectionless. Socket and ServerSocket classes are
                used for connection-oriented socket programming and DatagramSocket, and DatagramPacket classes are used
                for connectionless socket programming. The client in socket programming must know two information:</p>

            <ul>
                <li>IP address of the server</li>
                <li>port number</li>
            </ul>

            <hr />
            <h3>208) What is Socket?</h3>

            <p>A socket is simply an endpoint for communications between the machines. It provides the connection
                mechanism to connect the two computers using TCP. The Socket class can be used to create a socket.</p>

            <hr />
            <h3>209) What are the steps that are followed when two computers connect through TCP?</h3>

            <p>There are the following steps that are performed when two computers connect through TCP.</p>

            <ul>
                <li>The ServerSocket object is instantiated by the server which denotes the port number to which, the
                    connection will be made.</li>
                <li>After instantiating the ServerSocket object, the server invokes accept() method of ServerSocket
                    class which makes server wait until the client attempts to connect to the server on the given port.
                </li>
                <li>Meanwhile, the server is waiting, a socket is created by the client by instantiating Socket class.
                    The socket class constructor accepts the server port number and server name.</li>
                <li>The Socket class constructor attempts to connect with the server on the specified name. If the
                    connection is established, the client will have a socket object that can communicate with the
                    server.</li>
                <li>The accept() method invoked by the server returns a reference to the new socket on the server that
                    is connected with the server.</li>
            </ul>

            <hr />
            <h3>210) Write a program in Java to establish a connection between client and server?</h3>

            <p>Consider the following program where the connection between the client and server is established.</p>

            <p>File: MyServer.java</p>

            <ol start="1">
                <li>import&nbsp;java.io.*;&nbsp;&nbsp;</li>
                <li>import&nbsp;java.net.*;&nbsp;&nbsp;</li>
                <li>public&nbsp;class&nbsp;MyServer&nbsp;{&nbsp;&nbsp;</li>
                <li>public&nbsp;static&nbsp;void&nbsp;main(String[]&nbsp;args){&nbsp;&nbsp;</li>
                <li>try{&nbsp;&nbsp;</li>
                <li>ServerSocket&nbsp;ss=new&nbsp;ServerSocket(6666);&nbsp;&nbsp;</li>
                <li>Socket&nbsp;s=ss.accept();//establishes&nbsp;connection&nbsp;&nbsp;&nbsp;</li>
                <li>DataInputStream&nbsp;dis=new&nbsp;DataInputStream(s.getInputStream());&nbsp;&nbsp;</li>
                <li>String&nbsp;&nbsp;str=(String)dis.readUTF();&nbsp;&nbsp;</li>
                <li>System.out.println(&quot;message=&nbsp;&quot;+str);&nbsp;&nbsp;</li>
                <li>ss.close();&nbsp;&nbsp;</li>
                <li>}catch(Exception&nbsp;e){System.out.println(e);}&nbsp;&nbsp;</li>
                <li>}&nbsp;&nbsp;</li>
                <li>}&nbsp;&nbsp;</li>
            </ol>

            <p>File: MyClient.java</p>

            <ol start="1">
                <li>import&nbsp;java.io.*;&nbsp;&nbsp;</li>
                <li>import&nbsp;java.net.*;&nbsp;&nbsp;</li>
                <li>public&nbsp;class&nbsp;MyClient&nbsp;{&nbsp;&nbsp;</li>
                <li>public&nbsp;static&nbsp;void&nbsp;main(String[]&nbsp;args)&nbsp;{&nbsp;&nbsp;</li>
                <li>try{&nbsp;&nbsp;&nbsp;&nbsp;</li>
                <li>Socket&nbsp;s=new&nbsp;Socket(&quot;localhost&quot;,6666);&nbsp;&nbsp;</li>
                <li>DataOutputStream&nbsp;dout=new&nbsp;DataOutputStream(s.getOutputStream());&nbsp;&nbsp;</li>
                <li>dout.writeUTF(&quot;Hello&nbsp;Server&quot;);&nbsp;&nbsp;</li>
                <li>dout.flush();&nbsp;&nbsp;</li>
                <li>dout.close();&nbsp;&nbsp;</li>
                <li>s.close();&nbsp;&nbsp;</li>
                <li>}catch(Exception&nbsp;e){System.out.println(e);}&nbsp;&nbsp;</li>
                <li>}&nbsp;&nbsp;</li>
                <li>}&nbsp;&nbsp;</li>
            </ol>

            <hr />
            <h3>211) How do I convert a numeric IP address like 192.18.97.39 into a hostname like java.sun.com?</h3>

            <p>By InetAddress.getByName(&quot;192.18.97.39&quot;).getHostName() where 192.18.97.39 is the IP address.
                Consider the following example.</p>

            <ol start="1">
                <li>import&nbsp;java.io.*;&nbsp;&nbsp;&nbsp;&nbsp;</li>
                <li>import&nbsp;java.net.*;&nbsp;&nbsp;&nbsp;&nbsp;</li>
                <li>public&nbsp;class&nbsp;InetDemo{&nbsp;&nbsp;&nbsp;&nbsp;</li>
                <li>public&nbsp;static&nbsp;void&nbsp;main(String[]&nbsp;args){&nbsp;&nbsp;&nbsp;&nbsp;</li>
                <li>try{&nbsp;&nbsp;&nbsp;&nbsp;</li>
                <li>InetAddress&nbsp;ip=InetAddress.getByName(&quot;195.201.10.8&quot;);&nbsp;&nbsp;&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;</li>
                <li>System.out.println(&quot;Host&nbsp;Name:&nbsp;&quot;+ip.getHostName());&nbsp;&nbsp;&nbsp;&nbsp;</li>
                <li>}catch(Exception&nbsp;e){System.out.println(e);}&nbsp;&nbsp;&nbsp;&nbsp;</li>
                <li>}&nbsp;&nbsp;&nbsp;&nbsp;</li>
                <li>}&nbsp;&nbsp;&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</li>
            </ol>

            <hr />
            <h2>Reflection Interview Questions</h2>

            <hr />
            <h3>212) What is the reflection?</h3>

            <p>Reflection is the process of examining or modifying the runtime behavior of a class at runtime. The
                java.lang.Class class provides various methods that can be used to get metadata, examine and change the
                runtime behavior of a class. The java.lang and java.lang.reflect packages provide classes for java
                reflection. It is used in:</p>

            <ul>
                <li>IDE (Integrated Development Environment), e.g., Eclipse, MyEclipse, NetBeans.</li>
                <li>Debugger</li>
                <li>Test Tools, etc.</li>
            </ul>

            <hr />
            <h3>213) What is the purpose of using java.lang.Class class?</h3>

            <p>The java.lang.Class class performs mainly two tasks:</p>

            <ul>
                <li>Provides methods to get the metadata of a class at runtime.</li>
                <li>Provides methods to examine and change the runtime behavior of a class.</li>
            </ul>

            <hr />
            <h3>214) What are the ways to instantiate the Class class?</h3>

            <p>There are three ways to instantiate the Class class.</p>

            <ul>
                <li><strong>forName() method of Class class:&nbsp;</strong>The forName() method is used to load the
                    class dynamically. It returns the instance of Class class. It should be used if you know the fully
                    qualified name of the class. This cannot be used for primitive types.</li>
                <br />
                <li><strong>getClass() method of Object class:</strong>&nbsp;It returns the instance of Class class. It
                    should be used if you know the type. Moreover, it can be used with primitives.</li>
                <br />
                <li><strong>the .class syntax:</strong>&nbsp;If a type is available, but there is no instance then it is
                    possible to obtain a Class by appending &quot;.class&quot; to the name of the type. It can be used
                    for primitive data type also.</li>
                <br />
                <br />
                <br />
                &nbsp;
                <li>&nbsp;</li>
            </ul>

            <hr />
            <h3>215) What is the output of the following Java program?</h3>

            <ol start="1">
                <li>class&nbsp;Simple{&nbsp;&nbsp;&nbsp;&nbsp;</li>
                <li>&nbsp;public&nbsp;Simple()&nbsp;&nbsp;</li>
                <li>&nbsp;{&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;System.out.println(&quot;Constructor&nbsp;of&nbsp;Simple&nbsp;class&nbsp;is&nbsp;invoked&quot;);&nbsp;&nbsp;
                </li>
                <li>&nbsp;}&nbsp;&nbsp;</li>
                <li>&nbsp;void&nbsp;message(){System.out.println(&quot;Hello&nbsp;Java&quot;);}&nbsp;&nbsp;&nbsp;&nbsp;
                </li>
                <li>}&nbsp;&nbsp;&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;</li>
                <li>class&nbsp;Test1{&nbsp;&nbsp;&nbsp;&nbsp;</li>
                <li>&nbsp;public&nbsp;static&nbsp;void&nbsp;main(String&nbsp;args[]){&nbsp;&nbsp;&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;try{&nbsp;&nbsp;&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;Class&nbsp;c=Class.forName(&quot;Simple&quot;);&nbsp;&nbsp;&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;Simple&nbsp;s=(Simple)c.newInstance();&nbsp;&nbsp;&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;s.message();&nbsp;&nbsp;&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;}catch(Exception&nbsp;e){System.out.println(e);}&nbsp;&nbsp;&nbsp;&nbsp;</li>
                <li>&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;</li>
                <li>}&nbsp;&nbsp;&nbsp;&nbsp;</li>
            </ol>

            <p><strong>Output</strong></p>

            <pre>
            Constructor of Simple class is invoked
            Hello Java
            </pre>

            <p><strong>Explanation</strong></p>

            <p>The newInstance() method of the Class class is used to invoke the constructor at runtime. In this
                program, the instance of the Simple class is created.</p>

            <hr />
            <h3>216) What is the purpose of using javap?</h3>

            <p>The javap command disassembles a class file. The javap command displays information about the fields,
                constructors and methods present in a class file.</p>

            <p><strong>Syntax</strong></p>

            <p>javap fully_class_name</p>

            <hr />
            <h3>217) Can you access the private method from outside the class?</h3>

            <p>Yes, by changing the runtime behavior of a class if the class is not secured.</p>

            <p><a href="https://www.javatpoint.com/reflection6">More details.</a></p>

            <hr />
            <h2>Miscellaneous Interview Questions</h2>

            <hr />
            <h3>218)What are wrapper classes?</h3>

            <p>Wrapper classes are classes that allow primitive types to be accessed as objects. In other words, we can
                say that wrapper classes are built-in java classes which allow the conversion of objects to primitives
                and primitives to objects. The process of converting primitives to objects is called autoboxing, and the
                process of converting objects to primitives is called unboxing. There are eight wrapper classes present
                in&nbsp;<strong>java.lang</strong>&nbsp;package is given below.</p>

            <table>
                <tbody>
                    <tr>
                        <th>Primitive Type</th>
                        <th>Wrapper class</th>
                    </tr>
                    <tr>
                        <td>boolean</td>
                        <td>Boolean</td>
                    </tr>
                    <tr>
                        <td>char</td>
                        <td>Character</td>
                    </tr>
                    <tr>
                        <td>byte</td>
                        <td>Byte</td>
                    </tr>
                    <tr>
                        <td>short</td>
                        <td>Short</td>
                    </tr>
                    <tr>
                        <td>int</td>
                        <td>Integer</td>
                    </tr>
                    <tr>
                        <td>long</td>
                        <td>Long</td>
                    </tr>
                    <tr>
                        <td>float</td>
                        <td>Float</td>
                    </tr>
                    <tr>
                        <td>double</td>
                        <td>Double</td>
                    </tr>
                </tbody>
            </table>

            <hr />
            <h3>219)What are autoboxing and unboxing? When does it occur?</h3>

            <p>The autoboxing is the process of converting primitive data type to the corresponding wrapper class
                object, eg., int to Integer. The unboxing is the process of converting wrapper class object to primitive
                data type. For eg., integer to int. Unboxing and autoboxing occur automatically in Java. However, we can
                externally convert one into another by using the methods like valueOf() or xxxValue().</p>

            <p>It can occur whenever a wrapper class object is expected, and primitive data type is provided or vice
                versa.</p>

            <ul>
                <li>Adding primitive types into Collection like ArrayList in Java.</li>
                <li>Creating an instance of parameterized classes ,e.g., ThreadLocal which expect Type.</li>
                <li>Java automatically converts primitive to object whenever one is required and another is provided in
                    the method calling.</li>
                <li>When a primitive type is assigned to an object type.</li>
            </ul>

            <hr />
            <h3>220) What is the output of the below Java program?</h3>

            <ol start="1">
                <li>public&nbsp;class&nbsp;Test1&nbsp;&nbsp;</li>
                <li>{&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;public&nbsp;static&nbsp;void&nbsp;main(String[]&nbsp;args)&nbsp;{&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;Integer&nbsp;i&nbsp;=&nbsp;new&nbsp;Integer(201);&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;Integer&nbsp;j&nbsp;=&nbsp;new&nbsp;Integer(201);&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;if(i&nbsp;==&nbsp;j)&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;{&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(&quot;hello&quot;);&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;}&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;else&nbsp;&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;{&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(&quot;bye&quot;);&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;}&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;}&nbsp;&nbsp;</li>
                <li>}&nbsp;&nbsp;</li>
            </ol>

            <p><strong>Output</strong></p>

            <pre>
            bye
            </pre>

            <p><strong>Explanation</strong></p>

            <p>The Integer class caches integer values from -127 to 127. Therefore, the Integer objects can only be
                created in the range -128 to 127. The operator&nbsp;<strong>==</strong>&nbsp;will not work for the value
                greater than 127; thus&nbsp;<strong>bye</strong>&nbsp;is printed.</p>

            <hr />
            <h3>221) What is object cloning?</h3>

            <p>The object cloning is a way to create an exact copy of an object. The clone() method of the Object class
                is used to clone an object. The java.lang.Cloneable interface must be implemented by the class whose
                object clone we want to create. If we don&#39;t implement Cloneable interface, clone() method generates
                CloneNotSupportedException. The clone() method is defined in the Object class. The syntax of the clone()
                method is as follows:</p>

            <p><strong>protected Object clone() throws CloneNotSupportedException</strong></p>

            <hr />
            <h3>222) What are the advantages and disadvantages of object cloning?</h3>

            <p><strong>Advantage of Object Cloning</strong></p>

            <ul>
                <li>You don&#39;t need to write lengthy and repetitive codes. Just use an abstract class with a 4- or
                    5-line long clone() method.</li>
                <li>It is the easiest and most efficient way of copying objects, especially if we are applying it to an
                    already developed or an old project. Just define a parent class, implement Cloneable in it, provide
                    the definition of the clone() method and the task will be done.</li>
                <li>Clone() is the fastest way to copy the array.</li>
            </ul>

            <p><strong>Disadvantage of Object Cloning</strong></p>

            <ul>
                <li>To use the Object.clone() method, we have to change many syntaxes to our code, like implementing a
                    Cloneable interface, defining the clone() method and handling CloneNotSupportedException, and
                    finally, calling Object.clone(), etc.</li>
                <li>We have to implement the Cloneable interface while it does not have any methods in it. We have to
                    use it to tell the JVM that we can perform a clone() on our object.</li>
                <li>Object.clone() is protected, so we have to provide our own clone() and indirectly call
                    Object.clone() from it.</li>
                <li>Object.clone() does not invoke any constructor, so we do not have any control over object
                    construction.</li>
                <li>If you want to write a clone method in a child class, then all of its superclasses should define the
                    clone() method in them or inherit it from another parent class. Otherwise, the super.clone() chain
                    will fail.</li>
                <li>Object.clone() supports only shallow copying, but we will need to override it if we need deep
                    cloning.</li>
            </ul>

            <hr />
            <h3>223) What is a native method?</h3>

            <p>A native method is a method that is implemented in a language other than Java. Natives methods are
                sometimes also referred to as foreign methods.</p>

            <hr />
            <h3>224) What is the purpose of the strictfp keyword?</h3>

            <p>Java strictfp keyword ensures that you will get the same result on every platform if you perform
                operations in the floating-point variable. The precision may differ from platform to platform that is
                why java programming language has provided the strictfp keyword so that you get the same result on every
                platform. So, now you have better control over the floating-point arithmetic.</p>

            <hr />
            <h3>225) What is the purpose of the System class?</h3>

            <p>The purpose of the System class is to provide access to system resources such as standard input and
                output. It cannot be instantiated. Facilities provided by System class are given below.</p>

            <ul>
                <li>Standard input</li>
                <li>Error output streams</li>
                <li>Standard output</li>
                <li>utility method to copy the portion of an array</li>
                <li>utilities to load files and libraries</li>
            </ul>

            <p>There are the three fields of Java System class, i.e., static printstream err, static inputstream in, and
                standard output stream.</p>

            <hr />
            <h3>226) What comes to mind when someone mentions a shallow copy in Java?</h3>

            <p>Object cloning.</p>

            <hr />
            <h3>227) What is a singleton class?</h3>

            <p>Singleton class is the class which can not be instantiated more than once. To make a class singleton, we
                either make its constructor private or use the static getInstance method. Consider the following
                example.</p>

            <ol start="1">
                <li>class&nbsp;Singleton{&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;private&nbsp;static&nbsp;Singleton&nbsp;single_instance&nbsp;=&nbsp;null;&nbsp;&nbsp;
                </li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;i;&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;private&nbsp;Singleton&nbsp;()&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;i=90;&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;Singleton&nbsp;getInstance()&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(single_instance&nbsp;==&nbsp;null)&nbsp;&nbsp;
                </li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;single_instance&nbsp;=&nbsp;new&nbsp;Singleton();&nbsp;&nbsp;
                </li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;single_instance;&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</li>
                <li>}&nbsp;&nbsp;</li>
                <li>public&nbsp;class&nbsp;Main&nbsp;&nbsp;&nbsp;</li>
                <li>{&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;void&nbsp;main&nbsp;(String&nbsp;args[])&nbsp;&nbsp;
                </li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Singleton&nbsp;first&nbsp;=&nbsp;Singleton.getInstance();&nbsp;&nbsp;
                </li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(&quot;First&nbsp;instance&nbsp;integer&nbsp;value:&quot;+first.i);&nbsp;&nbsp;
                </li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;first.i=first.i+90;&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Singleton&nbsp;second&nbsp;=&nbsp;Singleton.getInstance();&nbsp;&nbsp;
                </li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(&quot;Second&nbsp;instance&nbsp;integer&nbsp;value:&quot;+second.i);&nbsp;&nbsp;
                </li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</li>
                <li>}&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</li>
            </ol>

            <hr />
            <h3>228) Write a Java program that prints all the values given at command-line.</h3>

            <p><strong>Program</strong></p>

            <ol start="1">
                <li>class&nbsp;A{&nbsp;&nbsp;</li>
                <li>public&nbsp;static&nbsp;void&nbsp;main(String&nbsp;args[]){&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;</li>
                <li>for(int&nbsp;i=0;i&lt;args.length;i++)&nbsp;&nbsp;</li>
                <li>System.out.println(args[i]);&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;</li>
                <li>}&nbsp;&nbsp;</li>
                <li>}&nbsp;&nbsp;</li>
            </ol>

            <ol start="1">
                <li>compile&nbsp;by&nbsp;&gt;&nbsp;javac&nbsp;A.java&nbsp;&nbsp;</li>
                <li>run&nbsp;by&nbsp;&gt;&nbsp;java&nbsp;A&nbsp;sonoo&nbsp;jaiswal&nbsp;1&nbsp;3&nbsp;abc&nbsp;&nbsp;
                </li>
            </ol>

            <p><strong>Output</strong></p>

            <pre>
            sonoo
            jaiswal
            1
            3
            abc      
            </pre>

            <hr />
            <h3>229) Which containers use a border layout as their default layout?</h3>

            <p>The Window, Frame and Dialog classes use a border layout as their default layout.</p>

            <hr />
            <h3>230) Which containers use a FlowLayout as their default layout?</h3>

            <p>The Panel and Applet classes use the FlowLayout as their default layout.</p>

            <hr />
            <h3>231) What are peerless components?</h3>

            <p>The lightweight component of Swing is called peerless components. Spring has its libraries, so it does
                not use resources from the Operating System, and hence it has lightweight components.</p>

            <hr />
            <h3>232) is there is any difference between a Scrollbar and a ScrollPane?</h3>

            <p>The Scrollbar is a Component whereas the ScrollPane is a Container. A ScrollPane handles its events and
                performs its scrolling.</p>

            <hr />
            <h3>233) What is a lightweight component?</h3>

            <p>Lightweight components are the one which does not go with the native call to obtain the graphical units.
                They share their parent component graphical units to render them. For example, Swing components, and
                JavaFX Components.</p>

            <hr />
            <h3>234) What is a heavyweight component?</h3>

            <p>The portable elements provided by the operating system are called heavyweight components. AWT is limited
                to the graphical classes provided by the operating system and therefore, It implements only the minimal
                subset of screen elements supported by all platforms. The Operating system dependent UI discovery tools
                are called heavyweight components.</p>

            <hr />
            <h3>235) What is an applet?</h3>

            <p>An applet is a small java program that runs inside the browser and generates dynamic content. It is
                embedded in the webpage and runs on the client side. It is secured and takes less response time. It can
                be executed by browsers running under many platforms, including Linux, Windows, Mac Os, etc. However,
                the plugins are required at the client browser to execute the applet. The following image shows the
                architecture of Applet.</p>

            <p><img alt="hierarchy of applet" src="https://static.javatpoint.com/images/applethierarchy.jpg" /></p>

            <p>When an applet is created, the following methods are invoked in order.</p>

            <ul>
                <li>init()</li>
                <li>start()</li>
                <li>paint()</li>
            </ul>

            <p>When an applet is destroyed, the following functions are invoked in order.</p>

            <ul>
                <li>stop()</li>
                <li>destroy()</li>
            </ul>

            <hr />
            <h3>236) Can you write a Java class that could be used both as an applet as well as an application?</h3>

            <p>Yes. Add a main() method to the applet.</p>

            <hr />
            <h2>Internationalization Interview Questions</h2>

            <hr />
            <h3>237) What is Locale?</h3>

            <p>A Locale object represents a specific geographical, political, or cultural region. This object can be
                used to get the locale-specific information such as country name, language, variant, etc.</p>

            <ol start="1">
                <li>import&nbsp;java.util.*;&nbsp;&nbsp;</li>
                <li>public&nbsp;class&nbsp;LocaleExample&nbsp;{&nbsp;&nbsp;</li>
                <li>public&nbsp;static&nbsp;void&nbsp;main(String[]&nbsp;args)&nbsp;{&nbsp;&nbsp;</li>
                <li>Locale&nbsp;locale=Locale.getDefault();&nbsp;&nbsp;</li>
                <li>//Locale&nbsp;locale=new&nbsp;Locale(&quot;fr&quot;,&quot;fr&quot;);//for&nbsp;the&nbsp;specific&nbsp;locale&nbsp;&nbsp;
                </li>
                <li>&nbsp;&nbsp;</li>
                <li>System.out.println(locale.getDisplayCountry());&nbsp;&nbsp;</li>
                <li>System.out.println(locale.getDisplayLanguage());&nbsp;&nbsp;</li>
                <li>System.out.println(locale.getDisplayName());&nbsp;&nbsp;</li>
                <li>System.out.println(locale.getISO3Country());&nbsp;&nbsp;</li>
                <li>System.out.println(locale.getISO3Language());&nbsp;&nbsp;</li>
                <li>System.out.println(locale.getLanguage());&nbsp;&nbsp;</li>
                <li>System.out.println(locale.getCountry());&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</li>
                <li>}&nbsp;&nbsp;</li>
                <li>}&nbsp;&nbsp;</li>
            </ol>

            <p><strong>Output:</strong></p>

            <pre>
            United States
            English
            English (United States)
            USA
            eng
            en
            US
            </pre>

            <hr />
            <h3>238)How will you load a specific locale?</h3>

            <p>By ResourceBundle.getBundle(?) method.</p>

            <hr />
            <h2>Java Bean Interview Questions</h2>

            <hr />
            <h3>239) What is a JavaBean?</h3>

            <p>JavaBean is a reusable software component written in the Java programming language, designed to be
                manipulated visually by a software development environment, like JBuilder or VisualAge for Java. t. A
                JavaBean encapsulates many objects into one object so that we can access this object from multiple
                places. Moreover, it provides the easy maintenance. Consider the following example to create a JavaBean
                class.</p>

            <ol start="1">
                <li>//Employee.java&nbsp;&nbsp;</li>
                <li>package&nbsp;mypack;&nbsp;&nbsp;</li>
                <li>public&nbsp;class&nbsp;Employee&nbsp;implements&nbsp;java.io.Serializable{&nbsp;&nbsp;</li>
                <li>private&nbsp;int&nbsp;id;&nbsp;&nbsp;</li>
                <li>private&nbsp;String&nbsp;name;&nbsp;&nbsp;</li>
                <li>public&nbsp;Employee(){}&nbsp;&nbsp;</li>
                <li>public&nbsp;void&nbsp;setId(int&nbsp;id){this.id=id;}&nbsp;&nbsp;</li>
                <li>public&nbsp;int&nbsp;getId(){return&nbsp;id;}&nbsp;&nbsp;</li>
                <li>public&nbsp;void&nbsp;setName(String&nbsp;name){this.name=name;}&nbsp;&nbsp;</li>
                <li>public&nbsp;String&nbsp;getName(){return&nbsp;name;}&nbsp;&nbsp;</li>
                <li>}&nbsp;&nbsp;</li>
            </ol>

            <hr />
            <h3>240) What is the purpose of using the Java bean?</h3>

            <p>According to Java white paper, it is a reusable software component. A bean encapsulates many objects into
                one object so that we can access this object from multiple places. Moreover, it provides the easy
                maintenance.</p>

            <hr />
            <h3>241) What do you understand by the bean persistent property?</h3>

            <p>The persistence property of Java bean comes into the act when the properties, fields, and state
                information are saved to or retrieve from the storage.</p>

            <hr />
            <h2>RMI Interview Questions</h2>

            <hr />
            <h3>242) What is RMI?</h3>

            <p>The RMI (Remote Method Invocation) is an API that provides a mechanism to create the distributed
                application in java. The RMI allows an object to invoke methods on an object running in another JVM. The
                RMI provides remote communication between the applications using two objects stub and skeleton.</p>

            <hr />
            <h3>243) What is the purpose of stub and skeleton?</h3>

            <p><strong>Stub</strong></p>

            <p>The stub is an object, acts as a gateway for the client side. All the outgoing requests are routed
                through it. It resides at the client side and represents the remote object. When the caller invokes the
                method on the stub object, it does the following tasks:</p>

            <ul>
                <li>It initiates a connection with remote Virtual Machine (JVM).</li>
                <li>It writes and transmits (marshals) the parameters to the remote Virtual Machine (JVM).</li>
                <li>It waits for the result.</li>
                <li>It reads (unmarshals) the return value or exception.</li>
                <li>It finally, returns the value to the caller.</li>
            </ul>

            <p>&nbsp;</p>

            <p><strong>Skeleton</strong></p>

            <p>The skeleton is an object, acts as a gateway for the server side object. All the incoming requests are
                routed through it. When the skeleton receives the incoming request, it does the following tasks:</p>

            <ul>
                <li>It reads the parameter for the remote method.</li>
                <li>It invokes the method on the actual remote object.</li>
                <li>It writes and transmits (marshals) the result to the caller.</li>
            </ul>

            <hr />
            <h3>244) What are the steps involved to write RMI based programs?</h3>

            <p>There are 6 steps which are performed to write RMI based programs.</p>

            <ul>
                <li>Create the remote interface.</li>
                <li>Provide the implementation of the remote interface.</li>
                <li>Compile the implementation class and create the stub and skeleton objects using the rmic tool.</li>
                <li>Start the registry service by the rmiregistry tool.</li>
                <li>Create and start the remote application.</li>
                <li>Create and start the client application.</li>
            </ul>

            <hr />
            <h3>245) What is the use of HTTP-tunneling in RMI?</h3>

            <p>HTTP tunneling can be defined as the method which doesn&#39;t need any setup to work within the firewall
                environment. It handles the HTTP connections through the proxy servers. However, it does not allow
                outbound TCP connections.</p>

            <hr />
            <h3>246) What is JRMP?</h3>

            <p>JRMP (Java Remote Method Protocol) can be defined as the Java-specific, stream-based protocol which looks
                up and refers to the remote objects. It requires both client and server to use Java objects. It is wire
                level protocol which runs under RMI and over TCP/IP.</p>

            <hr />
            <h3>247) Can RMI and CORBA based applications interact?</h3>

            <p>Yes, they can. RMI is available with IIOP as the transport protocol instead of JRMP.</p>

            <hr />
            <h2>Core Java: Data Structure interview questions</h2>

            <hr />
            <h3>248) How to perform Bubble Sort in Java?</h3>

            <p>Consider the following program to perform Bubble sort in Java.</p>

            <ol start="1">
                <li>public&nbsp;class&nbsp;BubbleSort&nbsp;{&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;public&nbsp;static&nbsp;void&nbsp;main(String[]&nbsp;args)&nbsp;{&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;int[]&nbsp;a&nbsp;=&nbsp;{10,&nbsp;9,&nbsp;7,&nbsp;101,&nbsp;23,&nbsp;44,&nbsp;12,&nbsp;78,&nbsp;34,&nbsp;23};&nbsp;&nbsp;
                </li>
                <li>&nbsp;&nbsp;for(int&nbsp;i=0;i&lt;10;i++)&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;{&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;(int&nbsp;j=0;j&lt;10;j++)&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(a[i]&lt;a[j])&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;temp&nbsp;=&nbsp;a[i];&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;a[i]=a[j];&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;a[j]&nbsp;=&nbsp;temp;&nbsp;&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;}&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;System.out.println(&quot;Printing&nbsp;Sorted&nbsp;List&nbsp;...&quot;);&nbsp;&nbsp;
                </li>
                <li>&nbsp;&nbsp;for(int&nbsp;i=0;i&lt;10;i++)&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;{&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(a[i]);&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;}&nbsp;&nbsp;</li>
                <li>}&nbsp;&nbsp;</li>
                <li>}&nbsp;&nbsp;</li>
            </ol>

            <p><strong>Output:</strong></p>

            <pre>
            Printing Sorted List . . . 
            7
            9
            10
            12
            23
            34
            34
            44
            78 
            101 
            </pre>

            <hr />
            <h3>249) How to perform Binary Search in Java?</h3>

            <p>Consider the following program to perform the binary search in Java.</p>

            <ol start="1">
                <li>import&nbsp;java.util.*;&nbsp;&nbsp;</li>
                <li>public&nbsp;class&nbsp;BinarySearch&nbsp;{&nbsp;&nbsp;</li>
                <li>public&nbsp;static&nbsp;void&nbsp;main(String[]&nbsp;args)&nbsp;{&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;int[]&nbsp;arr&nbsp;=&nbsp;{16,&nbsp;19,&nbsp;20,&nbsp;23,&nbsp;45,&nbsp;56,&nbsp;78,&nbsp;90,&nbsp;96,&nbsp;100};&nbsp;&nbsp;
                </li>
                <li>&nbsp;&nbsp;int&nbsp;item,&nbsp;location&nbsp;=&nbsp;-1;&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;System.out.println(&quot;Enter&nbsp;the&nbsp;item&nbsp;which&nbsp;you&nbsp;want&nbsp;to&nbsp;search&quot;);&nbsp;&nbsp;
                </li>
                <li>&nbsp;&nbsp;Scanner&nbsp;sc&nbsp;=&nbsp;new&nbsp;Scanner(System.in);&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;item&nbsp;=&nbsp;sc.nextInt();&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;location&nbsp;=&nbsp;binarySearch(arr,0,9,item);&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;if(location&nbsp;!=&nbsp;-1)&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;System.out.println(&quot;the&nbsp;location&nbsp;of&nbsp;the&nbsp;item&nbsp;is&nbsp;&quot;+location);&nbsp;&nbsp;
                </li>
                <li>&nbsp;&nbsp;else&nbsp;&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(&quot;Item&nbsp;not&nbsp;found&quot;);&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;}&nbsp;&nbsp;</li>
                <li>public&nbsp;static&nbsp;int&nbsp;binarySearch(int[]&nbsp;a,&nbsp;int&nbsp;beg,&nbsp;int&nbsp;end,&nbsp;int&nbsp;item)&nbsp;&nbsp;
                </li>
                <li>{&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;int&nbsp;mid;&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;if(end&nbsp;&gt;=&nbsp;beg)&nbsp;&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;{&nbsp;&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;mid&nbsp;=&nbsp;(beg&nbsp;+&nbsp;end)/2;&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;if(a[mid]&nbsp;==&nbsp;item)&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;mid+1;&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;else&nbsp;if(a[mid]&nbsp;&lt;&nbsp;item)&nbsp;&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;binarySearch(a,mid+1,end,item);&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;else&nbsp;&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;binarySearch(a,beg,mid-1,item);&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;}&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;return&nbsp;-1;&nbsp;&nbsp;&nbsp;</li>
                <li>}&nbsp;&nbsp;</li>
                <li>}&nbsp;&nbsp;</li>
            </ol>

            <p><strong>Output:</strong></p>

            <pre>
            Enter the item which you want to search 
            45 
            the location of the item is 5 
            </pre>

            <hr />
            <h3>250) How to perform Selection Sort in Java?</h3>

            <p>Consider the following program to perform selection sort in Java.</p>

            <ol start="1">
                <li>public&nbsp;class&nbsp;SelectionSort&nbsp;{&nbsp;&nbsp;</li>
                <li>public&nbsp;static&nbsp;void&nbsp;main(String[]&nbsp;args)&nbsp;{&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;int[]&nbsp;a&nbsp;=&nbsp;{10,&nbsp;9,&nbsp;7,&nbsp;101,&nbsp;23,&nbsp;44,&nbsp;12,&nbsp;78,&nbsp;34,&nbsp;23};&nbsp;&nbsp;
                </li>
                <li>&nbsp;&nbsp;int&nbsp;i,j,k,pos,temp;&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;for(i=0;i&lt;10;i++)&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;{&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;pos&nbsp;=&nbsp;smallest(a,10,i);&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;temp&nbsp;=&nbsp;a[i];&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;a[i]=a[pos];&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;a[pos]&nbsp;=&nbsp;temp;&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;}&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;System.out.println(&quot;\nprinting&nbsp;sorted&nbsp;elements...\n&quot;);&nbsp;&nbsp;
                </li>
                <li>&nbsp;&nbsp;for(i=0;i&lt;10;i++)&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;{&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(a[i]);&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;}&nbsp;&nbsp;</li>
                <li>}&nbsp;&nbsp;</li>
                <li>public&nbsp;static&nbsp;int&nbsp;smallest(int&nbsp;a[],&nbsp;int&nbsp;n,&nbsp;int&nbsp;i)&nbsp;&nbsp;
                </li>
                <li>{&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;int&nbsp;small,pos,j;&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;small&nbsp;=&nbsp;a[i];&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;pos&nbsp;=&nbsp;i;&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;for(j=i+1;j&lt;10;j++)&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;{&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;if(a[j]&lt;small)&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;small&nbsp;=&nbsp;a[j];&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pos=j;&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;}&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;return&nbsp;pos;&nbsp;&nbsp;</li>
                <li>}&nbsp;&nbsp;</li>
                <li>}&nbsp;&nbsp;</li>
            </ol>

            <p><strong>Output:</strong></p>

            <pre>
            printing sorted elements...
            7
            9
            10
            12
            23
            23
            34
            44
            78
            101
            </pre>

            <hr />
            <h3>251) How to perform Linear Search in Java?</h3>

            <p>Consider the following program to perform Linear search in Java.</p>

            <ol start="1">
                <li>import&nbsp;java.util.Scanner;&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;</li>
                <li>public&nbsp;class&nbsp;Leniear_Search&nbsp;{&nbsp;&nbsp;</li>
                <li>public&nbsp;static&nbsp;void&nbsp;main(String[]&nbsp;args)&nbsp;{&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;int[]&nbsp;arr&nbsp;=&nbsp;{10,&nbsp;23,&nbsp;15,&nbsp;8,&nbsp;4,&nbsp;3,&nbsp;25,&nbsp;30,&nbsp;34,&nbsp;2,&nbsp;19};&nbsp;&nbsp;
                </li>
                <li>&nbsp;&nbsp;int&nbsp;item,flag=0;&nbsp;&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;Scanner&nbsp;sc&nbsp;=&nbsp;new&nbsp;Scanner(System.in);&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;System.out.println(&quot;Enter&nbsp;Item&nbsp;?&quot;);&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;item&nbsp;=&nbsp;sc.nextInt();&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;for(int&nbsp;i&nbsp;=&nbsp;0;&nbsp;i&lt;10;&nbsp;i++)&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;{&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;if(arr[i]==item)&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;flag&nbsp;=&nbsp;i+1;&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;else&nbsp;&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;flag&nbsp;=&nbsp;0;&nbsp;&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;}&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;if(flag&nbsp;!=&nbsp;0)&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;{&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(&quot;Item&nbsp;found&nbsp;at&nbsp;location&quot;&nbsp;+&nbsp;flag);&nbsp;&nbsp;
                </li>
                <li>&nbsp;&nbsp;}&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;else&nbsp;&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(&quot;Item&nbsp;not&nbsp;found&quot;);&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;</li>
                <li>}&nbsp;&nbsp;</li>
                <li>}&nbsp;&nbsp;</li>
            </ol>

            <p><strong>Output:</strong></p>

            <pre>
            Enter Item ?
            23
            Item found at location 2
            Enter Item ?
            22
            Item not found
            </pre>

            <hr />
            <h3>252) How to perform merge sort in Java?</h3>

            <p>Consider the following program to perform merge sort in Java.</p>

            <ol start="1">
                <li>public&nbsp;class&nbsp;MyMergeSort&nbsp;&nbsp;</li>
                <li>{&nbsp;&nbsp;</li>
                <li>void&nbsp;merge(int&nbsp;arr[],&nbsp;int&nbsp;beg,&nbsp;int&nbsp;mid,&nbsp;int&nbsp;end)&nbsp;&nbsp;
                </li>
                <li>{&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;</li>
                <li>int&nbsp;l&nbsp;=&nbsp;mid&nbsp;-&nbsp;beg&nbsp;+&nbsp;1;&nbsp;&nbsp;</li>
                <li>int&nbsp;r&nbsp;=&nbsp;end&nbsp;-&nbsp;mid;&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;</li>
                <li>intLeftArray[]&nbsp;=&nbsp;new&nbsp;int&nbsp;[l];&nbsp;&nbsp;</li>
                <li>intRightArray[]&nbsp;=&nbsp;new&nbsp;int&nbsp;[r];&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;</li>
                <li>for&nbsp;(int&nbsp;i=0;&nbsp;i&lt;l;&nbsp;++i)&nbsp;&nbsp;</li>
                <li>LeftArray[i]&nbsp;=&nbsp;arr[beg&nbsp;+&nbsp;i];&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;</li>
                <li>for&nbsp;(int&nbsp;j=0;&nbsp;j&lt;r;&nbsp;++j)&nbsp;&nbsp;</li>
                <li>RightArray[j]&nbsp;=&nbsp;arr[mid&nbsp;+&nbsp;1+&nbsp;j];&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;</li>
                <li>int&nbsp;i&nbsp;=&nbsp;0,&nbsp;j&nbsp;=&nbsp;0;&nbsp;&nbsp;</li>
                <li>int&nbsp;k&nbsp;=&nbsp;beg;&nbsp;&nbsp;</li>
                <li>while&nbsp;(i&lt;l&amp;&amp;j&lt;r)&nbsp;&nbsp;</li>
                <li>{&nbsp;&nbsp;</li>
                <li>if&nbsp;(LeftArray[i]&nbsp;&lt;=&nbsp;RightArray[j])&nbsp;&nbsp;</li>
                <li>{&nbsp;&nbsp;</li>
                <li>arr[k]&nbsp;=&nbsp;LeftArray[i];&nbsp;&nbsp;</li>
                <li>i++;&nbsp;&nbsp;</li>
                <li>}&nbsp;&nbsp;</li>
                <li>else&nbsp;&nbsp;</li>
                <li>{&nbsp;&nbsp;</li>
                <li>arr[k]&nbsp;=&nbsp;RightArray[j];&nbsp;&nbsp;</li>
                <li>j++;&nbsp;&nbsp;</li>
                <li>}&nbsp;&nbsp;</li>
                <li>k++;&nbsp;&nbsp;</li>
                <li>}&nbsp;&nbsp;</li>
                <li>while&nbsp;(i&lt;l)&nbsp;&nbsp;</li>
                <li>{&nbsp;&nbsp;</li>
                <li>arr[k]&nbsp;=&nbsp;LeftArray[i];&nbsp;&nbsp;</li>
                <li>i++;&nbsp;&nbsp;</li>
                <li>k++;&nbsp;&nbsp;</li>
                <li>}&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;</li>
                <li>while&nbsp;(j&lt;r)&nbsp;&nbsp;</li>
                <li>{&nbsp;&nbsp;</li>
                <li>arr[k]&nbsp;=&nbsp;RightArray[j];&nbsp;&nbsp;</li>
                <li>j++;&nbsp;&nbsp;</li>
                <li>k++;&nbsp;&nbsp;</li>
                <li>}&nbsp;&nbsp;</li>
                <li>}&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;</li>
                <li>void&nbsp;sort(int&nbsp;arr[],&nbsp;int&nbsp;beg,&nbsp;int&nbsp;end)&nbsp;&nbsp;</li>
                <li>{&nbsp;&nbsp;</li>
                <li>if&nbsp;(beg&lt;end)&nbsp;&nbsp;</li>
                <li>{&nbsp;&nbsp;</li>
                <li>int&nbsp;mid&nbsp;=&nbsp;(beg+end)/2;&nbsp;&nbsp;</li>
                <li>sort(arr,&nbsp;beg,&nbsp;mid);&nbsp;&nbsp;</li>
                <li>sort(arr&nbsp;,&nbsp;mid+1,&nbsp;end);&nbsp;&nbsp;</li>
                <li>merge(arr,&nbsp;beg,&nbsp;mid,&nbsp;end);&nbsp;&nbsp;</li>
                <li>}&nbsp;&nbsp;</li>
                <li>}&nbsp;&nbsp;</li>
                <li>public&nbsp;static&nbsp;void&nbsp;main(String&nbsp;args[])&nbsp;&nbsp;</li>
                <li>{&nbsp;&nbsp;</li>
                <li>intarr[]&nbsp;=&nbsp;{90,23,101,45,65,23,67,89,34,23};&nbsp;&nbsp;</li>
                <li>MyMergeSort&nbsp;ob&nbsp;=&nbsp;new&nbsp;MyMergeSort();&nbsp;&nbsp;</li>
                <li>ob.sort(arr,&nbsp;0,&nbsp;arr.length-1);&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;</li>
                <li>System.out.println(&quot;\nSorted&nbsp;array&quot;);&nbsp;&nbsp;</li>
                <li>for(int&nbsp;i&nbsp;=0;&nbsp;i&lt;arr.length;i++)&nbsp;&nbsp;</li>
                <li>{&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;System.out.println(arr[i]+&quot;&quot;);&nbsp;&nbsp;</li>
                <li>}&nbsp;&nbsp;</li>
                <li>}&nbsp;&nbsp;</li>
                <li>}&nbsp;&nbsp;</li>
            </ol>

            <p><strong>Output:</strong></p>

            <pre>
            Sorted array 
            23
            23
            23
            34
            45
            65
            67
            89
            90
            101
            </pre>

            <hr />
            <h3>253) How to perform quicksort in Java?</h3>

            <p>Consider the following program to perform quicksort in Java.</p>

            <ol start="1">
                <li>public&nbsp;class&nbsp;QuickSort&nbsp;{&nbsp;&nbsp;</li>
                <li>public&nbsp;static&nbsp;void&nbsp;main(String[]&nbsp;args)&nbsp;{&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;i;&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;int[]&nbsp;arr={90,23,101,45,65,23,67,89,34,23};&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;quickSort(arr,&nbsp;0,&nbsp;9);&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(&quot;\n&nbsp;The&nbsp;sorted&nbsp;array&nbsp;is:&nbsp;\n&quot;);&nbsp;&nbsp;
                </li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;for(i=0;i&lt;10;i++)&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(arr[i]);&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;}&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;public&nbsp;static&nbsp;int&nbsp;partition(int&nbsp;a[],&nbsp;int&nbsp;beg,&nbsp;int&nbsp;end)&nbsp;&nbsp;
                </li>
                <li>&nbsp;&nbsp;{&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;left,&nbsp;right,&nbsp;temp,&nbsp;loc,&nbsp;flag;&nbsp;&nbsp;&nbsp;
                </li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;loc&nbsp;=&nbsp;left&nbsp;=&nbsp;beg;&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;right&nbsp;=&nbsp;end;&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;flag&nbsp;=&nbsp;0;&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;while(flag&nbsp;!=&nbsp;1)&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;while((a[loc]&nbsp;&lt;=&nbsp;a[right])&nbsp;&amp;&amp;&nbsp;(loc!=right))&nbsp;&nbsp;
                </li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;right--;&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(loc==right)&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;flag&nbsp;=1;&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;elseif(a[loc]&gt;a[right])&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;temp&nbsp;=&nbsp;a[loc];&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;a[loc]&nbsp;=&nbsp;a[right];&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;a[right]&nbsp;=&nbsp;temp;&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;loc&nbsp;=&nbsp;right;&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(flag!=1)&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;while((a[loc]&nbsp;&gt;=&nbsp;a[left])&nbsp;&amp;&amp;&nbsp;(loc!=left))&nbsp;&nbsp;
                </li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;left++;&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(loc==left)&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;flag&nbsp;=1;&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;elseif(a[loc]&nbsp;&lt;a[left])&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;temp&nbsp;=&nbsp;a[loc];&nbsp;&nbsp;
                </li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;a[loc]&nbsp;=&nbsp;a[left];&nbsp;&nbsp;
                </li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;a[left]&nbsp;=&nbsp;temp;&nbsp;&nbsp;
                </li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;loc&nbsp;=&nbsp;left;&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;returnloc;&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;}&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;static&nbsp;void&nbsp;quickSort(int&nbsp;a[],&nbsp;int&nbsp;beg,&nbsp;int&nbsp;end)&nbsp;&nbsp;
                </li>
                <li>&nbsp;&nbsp;{&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;loc;&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;if(beg&lt;end)&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;loc&nbsp;=&nbsp;partition(a,&nbsp;beg,&nbsp;end);&nbsp;&nbsp;
                </li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;quickSort(a,&nbsp;beg,&nbsp;loc-1);&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;quickSort(a,&nbsp;loc+1,&nbsp;end);&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;}&nbsp;&nbsp;</li>
                <li>}&nbsp;&nbsp;</li>
            </ol>

            <p><strong>Output:</strong></p>

            <pre>
            The sorted array is: 
            23
            23
            23
            34
            45
            65
            67
            89
            90
            101
            </pre>

            <hr />
            <h3>254) Write a program in Java to create a doubly linked list containing n nodes.</h3>

            <p>Consider the following program to create a doubly linked list containing n nodes.</p>

            <ol start="1">
                <li>&nbsp;&nbsp;public&nbsp;class&nbsp;CountList&nbsp;{&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;//Represent&nbsp;a&nbsp;node&nbsp;of&nbsp;the&nbsp;doubly&nbsp;linked&nbsp;list&nbsp;&nbsp;
                </li>
                <li>&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;class&nbsp;Node{&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;data;&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Node&nbsp;previous;&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Node&nbsp;next;&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;Node(int&nbsp;data)&nbsp;{&nbsp;&nbsp;
                </li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.data&nbsp;=&nbsp;data;&nbsp;&nbsp;
                </li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;//Represent&nbsp;the&nbsp;head&nbsp;and&nbsp;tail&nbsp;of&nbsp;the&nbsp;doubly&nbsp;linked&nbsp;list&nbsp;&nbsp;
                </li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;Node&nbsp;head,&nbsp;tail&nbsp;=&nbsp;null;&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;//addNode()&nbsp;will&nbsp;add&nbsp;a&nbsp;node&nbsp;to&nbsp;the&nbsp;list&nbsp;&nbsp;
                </li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;addNode(int&nbsp;data)&nbsp;{&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//Create&nbsp;a&nbsp;new&nbsp;node&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Node&nbsp;newNode&nbsp;=&nbsp;new&nbsp;Node(data);&nbsp;&nbsp;
                </li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//If&nbsp;list&nbsp;is&nbsp;empty&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(head&nbsp;==&nbsp;null)&nbsp;{&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//Both&nbsp;head&nbsp;and&nbsp;tail&nbsp;will&nbsp;point&nbsp;to&nbsp;newNode&nbsp;&nbsp;
                </li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;head&nbsp;=&nbsp;tail&nbsp;=&nbsp;newNode;&nbsp;&nbsp;
                </li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//head&#39;s&nbsp;previous&nbsp;will&nbsp;point&nbsp;to&nbsp;null&nbsp;&nbsp;
                </li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;head.previous&nbsp;=&nbsp;null;&nbsp;&nbsp;
                </li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//tail&#39;s&nbsp;next&nbsp;will&nbsp;point&nbsp;to&nbsp;null,&nbsp;as&nbsp;it&nbsp;is&nbsp;the&nbsp;last&nbsp;node&nbsp;of&nbsp;the&nbsp;list&nbsp;&nbsp;
                </li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tail.next&nbsp;=&nbsp;null;&nbsp;&nbsp;
                </li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else&nbsp;{&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//newNode&nbsp;will&nbsp;be&nbsp;added&nbsp;after&nbsp;tail&nbsp;such&nbsp;that&nbsp;tail&#39;s&nbsp;next&nbsp;will&nbsp;point&nbsp;to&nbsp;newNode&nbsp;&nbsp;
                </li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tail.next&nbsp;=&nbsp;newNode;&nbsp;&nbsp;
                </li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//newNode&#39;s&nbsp;previous&nbsp;will&nbsp;point&nbsp;to&nbsp;tail&nbsp;&nbsp;
                </li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;newNode.previous&nbsp;=&nbsp;tail;&nbsp;&nbsp;
                </li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//newNode&nbsp;will&nbsp;become&nbsp;new&nbsp;tail&nbsp;&nbsp;
                </li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tail&nbsp;=&nbsp;newNode;&nbsp;&nbsp;
                </li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//As&nbsp;it&nbsp;is&nbsp;last&nbsp;node,&nbsp;tail&#39;s&nbsp;next&nbsp;will&nbsp;point&nbsp;to&nbsp;null&nbsp;&nbsp;
                </li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tail.next&nbsp;=&nbsp;null;&nbsp;&nbsp;
                </li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;//countNodes()&nbsp;will&nbsp;count&nbsp;the&nbsp;nodes&nbsp;present&nbsp;in&nbsp;the&nbsp;list&nbsp;&nbsp;
                </li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;int&nbsp;countNodes()&nbsp;{&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;counter&nbsp;=&nbsp;0;&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//Node&nbsp;current&nbsp;will&nbsp;point&nbsp;to&nbsp;head&nbsp;&nbsp;
                </li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Node&nbsp;current&nbsp;=&nbsp;head;&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;while(current&nbsp;!=&nbsp;null)&nbsp;{&nbsp;&nbsp;
                </li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//Increment&nbsp;the&nbsp;counter&nbsp;by&nbsp;1&nbsp;for&nbsp;each&nbsp;node&nbsp;&nbsp;
                </li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;counter++;&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;current&nbsp;=&nbsp;current.next;&nbsp;&nbsp;
                </li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;counter;&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;//display()&nbsp;will&nbsp;print&nbsp;out&nbsp;the&nbsp;elements&nbsp;of&nbsp;the&nbsp;list&nbsp;&nbsp;
                </li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;display()&nbsp;{&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//Node&nbsp;current&nbsp;will&nbsp;point&nbsp;to&nbsp;head&nbsp;&nbsp;
                </li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Node&nbsp;current&nbsp;=&nbsp;head;&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(head&nbsp;==&nbsp;null)&nbsp;{&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(&quot;List&nbsp;is&nbsp;empty&quot;);&nbsp;&nbsp;
                </li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return;&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(&quot;Nodes&nbsp;of&nbsp;doubly&nbsp;linked&nbsp;list:&nbsp;&quot;);&nbsp;&nbsp;
                </li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;while(current&nbsp;!=&nbsp;null)&nbsp;{&nbsp;&nbsp;
                </li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//Prints&nbsp;each&nbsp;node&nbsp;by&nbsp;incrementing&nbsp;the&nbsp;pointer.&nbsp;&nbsp;
                </li>
                <li>&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.print(current.data&nbsp;+&nbsp;&quot;&nbsp;&quot;);&nbsp;&nbsp;
                </li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;current&nbsp;=&nbsp;current.next;&nbsp;&nbsp;
                </li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;void&nbsp;main(String[]&nbsp;args)&nbsp;{&nbsp;&nbsp;
                </li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;CountList&nbsp;dList&nbsp;=&nbsp;new&nbsp;CountList();&nbsp;&nbsp;
                </li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//Add&nbsp;nodes&nbsp;to&nbsp;the&nbsp;list&nbsp;&nbsp;
                </li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dList.addNode(1);&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dList.addNode(2);&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dList.addNode(3);&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dList.addNode(4);&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dList.addNode(5);&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//Displays&nbsp;the&nbsp;nodes&nbsp;present&nbsp;in&nbsp;the&nbsp;list&nbsp;&nbsp;
                </li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dList.display();&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//Counts&nbsp;the&nbsp;nodes&nbsp;present&nbsp;in&nbsp;the&nbsp;given&nbsp;list&nbsp;&nbsp;
                </li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(&quot;\nCount&nbsp;of&nbsp;nodes&nbsp;present&nbsp;in&nbsp;the&nbsp;list:&nbsp;&quot;&nbsp;+&nbsp;dList.countNodes());&nbsp;&nbsp;
                </li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</li>
                <li>}&nbsp;&nbsp;</li>
            </ol>

            <p><strong>Output:</strong></p>

            <pre>
            Nodes of doubly linked list: 
            1 2 3 4 5 
            Count of nodes present in the list: 5
            </pre>

            <hr />
            <h3>255) Write a program in Java to find the maximum and minimum value node from a circular linked list.
            </h3>

            <p>Consider the following program.</p>

            <ol start="1">
                <li>public&nbsp;class&nbsp;MinMax&nbsp;{&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;//Represents&nbsp;the&nbsp;node&nbsp;of&nbsp;list.&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;class&nbsp;Node{&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;data;&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Node&nbsp;next;&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;Node(int&nbsp;data)&nbsp;{&nbsp;&nbsp;
                </li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.data&nbsp;=&nbsp;data;&nbsp;&nbsp;
                </li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;//Declaring&nbsp;head&nbsp;and&nbsp;tail&nbsp;pointer&nbsp;as&nbsp;null.&nbsp;&nbsp;
                </li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;Node&nbsp;head&nbsp;=&nbsp;null;&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;Node&nbsp;tail&nbsp;=&nbsp;null;&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;//This&nbsp;function&nbsp;will&nbsp;add&nbsp;the&nbsp;new&nbsp;node&nbsp;at&nbsp;the&nbsp;end&nbsp;of&nbsp;the&nbsp;list.&nbsp;&nbsp;
                </li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;add(int&nbsp;data){&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//Create&nbsp;new&nbsp;node&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Node&nbsp;newNode&nbsp;=&nbsp;new&nbsp;Node(data);&nbsp;&nbsp;
                </li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//Checks&nbsp;if&nbsp;the&nbsp;list&nbsp;is&nbsp;empty.&nbsp;&nbsp;
                </li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(head&nbsp;==&nbsp;null)&nbsp;{&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//If&nbsp;list&nbsp;is&nbsp;empty,&nbsp;both&nbsp;head&nbsp;and&nbsp;tail&nbsp;would&nbsp;point&nbsp;to&nbsp;new&nbsp;node.&nbsp;&nbsp;
                </li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;head&nbsp;=&nbsp;newNode;&nbsp;&nbsp;
                </li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tail&nbsp;=&nbsp;newNode;&nbsp;&nbsp;
                </li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;newNode.next&nbsp;=&nbsp;head;&nbsp;&nbsp;
                </li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else&nbsp;{&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//tail&nbsp;will&nbsp;point&nbsp;to&nbsp;new&nbsp;node.&nbsp;&nbsp;
                </li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tail.next&nbsp;=&nbsp;newNode;&nbsp;&nbsp;
                </li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//New&nbsp;node&nbsp;will&nbsp;become&nbsp;new&nbsp;tail.&nbsp;&nbsp;
                </li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tail&nbsp;=&nbsp;newNode;&nbsp;&nbsp;
                </li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//Since,&nbsp;it&nbsp;is&nbsp;circular&nbsp;linked&nbsp;list&nbsp;tail&nbsp;will&nbsp;points&nbsp;to&nbsp;head.&nbsp;&nbsp;
                </li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tail.next&nbsp;=&nbsp;head;&nbsp;&nbsp;
                </li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;//Finds&nbsp;out&nbsp;the&nbsp;minimum&nbsp;value&nbsp;node&nbsp;in&nbsp;the&nbsp;list&nbsp;&nbsp;
                </li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;minNode()&nbsp;{&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Node&nbsp;current&nbsp;=&nbsp;head;&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//Initializing&nbsp;min&nbsp;to&nbsp;initial&nbsp;node&nbsp;data&nbsp;&nbsp;
                </li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;min&nbsp;=&nbsp;head.data;&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(head&nbsp;==&nbsp;null)&nbsp;{&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(&quot;List&nbsp;is&nbsp;empty&quot;);&nbsp;&nbsp;
                </li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else&nbsp;{&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;do{&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//If&nbsp;current&nbsp;node&#39;s&nbsp;data&nbsp;is&nbsp;smaller&nbsp;than&nbsp;min&nbsp;&nbsp;
                </li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//Then&nbsp;replace&nbsp;value&nbsp;of&nbsp;min&nbsp;with&nbsp;current&nbsp;node&#39;s&nbsp;data&nbsp;&nbsp;
                </li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(min&nbsp;&gt;&nbsp;current.data)&nbsp;{&nbsp;&nbsp;
                </li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;min&nbsp;=&nbsp;current.data;&nbsp;&nbsp;
                </li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;
                </li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;current=&nbsp;current.next;&nbsp;&nbsp;
                </li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}while(current&nbsp;!=&nbsp;head);&nbsp;&nbsp;
                </li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(&quot;Minimum&nbsp;value&nbsp;node&nbsp;in&nbsp;the&nbsp;list:&nbsp;&quot;+&nbsp;min);&nbsp;&nbsp;
                </li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;//Finds&nbsp;out&nbsp;the&nbsp;maximum&nbsp;value&nbsp;node&nbsp;in&nbsp;the&nbsp;list&nbsp;&nbsp;
                </li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;maxNode()&nbsp;{&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Node&nbsp;current&nbsp;=&nbsp;head;&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//Initializing&nbsp;max&nbsp;to&nbsp;initial&nbsp;node&nbsp;data&nbsp;&nbsp;
                </li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;max&nbsp;=&nbsp;head.data;&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(head&nbsp;==&nbsp;null)&nbsp;{&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(&quot;List&nbsp;is&nbsp;empty&quot;);&nbsp;&nbsp;
                </li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else&nbsp;{&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;do{&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//If&nbsp;current&nbsp;node&#39;s&nbsp;data&nbsp;is&nbsp;greater&nbsp;than&nbsp;max&nbsp;&nbsp;
                </li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//Then&nbsp;replace&nbsp;value&nbsp;of&nbsp;max&nbsp;with&nbsp;current&nbsp;node&#39;s&nbsp;data&nbsp;&nbsp;
                </li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(max&nbsp;&lt;&nbsp;current.data)&nbsp;{&nbsp;&nbsp;
                </li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;max&nbsp;=&nbsp;current.data;&nbsp;&nbsp;
                </li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;
                </li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;current=&nbsp;current.next;&nbsp;&nbsp;
                </li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}while(current&nbsp;!=&nbsp;head);&nbsp;&nbsp;
                </li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(&quot;Maximum&nbsp;value&nbsp;node&nbsp;in&nbsp;the&nbsp;list:&nbsp;&quot;+&nbsp;max);&nbsp;&nbsp;
                </li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
                </li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;void&nbsp;main(String[]&nbsp;args)&nbsp;{&nbsp;&nbsp;
                </li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;MinMax&nbsp;cl&nbsp;=&nbsp;new&nbsp;MinMax();&nbsp;&nbsp;
                </li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//Adds&nbsp;data&nbsp;to&nbsp;the&nbsp;list&nbsp;&nbsp;
                </li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cl.add(5);&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cl.add(20);&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cl.add(10);&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cl.add(1);&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//Prints&nbsp;the&nbsp;minimum&nbsp;value&nbsp;node&nbsp;in&nbsp;the&nbsp;list&nbsp;&nbsp;
                </li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cl.minNode();&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//Prints&nbsp;the&nbsp;maximum&nbsp;value&nbsp;node&nbsp;in&nbsp;the&nbsp;list&nbsp;&nbsp;
                </li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cl.maxNode();&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</li>
                <li>}&nbsp;&nbsp;</li>
            </ol>

            <p><strong>Output:</strong></p>

            <pre>
            Minimum value node in the list: 1
            Maximum value node in the list: 20
            </pre>

            <hr />
            <h3>256) Write a program in Java to calculate the difference between the sum of the odd level and even level
                nodes of a Binary Tree.</h3>

            <p>Consider the following program.</p>

            <ol start="1">
                <li>import&nbsp;java.util.LinkedList;&nbsp;&nbsp;</li>
                <li>import&nbsp;java.util.Queue;&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;</li>
                <li>public&nbsp;class&nbsp;DiffOddEven&nbsp;{&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;//Represent&nbsp;a&nbsp;node&nbsp;of&nbsp;binary&nbsp;tree&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;class&nbsp;Node{&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;data;&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Node&nbsp;left;&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Node&nbsp;right;&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;Node(int&nbsp;data){&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//Assign&nbsp;data&nbsp;to&nbsp;the&nbsp;new&nbsp;node,&nbsp;set&nbsp;left&nbsp;and&nbsp;right&nbsp;children&nbsp;to&nbsp;null&nbsp;&nbsp;
                </li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.data&nbsp;=&nbsp;data;&nbsp;&nbsp;
                </li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.left&nbsp;=&nbsp;null;&nbsp;&nbsp;
                </li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.right&nbsp;=&nbsp;null;&nbsp;&nbsp;
                </li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;//Represent&nbsp;the&nbsp;root&nbsp;of&nbsp;binary&nbsp;tree&nbsp;&nbsp;
                </li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;Node&nbsp;root;&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;DiffOddEven(){&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;root&nbsp;=&nbsp;null;&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;//difference()&nbsp;will&nbsp;calculate&nbsp;the&nbsp;difference&nbsp;between&nbsp;sum&nbsp;of&nbsp;odd&nbsp;and&nbsp;even&nbsp;levels&nbsp;of&nbsp;binary&nbsp;tree&nbsp;&nbsp;
                </li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;int&nbsp;difference()&nbsp;{&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;oddLevel&nbsp;=&nbsp;0,&nbsp;evenLevel&nbsp;=&nbsp;0,&nbsp;diffOddEven&nbsp;=&nbsp;0;&nbsp;&nbsp;
                </li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//Variable&nbsp;nodesInLevel&nbsp;keep&nbsp;tracks&nbsp;of&nbsp;number&nbsp;of&nbsp;nodes&nbsp;in&nbsp;each&nbsp;level&nbsp;&nbsp;
                </li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;nodesInLevel&nbsp;=&nbsp;0;&nbsp;&nbsp;
                </li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//Variable&nbsp;currentLevel&nbsp;keep&nbsp;track&nbsp;of&nbsp;level&nbsp;in&nbsp;binary&nbsp;tree&nbsp;&nbsp;
                </li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;currentLevel&nbsp;=&nbsp;0;&nbsp;&nbsp;
                </li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//Queue&nbsp;will&nbsp;be&nbsp;used&nbsp;to&nbsp;keep&nbsp;track&nbsp;of&nbsp;nodes&nbsp;of&nbsp;tree&nbsp;level-wise&nbsp;&nbsp;
                </li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Queue&lt;Node&gt;&nbsp;queue&nbsp;=&nbsp;new&nbsp;LinkedList&lt;Node&gt;();&nbsp;&nbsp;
                </li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//Check&nbsp;if&nbsp;root&nbsp;is&nbsp;null&nbsp;&nbsp;
                </li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(root&nbsp;==&nbsp;null)&nbsp;{&nbsp;&nbsp;
                </li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(&quot;Tree&nbsp;is&nbsp;empty&quot;);&nbsp;&nbsp;
                </li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;0;&nbsp;&nbsp;
                </li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else&nbsp;{&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//Add&nbsp;root&nbsp;node&nbsp;to&nbsp;queue&nbsp;as&nbsp;it&nbsp;represents&nbsp;the&nbsp;first&nbsp;level&nbsp;&nbsp;
                </li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;queue.add(root);&nbsp;&nbsp;
                </li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;currentLevel++;&nbsp;&nbsp;
                </li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
                </li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;while(queue.size()&nbsp;!=&nbsp;0)&nbsp;{&nbsp;&nbsp;
                </li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
                </li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//Variable&nbsp;nodesInLevel&nbsp;will&nbsp;hold&nbsp;the&nbsp;size&nbsp;of&nbsp;queue&nbsp;i.e.&nbsp;number&nbsp;of&nbsp;elements&nbsp;in&nbsp;queue&nbsp;&nbsp;
                </li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;nodesInLevel&nbsp;=&nbsp;queue.size();&nbsp;&nbsp;
                </li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
                </li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;while(nodesInLevel&nbsp;&gt;&nbsp;0)&nbsp;{&nbsp;&nbsp;
                </li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Node&nbsp;current&nbsp;=&nbsp;queue.remove();&nbsp;&nbsp;
                </li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
                </li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//Checks&nbsp;if&nbsp;currentLevel&nbsp;is&nbsp;even&nbsp;or&nbsp;not.&nbsp;&nbsp;
                </li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(currentLevel&nbsp;%&nbsp;2&nbsp;==&nbsp;0)&nbsp;&nbsp;
                </li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//If&nbsp;level&nbsp;is&nbsp;even,&nbsp;add&nbsp;nodes&#39;s&nbsp;to&nbsp;variable&nbsp;evenLevel&nbsp;&nbsp;
                </li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;evenLevel&nbsp;+=&nbsp;current.data;&nbsp;&nbsp;
                </li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else&nbsp;&nbsp;
                </li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//If&nbsp;level&nbsp;is&nbsp;odd,&nbsp;add&nbsp;nodes&#39;s&nbsp;to&nbsp;variable&nbsp;oddLevel&nbsp;&nbsp;
                </li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;oddLevel&nbsp;+=&nbsp;current.data;&nbsp;&nbsp;
                </li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
                </li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//Adds&nbsp;left&nbsp;child&nbsp;to&nbsp;queue&nbsp;&nbsp;
                </li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(current.left&nbsp;!=&nbsp;null)&nbsp;&nbsp;
                </li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;queue.add(current.left);&nbsp;&nbsp;
                </li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//Adds&nbsp;right&nbsp;child&nbsp;to&nbsp;queue&nbsp;&nbsp;
                </li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(current.right&nbsp;!=&nbsp;null)&nbsp;&nbsp;&nbsp;
                </li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;queue.add(current.right);&nbsp;&nbsp;
                </li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;nodesInLevel--;&nbsp;&nbsp;
                </li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;
                </li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;currentLevel++;&nbsp;&nbsp;
                </li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;
                </li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//Calculates&nbsp;difference&nbsp;between&nbsp;oddLevel&nbsp;and&nbsp;evenLevel&nbsp;&nbsp;
                </li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;diffOddEven&nbsp;=&nbsp;Math.abs(oddLevel&nbsp;-&nbsp;evenLevel);&nbsp;&nbsp;
                </li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;diffOddEven;&nbsp;&nbsp;
                </li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;void&nbsp;main&nbsp;(String[]&nbsp;args)&nbsp;{&nbsp;&nbsp;
                </li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;DiffOddEven&nbsp;bt&nbsp;=&nbsp;new&nbsp;DiffOddEven();&nbsp;&nbsp;
                </li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//Add&nbsp;nodes&nbsp;to&nbsp;the&nbsp;binary&nbsp;tree&nbsp;&nbsp;
                </li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;bt.root&nbsp;=&nbsp;new&nbsp;Node(1);&nbsp;&nbsp;
                </li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;bt.root.left&nbsp;=&nbsp;new&nbsp;Node(2);&nbsp;&nbsp;
                </li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;bt.root.right&nbsp;=&nbsp;new&nbsp;Node(3);&nbsp;&nbsp;
                </li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;bt.root.left.left&nbsp;=&nbsp;new&nbsp;Node(4);&nbsp;&nbsp;
                </li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;bt.root.right.left&nbsp;=&nbsp;new&nbsp;Node(5);&nbsp;&nbsp;
                </li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;bt.root.right.right&nbsp;=&nbsp;new&nbsp;Node(6);&nbsp;&nbsp;
                </li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//Display&nbsp;the&nbsp;difference&nbsp;between&nbsp;sum&nbsp;of&nbsp;odd&nbsp;level&nbsp;and&nbsp;even&nbsp;level&nbsp;nodes&nbsp;&nbsp;
                </li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(&quot;Difference&nbsp;between&nbsp;sum&nbsp;of&nbsp;odd&nbsp;level&nbsp;and&nbsp;even&nbsp;level&nbsp;nodes:&nbsp;&quot;&nbsp;+&nbsp;bt.difference());&nbsp;&nbsp;
                </li>
                <li>}&nbsp;&nbsp;</li>
                <li>}&nbsp;&nbsp;</li>
            </ol>

            <p><strong>Output:</strong></p>

            <pre>
            Difference between sum of odd level and even level nodes: 11</pre>

        </div>

        <div class="box-prem">
            <h1>Java Multithreading and Concurrency Interview Questions</h1>

            <p>Multithreading and Synchronization are considered as the typical chapter in java programming. In game
                development companies, multithreading related interview questions are asked mostly. A list of frequently
                asked java multithreading and concurrency interview questions is given below.</p>

            <hr />
            <h2>Multithreading Interview Questions</h2>

            <h3>1) What is multithreading?</h3>

            <p>Multithreading is a process of executing multiple threads simultaneously. Multithreading is used to
                obtain the multitasking. It consumes less memory and gives the fast and efficient performance. Its main
                advantages are:</p>

            <ul>
                <li>Threads share the same address space.</li>
                <li>The thread is lightweight.</li>
                <li>The cost of communication between the processes is low.</li>
            </ul>

            <p><a href="https://www.javatpoint.com/multithreading">More details.</a></p>

            <hr />
            <h3>2) What is the thread?</h3>

            <p>A thread is a lightweight subprocess. It is a separate path of execution because each thread runs in a
                different stack frame. A process may contain multiple threads. Threads share the process resources, but
                still, they execute independently.</p>

            <p><a href="https://www.javatpoint.com/multithreading">More details.</a></p>

            <hr />
            <h3>3) Differentiate between process and thread?</h3>

            <p>There are the following differences between the process and thread.</p>

            <p>&nbsp;</p>

            <p>&nbsp;</p>

            <p>38.6M</p>

            <p>816</p>

            <p>C++ vs Java</p>

            <p>Next</p>

            <p>Stay</p>

            <ul>
                <li>A Program in the execution is called the process whereas; A thread is a subset of the process</li>
                <li>Processes are independent whereas threads are the subset of process.</li>
                <li>Process have different address space in memory, while threads contain a shared address space.</li>
                <li>Context switching is faster between the threads as compared to processes.</li>
                <li>Inter-process communication is slower and expensive than inter-thread communication.</li>
                <li>Any change in Parent process doesn&#39;t affect the child process whereas changes in parent thread
                    can affect the child thread.</li>
            </ul>

            <p><img alt="Java Multithreading" src="https://www.javatpoint.com/images/java-multithreading.png" /></p>

            <hr />
            <h3>4) What do you understand by inter-thread communication?</h3>

            <ul>
                <li>The process of communication between synchronized threads is termed as inter-thread communication.
                </li>
                <li>Inter-thread communication is used to avoid thread polling in Java.</li>
                <li>The thread is paused running in its critical section, and another thread is allowed to enter (or
                    lock) in the same critical section to be executed.</li>
                <li>It can be obtained by wait(), notify(), and notifyAll() methods.</li>
            </ul>

            <hr />
            <h3>5) What is the purpose of wait() method in Java?</h3>

            <p>The wait() method is provided by the Object class in Java. This method is used for inter-thread
                communication in Java. The java.lang.Object.wait() is used to pause the current thread, and wait until
                another thread does not call the notify() or notifyAll() method. Its syntax is given below.</p>

            <p>public final void wait()</p>

            <hr />
            <h3>6) Why must wait() method be called from the synchronized block?</h3>

            <p>We must call the wait method otherwise it will
                throw&nbsp;<strong>java.lang.IllegalMonitorStateException</strong>&nbsp;exception. Moreover, we need
                wait() method for inter-thread communication with notify() and notifyAll(). Therefore It must be present
                in the synchronized block for the proper and correct communication.</p>

            <hr />
            <h3>7) What are the advantages of multithreading?</h3>

            <p>Multithreading programming has the following advantages:</p>

            <ul>
                <li>Multithreading allows an application/program to be always reactive for input, even already running
                    with some background tasks</li>
                <li>Multithreading allows the faster execution of tasks, as threads execute independently.</li>
                <li>Multithreading provides better utilization of cache memory as threads share the common memory
                    resources.</li>
                <li>Multithreading reduces the number of the required server as one server can execute multiple threads
                    at a time.</li>
            </ul>

            <hr />
            <h3>8) What are the states in the lifecycle of a Thread?</h3>

            <p>A thread can have one of the following states during its lifetime:</p>

            <ol>
                <li><strong>New:</strong>&nbsp;In this state, a Thread class object is created using a new operator, but
                    the thread is not alive. Thread doesn&#39;t start until we call the start() method.</li>
                <li><strong>Runnable:</strong>&nbsp;In this state, the thread is ready to run after calling the start()
                    method. However, the thread is not yet selected by the thread scheduler.</li>
                <li><strong>Running:</strong>&nbsp;In this state, the thread scheduler picks the thread from the ready
                    state, and the thread is running.</li>
                <li><strong>Waiting/Blocked:</strong>&nbsp;In this state, a thread is not running but still alive, or it
                    is waiting for the other thread to finish.</li>
                <li><strong>Dead/Terminated:</strong>&nbsp;A thread is in terminated or dead state when the run() method
                    exits.</li>
            </ol>

            <p><img alt="Java thread life cycle" src="https://www.javatpoint.com/images/thread-life-cycle.png" /></p>

            <hr />
            <h3>9) What is the difference between preemptive scheduling and time slicing?</h3>

            <p>Under preemptive scheduling, the highest priority task executes until it enters the waiting or dead
                states or a higher priority task comes into existence. Under time slicing, a task executes for a
                predefined slice of time and then reenters the pool of ready tasks. The scheduler then determines which
                task should execute next, based on priority and other factors.</p>

            <hr />
            <h3>10) What is context switching?</h3>

            <p>In Context switching the state of the process (or thread) is stored so that it can be restored and
                execution can be resumed from the same point later. Context switching enables the multiple processes to
                share the same CPU.</p>

            <hr />
            <h3>11) Differentiate between the Thread class and Runnable interface for creating a Thread?</h3>

            <p>The Thread can be created by using two ways.</p>

            <p>&nbsp;</p>

            <ul>
                <li>By extending the Thread class</li>
                <li>By implementing the Runnable interface</li>
            </ul>

            <p>However, the primary differences between both the ways are given below:</p>

            <ul>
                <li>By extending the Thread class, we cannot extend any other class, as Java does not allow multiple
                    inheritances while implementing the Runnable interface; we can also extend other base class(if
                    required).</li>
                <li>By extending the Thread class, each of thread creates the unique object and associates with it while
                    implementing the Runnable interface; multiple threads share the same object</li>
                <li>Thread class provides various inbuilt methods such as getPriority(), isAlive and many more while the
                    Runnable interface provides a single method, i.e., run().</li>
            </ul>

            <hr />
            <h3>12) What does join() method?</h3>

            <p>The join() method waits for a thread to die. In other words, it causes the currently running threads to
                stop executing until the thread it joins with completes its task. Join method is overloaded in Thread
                class in the following ways.</p>

            <ul>
                <li>public void join()throws InterruptedException</li>
                <li>public void join(long milliseconds)throws InterruptedException</li>
            </ul>

            <p><a href="https://www.javatpoint.com/join()-method">More details.</a></p>

            <hr />
            <h3>13) Describe the purpose and working of sleep() method.</h3>

            <p>The sleep() method in java is used to block a thread for a particular time, which means it pause the
                execution of a thread for a specific time. There are two methods of doing so.</p>

            <p><strong>Syntax:</strong></p>

            <ul>
                <li>public static void sleep(long milliseconds)throws InterruptedException</li>
                <li>public static void sleep(long milliseconds, int nanos)throws InterruptedException</li>
            </ul>

            <p><strong>Working of sleep() method</strong></p>

            <p>&nbsp;</p>

            <p>When we call the sleep() method, it pauses the execution of the current thread for the given time and
                gives priority to another thread(if available). Moreover, when the waiting time completed then again
                previous thread changes its state from waiting to runnable and comes in running state, and the whole
                process works so on till the execution doesn&#39;t complete.</p>

            <hr />
            <h3>14) What is the difference between wait() and sleep() method?</h3>

            <table>
                <tbody>
                    <tr>
                        <th>wait()</th>
                        <th>sleep()</th>
                    </tr>
                    <tr>
                        <td>1) The wait() method is defined in Object class.</td>
                        <td>The sleep() method is defined in Thread class.</td>
                    </tr>
                    <tr>
                        <td>2) The wait() method releases the lock.</td>
                        <td>The sleep() method doesn&#39;t release the lock.</td>
                    </tr>
                </tbody>
            </table>

            <hr />
            <h3>15) Is it possible to start a thread twice?</h3>

            <p>No, we cannot restart the thread, as once a thread started and executed, it goes to the Dead state.
                Therefore, if we try to start a thread twice, it will give a runtimeException
                &quot;java.lang.IllegalThreadStateException&quot;. Consider the following example.</p>

            <ol start="1">
                <li>public&nbsp;class&nbsp;Multithread1&nbsp;extends&nbsp;Thread&nbsp;&nbsp;</li>
                <li>{&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;run()&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;try&nbsp;{&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(&quot;thread&nbsp;is&nbsp;executing&nbsp;now........&quot;);&nbsp;&nbsp;
                </li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;catch(Exception&nbsp;e)&nbsp;{&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;void&nbsp;main&nbsp;(String[]&nbsp;args)&nbsp;{&nbsp;&nbsp;
                </li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Multithread1&nbsp;m1=&nbsp;new&nbsp;Multithread1();&nbsp;&nbsp;
                </li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;m1.start();&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;m1.start();&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</li>
                <li>}&nbsp;&nbsp;</li>
            </ol>

            <p><strong>Output</strong></p>

            <pre>
thread is executing now........
Exception in thread &quot;main&quot; java.lang.IllegalThreadStateException
	at java.lang.Thread.start(Thread.java:708)
	at Multithread1.main(Multithread1.java:13)
</pre>

            <p><a href="https://www.javatpoint.com/can-we-start-a-thread-twice">More details.</a></p>

            <hr />
            <h3>16) Can we call the run() method instead of start()?</h3>

            <p>Yes, calling run() method directly is valid, but it will not work as a thread instead it will work as a
                normal object. There will not be context-switching between the threads. When we call the start() method,
                it internally calls the run() method, which creates a new stack for a thread while directly calling the
                run() will not create a new stack.</p>

            <p><a href="https://www.javatpoint.com/what-if-we-call-run()-method-directly">More details.</a></p>

            <hr />
            <h3>17) What about the daemon threads?</h3>

            <p>The daemon threads are the low priority threads that provide the background support and services to the
                user threads. Daemon thread gets automatically terminated by the JVM if the program remains with the
                daemon thread only, and all other user threads are ended/died. There are two methods for daemon thread
                available in the Thread class:</p>

            <ul>
                <li><strong>public void setDaemon(boolean status):</strong>&nbsp;It used to mark the thread daemon
                    thread or a user thread.</li>
                <li><strong>public boolean isDaemon():</strong>&nbsp;It checks the thread is daemon or not.</li>
            </ul>

            <p><a href="https://www.javatpoint.com/daemon-thread">More details.</a></p>

            <hr />
            <h3>18)Can we make the user thread as daemon thread if the thread is started?</h3>

            <p>No, if you do so, it will throw IllegalThreadStateException. Therefore, we can only create a daemon
                thread before starting the thread.</p>

            <ol start="1">
                <li>class&nbsp;Testdaemon1&nbsp;extends&nbsp;Thread{&nbsp;&nbsp;&nbsp;&nbsp;</li>
                <li>public&nbsp;void&nbsp;run(){&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(&quot;Running&nbsp;thread&nbsp;is&nbsp;daemon...&quot;);&nbsp;&nbsp;
                </li>
                <li>}&nbsp;&nbsp;</li>
                <li>public&nbsp;static&nbsp;void&nbsp;main&nbsp;(String[]&nbsp;args)&nbsp;{&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Testdaemon1&nbsp;td=&nbsp;new&nbsp;Testdaemon1();&nbsp;&nbsp;
                </li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;td.start();&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;setDaemon(true);//&nbsp;It&nbsp;will&nbsp;throw&nbsp;the&nbsp;exception:&nbsp;td.&nbsp;&nbsp;&nbsp;
                </li>
                <li>&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</li>
                <li>}&nbsp;&nbsp;</li>
            </ol>

            <p><strong>Output</strong></p>

            <pre>
Running thread is daemon...
Exception in thread &quot;main&quot; java.lang.IllegalThreadStateException
at java.lang.Thread.setDaemon(Thread.java:1359)
at Testdaemon1.main(Testdaemon1.java:8)
</pre>

            <p><a href="https://www.javatpoint.com/daemon-thread">More details.</a></p>

            <hr />
            <h3>19)What is shutdown hook?</h3>

            <p>The shutdown hook is a thread that is invoked implicitly before JVM shuts down. So we can use it to
                perform clean up the resource or save the state when JVM shuts down normally or abruptly. We can add
                shutdown hook by using the following method:</p>

            <ol start="1">
                <li>public&nbsp;void&nbsp;addShutdownHook(Thread&nbsp;hook){}&nbsp;&nbsp;&nbsp;&nbsp;</li>
                <li>Runtime&nbsp;r=Runtime.getRuntime();&nbsp;&nbsp;</li>
                <li>r.addShutdownHook(new&nbsp;MyThread());&nbsp;&nbsp;</li>
            </ol>

            <p>Some important points about shutdown hooks are :</p>

            <ul>
                <li>Shutdown hooks initialized but can only be started when JVM shutdown occurred.</li>
                <li>Shutdown hooks are more reliable than the finalizer() because there are very fewer chances that
                    shutdown hooks not run.</li>
                <li>The shutdown hook can be stopped by calling the halt(int) method of Runtime class.</li>
            </ul>

            <p><a href="https://www.javatpoint.com/ShutdownHook-thread">More details.</a></p>

            <hr />
            <h3>20)When should we interrupt a thread?</h3>

            <p>We should interrupt a thread when we want to break out the sleep or wait state of a thread. We can
                interrupt a thread by calling the interrupt()&nbsp;throwing the InterruptedException.</p>

            <p><a href="https://www.javatpoint.com/interrupting-a-thread">More details.</a></p>

            <hr />
            <h3>21) What is the synchronization?</h3>

            <p>Synchronization is the capability to control the access of multiple threads to any shared resource. It is
                used:</p>

            <hr />
            <ol>
                <li>To prevent thread interference.</li>
                <li>To prevent consistency problem.</li>
            </ol>

            <p>When the multiple threads try to do the same task, there is a possibility of an erroneous&nbsp;result,
                hence to remove this issue, Java uses the process of synchronization which allows only one thread to be
                executed at a time. Synchronization can be achieved in three ways:</p>

            <p>&nbsp;</p>

            <ul>
                <li>by the synchronized method</li>
                <li>by synchronized block</li>
                <li>by static synchronization</li>
            </ul>

            <p>Syntax for synchronized block</p>

            <ol start="1">
                <li>synchronized(object&nbsp;reference&nbsp;expression)&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//code&nbsp;block&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</li>
            </ol>

            <p><a href="https://www.javatpoint.com/synchronization">More details.</a></p>

            <hr />
            <h3>22) What is the purpose of the Synchronized block?</h3>

            <p>The Synchronized block can be used to perform synchronization on any specific resource of the method.
                Only one thread at a time can execute on a particular resource, and all other threads which attempt to
                enter the synchronized block are blocked.</p>

            <ul>
                <li>Synchronized block is used to lock an object for any shared resource.</li>
                <li>The scope of the synchronized block is limited to the block on which, it is applied. Its scope is
                    smaller than a method.</li>
            </ul>

            <p><a href="https://www.javatpoint.com/synchronized-block-example">More details.</a></p>

            <hr />
            <h3>23)Can Java object be locked down for exclusive use by a given thread?</h3>

            <p>Yes. You can lock an object by putting it in a &quot;synchronized&quot; block. The locked object is
                inaccessible to any thread other than the one that explicitly claimed it.</p>

            <hr />
            <h3>24) What is static synchronization?</h3>

            <p>If you make any static method as synchronized, the lock will be on the class not on the object. If we use
                the synchronized keyword before a method so it will lock the object (one thread can access an object at
                a time) but if we use static synchronized so it will lock a class (one thread can access a class at a
                time).&nbsp;<a href="https://www.javatpoint.com/static-synchronization-example">More details.</a></p>

            <hr />
            <h3>25)What is the difference between notify() and notifyAll()?</h3>

            <p>The notify() is used to unblock one waiting thread whereas notifyAll() method is used to unblock all the
                threads in waiting state.</p>

            <hr />
            <h3>26)What is the deadlock?</h3>

            <p>Deadlock is a situation in which every thread is waiting for a resource which is held by some other
                waiting thread. In this situation, Neither of the thread executes nor it gets the chance to be executed.
                Instead, there exists a universal waiting state among all the threads. Deadlock is a very complicated
                situation which can break our code at runtime.</p>

            <p><a href="https://www.javatpoint.com/deadlock-in-java">More details.</a></p>

            <hr />
            <h3>27) How to detect a deadlock condition? How can it be avoided?</h3>

            <p>We can detect the deadlock condition by running the code on cmd and collecting the Thread Dump, and if
                any deadlock is present in the code, then a message will appear on cmd.</p>

            <p><strong>Ways to avoid the deadlock condition in Java:</strong></p>

            <ul>
                <li><strong>Avoid Nested lock:</strong>&nbsp;Nested lock is the common reason for deadlock as deadlock
                    occurs when we provide locks to various threads so we should give one lock to only one thread at
                    some particular time.</li>
                <li><strong>Avoid unnecessary locks:</strong>&nbsp;we must avoid the locks which are not required.</li>
                <li><strong>Using thread join:</strong>&nbsp;Thread join helps to wait for a thread until another thread
                    doesn&#39;t finish its execution so we can avoid deadlock by maximum use of join method.</li>
            </ul>

            <hr />
            <h3>28) What is Thread Scheduler in java?</h3>

            <p>In Java, when we create the threads, they are supervised with the help of a Thread Scheduler, which is
                the part of JVM. Thread scheduler is only responsible for deciding which thread should be executed.
                Thread scheduler uses two mechanisms for scheduling the threads: Preemptive and Time Slicing.</p>

            <p>Java thread scheduler also works for deciding the following for a thread:</p>

            <ul>
                <li>It selects the priority of the thread.</li>
                <li>It determines the waiting time for a thread</li>
                <li>It checks the Nature of thread</li>
            </ul>

            <hr />
            <h3>29) Does each thread have its stack in multithreaded programming?</h3>

            <p>Yes, in multithreaded programming every thread maintains its own or separate stack area in memory due to
                which every thread is independent of each other.</p>

            <hr />
            <h3>30) How is the safety of a thread achieved?</h3>

            <p>If a method or class object can be used by multiple threads at a time without any race condition, then
                the class is thread-safe. Thread safety is used to make a program safe to use in multithreaded
                programming. It can be achieved by the following ways:</p>

            <ul>
                <li>Synchronization</li>
                <li>Using Volatile keyword</li>
                <li>Using a lock based mechanism</li>
                <li>Use of atomic wrapper classes</li>
            </ul>

            <hr />
            <h3>31) What is race-condition?</h3>

            <p>A Race condition is a problem which occurs in the multithreaded programming when various threads execute
                simultaneously accessing a shared resource at the same time. The proper use of synchronization can avoid
                the Race condition.</p>

            <hr />
            <h3>32) What is the volatile keyword in java?</h3>

            <p>Volatile keyword is used in multithreaded programming to achieve the thread safety, as a change in one
                volatile variable is visible to all other threads so one variable can be used by one thread at a time.
            </p>

            <hr />
            <h3>33) What do you understand by thread pool?</h3>

            <ul>
                <li>Java Thread pool represents a group of worker threads, which are waiting for the task to be
                    allocated.</li>
                <li>Threads in the thread pool are supervised by the service provider which pulls one thread from the
                    pool and assign a job to it.</li>
                <li>After completion of the given task, thread again came to the thread pool.</li>
                <li>The size of the thread pool depends on the total number of threads kept at reserve for execution.
                </li>
            </ul>

            <p>The advantages of the thread pool are :</p>

            <ul>
                <li>Using a thread pool, performance can be enhanced.</li>
                <li>Using a thread pool, better system stability can occur.</li>
            </ul>

            <hr />
            <h2>Concurrency Interview Questions</h2>

            <h3>34) What are the main components of concurrency API?</h3>

            <p>Concurrency API can be developed using the class and interfaces of java.util.Concurrent package. There
                are the following classes and interfaces in java.util.Concurrent package.</p>

            <ul>
                <li>Executor</li>
                <li>FarkJoinPool</li>
                <li>ExecutorService</li>
                <li>ScheduledExecutorService</li>
                <li>Future</li>
                <li>TimeUnit(Enum)</li>
                <li>CountDownLatch</li>
                <li>CyclicBarrier</li>
                <li>Semaphore</li>
                <li>ThreadFactory</li>
                <li>BlockingQueue</li>
                <li>DelayQueue</li>
                <li>Locks</li>
                <li>Phaser</li>
            </ul>

            <hr />
            <h3>35) What is the Executor interface in Concurrency API in Java?</h3>

            <p>The Executor Interface provided by the package java.util.concurrent is the simple interface used to
                execute the new task. The execute() method of Executor interface is used to execute some given command.
                The syntax of the execute() method is given below.</p>

            <p><strong>void execute(Runnable command)</strong></p>

            <p>Consider the following example:</p>

            <ol start="1">
                <li>import&nbsp;java.util.concurrent.Executor;&nbsp;&nbsp;</li>
                <li>import&nbsp;java.util.concurrent.Executors;&nbsp;&nbsp;</li>
                <li>import&nbsp;java.util.concurrent.ThreadPoolExecutor;&nbsp;&nbsp;</li>
                <li>import&nbsp;java.util.concurrent.TimeUnit;&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;</li>
                <li>public&nbsp;class&nbsp;TestThread&nbsp;{&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;void&nbsp;main(final&nbsp;String[]&nbsp;arguments)&nbsp;throws&nbsp;InterruptedException&nbsp;{&nbsp;&nbsp;
                </li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Executor&nbsp;e&nbsp;=&nbsp;Executors.newCachedThreadPool();&nbsp;&nbsp;
                </li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;e.execute(new&nbsp;Thread());&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ThreadPoolExecutor&nbsp;pool&nbsp;=&nbsp;(ThreadPoolExecutor)e;&nbsp;&nbsp;
                </li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pool.shutdown();&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;static&nbsp;class&nbsp;Thread&nbsp;implements&nbsp;Runnable&nbsp;{&nbsp;&nbsp;
                </li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;run()&nbsp;{&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;try&nbsp;{&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Long&nbsp;duration&nbsp;=&nbsp;(long)&nbsp;(Math.random()&nbsp;*&nbsp;5);&nbsp;&nbsp;
                </li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(&quot;Running&nbsp;Thread!&quot;);&nbsp;&nbsp;
                </li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;TimeUnit.SECONDS.sleep(duration);&nbsp;&nbsp;
                </li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(&quot;Thread&nbsp;Completed&quot;);&nbsp;&nbsp;
                </li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;catch&nbsp;(InterruptedException&nbsp;ex)&nbsp;{&nbsp;&nbsp;
                </li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ex.printStackTrace();&nbsp;&nbsp;
                </li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</li>
                <li>}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</li>
            </ol>

            <p><strong>Output</strong></p>

            <pre>
Running Thread!
Thread Completed
</pre>

            <hr />
            <h3>36) What is BlockingQueue?</h3>

            <p>The java.util.concurrent.BlockingQueue is the subinterface of Queue that supports the operations such as
                waiting for the space availability before inserting a new value or waiting for the queue to become
                non-empty before retrieving an element from it. Consider the following example.</p>

            <ol start="1">
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</li>
                <li>import&nbsp;java.util.Random;&nbsp;&nbsp;</li>
                <li>import&nbsp;java.util.concurrent.ArrayBlockingQueue;&nbsp;&nbsp;</li>
                <li>import&nbsp;java.util.concurrent.BlockingQueue;&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;</li>
                <li>public&nbsp;class&nbsp;TestThread&nbsp;{&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;void&nbsp;main(final&nbsp;String[]&nbsp;arguments)&nbsp;throws&nbsp;InterruptedException&nbsp;{&nbsp;&nbsp;
                </li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;BlockingQueue&lt;Integer&gt;&nbsp;queue&nbsp;=&nbsp;new&nbsp;ArrayBlockingQueue&lt;Integer&gt;(10);&nbsp;&nbsp;
                </li>
                <li>&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Insert&nbsp;i&nbsp;=&nbsp;new&nbsp;Insert(queue);&nbsp;&nbsp;
                </li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Retrieve&nbsp;r&nbsp;=&nbsp;new&nbsp;Retrieve(queue);&nbsp;&nbsp;
                </li>
                <li>&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;new&nbsp;Thread(i).start();&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;new&nbsp;Thread(r).start();&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Thread.sleep(2000);&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;static&nbsp;class&nbsp;Insert&nbsp;implements&nbsp;Runnable&nbsp;{&nbsp;&nbsp;
                </li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;private&nbsp;BlockingQueue&lt;Integer&gt;&nbsp;queue;&nbsp;&nbsp;
                </li>
                <li>&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;Insert(BlockingQueue&nbsp;queue)&nbsp;{&nbsp;&nbsp;
                </li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.queue&nbsp;=&nbsp;queue;&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;@Override&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;run()&nbsp;{&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Random&nbsp;random&nbsp;=&nbsp;new&nbsp;Random();&nbsp;&nbsp;
                </li>
                <li>&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;try&nbsp;{&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;result&nbsp;=&nbsp;random.nextInt(200);&nbsp;&nbsp;
                </li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Thread.sleep(1000);&nbsp;&nbsp;
                </li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;queue.put(result);&nbsp;&nbsp;
                </li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(&quot;Added:&nbsp;&quot;&nbsp;+&nbsp;result);&nbsp;&nbsp;
                </li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;result&nbsp;=&nbsp;random.nextInt(10);&nbsp;&nbsp;
                </li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Thread.sleep(1000);&nbsp;&nbsp;
                </li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;queue.put(result);&nbsp;&nbsp;
                </li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(&quot;Added:&nbsp;&quot;&nbsp;+&nbsp;result);&nbsp;&nbsp;
                </li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;result&nbsp;=&nbsp;random.nextInt(50);&nbsp;&nbsp;
                </li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Thread.sleep(1000);&nbsp;&nbsp;
                </li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;queue.put(result);&nbsp;&nbsp;
                </li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(&quot;Added:&nbsp;&quot;&nbsp;+&nbsp;result);&nbsp;&nbsp;
                </li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;catch&nbsp;(InterruptedException&nbsp;e)&nbsp;{&nbsp;&nbsp;
                </li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;e.printStackTrace();&nbsp;&nbsp;
                </li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;static&nbsp;class&nbsp;Retrieve&nbsp;implements&nbsp;Runnable&nbsp;{&nbsp;&nbsp;
                </li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;private&nbsp;BlockingQueue&lt;Integer&gt;&nbsp;queue;&nbsp;&nbsp;
                </li>
                <li>&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;Retrieve(BlockingQueue&nbsp;queue)&nbsp;{&nbsp;&nbsp;
                </li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.queue&nbsp;=&nbsp;queue;&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;@Override&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;run()&nbsp;{&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;try&nbsp;{&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(&quot;Removed:&nbsp;&quot;&nbsp;+&nbsp;queue.take());&nbsp;&nbsp;
                </li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(&quot;Removed:&nbsp;&quot;&nbsp;+&nbsp;queue.take());&nbsp;&nbsp;
                </li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(&quot;Removed:&nbsp;&quot;&nbsp;+&nbsp;queue.take());&nbsp;&nbsp;
                </li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;catch&nbsp;(InterruptedException&nbsp;e)&nbsp;{&nbsp;&nbsp;
                </li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;e.printStackTrace();&nbsp;&nbsp;
                </li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</li>
                <li>}&nbsp;&nbsp;</li>
            </ol>

            <p><strong>Output</strong></p>

            <pre>
Added: 96
Removed: 96
Added: 8
Removed: 8
Added: 5
Removed: 5
</pre>

            <hr />
            <h3>37) How to implement producer-consumer problem by using BlockingQueue?</h3>

            <p>The producer-consumer problem can be solved by using BlockingQueue in the following way.</p>

            <ol start="1">
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</li>
                <li>import&nbsp;java.util.concurrent.BlockingQueue;&nbsp;&nbsp;</li>
                <li>import&nbsp;java.util.concurrent.LinkedBlockingQueue;&nbsp;&nbsp;</li>
                <li>import&nbsp;java.util.logging.Level;&nbsp;&nbsp;</li>
                <li>import&nbsp;java.util.logging.Logger;&nbsp;&nbsp;</li>
                <li>public&nbsp;class&nbsp;ProducerConsumerProblem&nbsp;{&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;void&nbsp;main(String&nbsp;args[]){&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//Creating&nbsp;shared&nbsp;object&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;BlockingQueue&nbsp;sharedQueue&nbsp;=&nbsp;new&nbsp;LinkedBlockingQueue();&nbsp;&nbsp;
                </li>
                <li>&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//Creating&nbsp;Producer&nbsp;and&nbsp;Consumer&nbsp;Thread&nbsp;&nbsp;
                </li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Thread&nbsp;prod&nbsp;=&nbsp;new&nbsp;Thread(new&nbsp;Producer(sharedQueue));&nbsp;&nbsp;
                </li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Thread&nbsp;cons&nbsp;=&nbsp;new&nbsp;Thread(new&nbsp;Consumer(sharedQueue));&nbsp;&nbsp;
                </li>
                <li>&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//Starting&nbsp;producer&nbsp;and&nbsp;Consumer&nbsp;thread&nbsp;&nbsp;
                </li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;prod.start();&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cons.start();&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;</li>
                <li>}&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;</li>
                <li>//Producer&nbsp;Class&nbsp;in&nbsp;java&nbsp;&nbsp;</li>
                <li>class&nbsp;Producer&nbsp;implements&nbsp;Runnable&nbsp;{&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;private&nbsp;final&nbsp;BlockingQueue&nbsp;sharedQueue;&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;Producer(BlockingQueue&nbsp;sharedQueue)&nbsp;{&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.sharedQueue&nbsp;=&nbsp;sharedQueue;&nbsp;&nbsp;
                </li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;@Override&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;run()&nbsp;{&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for(int&nbsp;i=0;&nbsp;i&lt;10;&nbsp;i++){&nbsp;&nbsp;
                </li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;try&nbsp;{&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(&quot;Produced:&nbsp;&quot;&nbsp;+&nbsp;i);&nbsp;&nbsp;
                </li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sharedQueue.put(i);&nbsp;&nbsp;
                </li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;catch&nbsp;(InterruptedException&nbsp;ex)&nbsp;{&nbsp;&nbsp;
                </li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Logger.getLogger(Producer.class.getName()).log(Level.SEVERE,&nbsp;null,&nbsp;ex);&nbsp;&nbsp;
                </li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;</li>
                <li>}&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;</li>
                <li>//Consumer&nbsp;Class&nbsp;in&nbsp;Java&nbsp;&nbsp;</li>
                <li>class&nbsp;Consumer&nbsp;implements&nbsp;Runnable{&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;private&nbsp;final&nbsp;BlockingQueue&nbsp;sharedQueue;&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;Consumer&nbsp;(BlockingQueue&nbsp;sharedQueue)&nbsp;{&nbsp;&nbsp;
                </li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.sharedQueue&nbsp;=&nbsp;sharedQueue;&nbsp;&nbsp;
                </li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;@Override&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;run()&nbsp;{&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;while(true){&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;try&nbsp;{&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(&quot;Consumed:&nbsp;&quot;+&nbsp;sharedQueue.take());&nbsp;&nbsp;
                </li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;catch&nbsp;(InterruptedException&nbsp;ex)&nbsp;{&nbsp;&nbsp;
                </li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Logger.getLogger(Consumer.class.getName()).log(Level.SEVERE,&nbsp;null,&nbsp;ex);&nbsp;&nbsp;
                </li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</li>
                <li>}&nbsp;&nbsp;</li>
            </ol>

            <p><strong>Output</strong></p>

            <pre>
Produced: 0
Produced: 1
Produced: 2
Produced: 3
Produced: 4
Produced: 5
Produced: 6
Produced: 7
Produced: 8
Produced: 9
Consumed: 0
Consumed: 1
Consumed: 2
Consumed: 3
Consumed: 4
Consumed: 5
Consumed: 6
Consumed: 7
Consumed: 8
Consumed: 9
</pre>

            <hr />
            <h3>38) What is the difference between Java Callable interface and Runnable interface?</h3>

            <p>The Callable interface and Runnable interface both are used by the classes which wanted to execute with
                multiple threads. However, there are two main differences between the both :</p>

            <ul>
                <li>A Callable &lt;V&gt; interface can return a result, whereas the Runnable interface cannot return any
                    result.</li>
                <li>A Callable &lt;V&gt; interface can throw a checked exception, whereas the Runnable interface cannot
                    throw checked exception.</li>
                <li>A Callable &lt;V&gt; interface cannot be used before the Java 5 whereas the Runnable interface can
                    be used.</li>
            </ul>

            <hr />
            <h3>39) What is the Atomic action in Concurrency in Java?</h3>

            <ul>
                <li>The Atomic action is the operation which can be performed in a single unit of a task without any
                    interference of the other operations.</li>
                <li>The Atomic action cannot be stopped in between the task. Once started it fill stop after the
                    completion of the task only.</li>
                <li>An increment operation such as a++ does not allow an atomic action.</li>
                <li>All reads and writes operation for the primitive variable (except long and double) are the atomic
                    operation.</li>
                <li>All reads and writes operation for the volatile variable (including long and double) are the atomic
                    operation.</li>
                <li>The Atomic methods are available in java.util.Concurrent package.</li>
            </ul>

            <hr />
            <h3>40) What is lock interface in Concurrency API in Java?</h3>

            <p>The java.util.concurrent.locks.Lock interface is used as the synchronization mechanism. It works similar
                to the synchronized block. There are a few differences between the lock and synchronized block that are
                given below.</p>

            <ul>
                <li>Lock interface provides the guarantee of sequence in which the waiting thread will be given the
                    access, whereas the synchronized block doesn&#39;t guarantee it.</li>
                <li>Lock interface provides the option of timeout if the lock is not granted whereas the synchronized
                    block doesn&#39;t provide that.</li>
                <li>The methods of Lock interface, i.e., Lock() and Unlock() can be called in different methods whereas
                    single synchronized block must be fully contained in a single method.</li>
            </ul>

            <hr />
            <h3>41) Explain the ExecutorService Interface.</h3>

            <p>The ExecutorService Interface is the subinterface of Executor interface and adds the features to manage
                the lifecycle. Consider the following example.</p>

            <p>&nbsp;</p>

            <ol start="1">
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</li>
                <li>import&nbsp;java.util.concurrent.ExecutorService;&nbsp;&nbsp;</li>
                <li>import&nbsp;java.util.concurrent.Executors;&nbsp;&nbsp;</li>
                <li>import&nbsp;java.util.concurrent.TimeUnit;&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;</li>
                <li>public&nbsp;class&nbsp;TestThread&nbsp;{&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;void&nbsp;main(final&nbsp;String[]&nbsp;arguments)&nbsp;throws&nbsp;InterruptedException&nbsp;{&nbsp;&nbsp;
                </li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ExecutorService&nbsp;e&nbsp;=&nbsp;Executors.newSingleThreadExecutor();&nbsp;&nbsp;
                </li>
                <li>&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;try&nbsp;{&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;e.submit(new&nbsp;Thread());&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(&quot;Shutdown&nbsp;executor&quot;);&nbsp;&nbsp;
                </li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;e.shutdown();&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;e.awaitTermination(5,&nbsp;TimeUnit.SECONDS);&nbsp;&nbsp;
                </li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;catch&nbsp;(InterruptedException&nbsp;ex)&nbsp;{&nbsp;&nbsp;
                </li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.err.println(&quot;tasks&nbsp;interrupted&quot;);&nbsp;&nbsp;
                </li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;finally&nbsp;{&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(!e.isTerminated())&nbsp;{&nbsp;&nbsp;
                </li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.err.println(&quot;cancel&nbsp;non-finished&nbsp;tasks&quot;);&nbsp;&nbsp;
                </li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;e.shutdownNow();&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(&quot;shutdown&nbsp;finished&quot;);&nbsp;&nbsp;
                </li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;static&nbsp;class&nbsp;Task&nbsp;implements&nbsp;Runnable&nbsp;{&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;run()&nbsp;{&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;try&nbsp;{&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Long&nbsp;duration&nbsp;=&nbsp;(long)&nbsp;(Math.random()&nbsp;*&nbsp;20);&nbsp;&nbsp;
                </li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(&quot;Running&nbsp;Task!&quot;);&nbsp;&nbsp;
                </li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;TimeUnit.SECONDS.sleep(duration);&nbsp;&nbsp;
                </li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;catch&nbsp;(InterruptedException&nbsp;ex)&nbsp;{&nbsp;&nbsp;
                </li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ex.printStackTrace();&nbsp;&nbsp;
                </li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</li>
                <li>}&nbsp;&nbsp;</li>
            </ol>

            <p><strong>Output</strong></p>

            <pre>
Shutdown executor
shutdown finished
</pre>

            <hr />
            <h3>42) What is the difference between Synchronous programming and Asynchronous programming regarding a
                thread?</h3>

            <p><strong>Synchronous programming:&nbsp;</strong>In Synchronous programming model, a thread is assigned to
                complete a task and hence thread started working on it, and it is only available for other tasks once it
                will end the assigned task.</p>

            <p><strong>Asynchronous Programming:&nbsp;</strong>In Asynchronous programming, one job can be completed by
                multiple threads and hence it provides maximum usability of the various threads.</p>

            <hr />
            <h3>43) What do you understand by Callable and Future in Java?</h3>

            <p><strong>Java Callable interface:&nbsp;</strong>In Java5 callable interface was provided by the package
                java.util.concurrent. It is similar to the Runnable interface but it can return a result, and it can
                throw an Exception. It also provides a run() method for execution of a thread. Java Callable can return
                any object as it uses Generic.</p>

            <p><strong>Syntax:</strong></p>

            <p>public interface Callable&lt;V&gt;</p>

            <p><strong>Java Future interface:</strong>&nbsp;Java Future interface gives the result of a concurrent
                process. The Callable interface returns the object of java.util.concurrent.Future.</p>

            <p>Java Future provides following methods for implementation.</p>

            <ul>
                <li><strong>cancel(boolean&nbsp;mayInterruptIfRunning):</strong>&nbsp;It is used to cancel the execution
                    of the assigned task.</li>
                <li><strong>get():</strong>&nbsp;It waits for the time if execution not completed and then retrieved the
                    result.</li>
                <li><strong>isCancelled():</strong>&nbsp;It returns the Boolean value as it returns true if the task was
                    canceled before the completion.</li>
                <li><strong>isDone():</strong>&nbsp;It returns true if the job is completed successfully else returns
                    false.</li>
            </ul>

            <hr />
            <h3>44. What is the difference between ScheduledExecutorService and ExecutorService interface?</h3>

            <p>ExecutorServcie and ScheduledExecutorService both are the interfaces of java.util.Concurrent package but
                scheduledExecutorService provides some additional methods to execute the Runnable and Callable tasks
                with the delay or every fixed time period.</p>

            <h3>45) Define FutureTask class in Java?</h3>

            <p>Java FutureTask class provides a base implementation of the Future interface. The result can only be
                obtained if the execution of one task is completed, and if the computation is not achieved then get
                method will be blocked. If the execution is completed, then it cannot be re-started and can&#39;t be
                canceled.</p>

            <p><strong>Syntax</strong></p>

            <p>public class FutureTask&lt;V&gt; extends Object implements RunnableFuture&lt;V&gt;</p>

        </div>

        <div class="box-prem">
            <h1>34 Java Collections Interview Questions</h1>

            <p>In Java, collection interview questions are most asked by the interviewers. Here is the list of the most
                asked collections interview questions with answers.</p>

            <hr />
            <h3>1) What is the Collection framework in Java?</h3>

            <p>Collection Framework is a combination of classes and interface, which is used to store and manipulate the
                data in the form of objects. It provides various classes such as ArrayList, Vector, Stack, and HashSet,
                etc. and interfaces such as List, Queue, Set, etc. for this purpose.</p>

            <hr />
            <h3>2) What are the main differences between array and collection?</h3>

            <p>Array and Collection are somewhat similar regarding storing the references of objects and manipulating
                the data, but they differ in many ways. The main differences between the array and Collection are
                defined below:</p>

            <ul>
                <li>Arrays are always of fixed size, i.e., a user can not increase or decrease the length of the array
                    according to their requirement or at runtime, but In Collection, size can be changed dynamically as
                    per need.</li>
                <li>Arrays can only store homogeneous or similar type objects, but in Collection, heterogeneous objects
                    can be stored.</li>
                <li>Arrays cannot provide the ?ready-made? methods for user requirements as sorting, searching, etc. but
                    Collection includes readymade methods to use.</li>
            </ul>

            <hr />
            <h3>3) Explain various interfaces used in Collection framework?</h3>

            <p>Collection framework implements various interfaces, Collection interface and Map interface
                (java.util.Map) are the mainly used interfaces of Java Collection Framework. List of interfaces of
                Collection Framework is given below:</p>

            <p><strong>1. Collection interface:</strong>&nbsp;Collection (java.util.Collection) is the primary
                interface, and every collection must implement this interface.</p>

            <p><strong>Syntax:</strong></p>

            <ol start="1">
                <li>public&nbsp;interface&nbsp;Collection&lt;E&gt;extends&nbsp;Iterable&nbsp;&nbsp;</li>
            </ol>

            <p>Where &lt;E&gt; represents that this interface is of Generic type</p>

            <p><strong>2. List interface:&nbsp;</strong>List interface extends the Collection interface, and it is an
                ordered collection of objects. It contains duplicate elements. It also allows random access of elements.
            </p>

            <p><strong>Syntax:</strong></p>

            <ol start="1">
                <li>public&nbsp;interface&nbsp;List&lt;E&gt;&nbsp;extends&nbsp;Collection&lt;E&gt;&nbsp;&nbsp;</li>
            </ol>

            <p><strong>3. Set interface:</strong>&nbsp;Set (java.util.Set) interface is a collection which cannot
                contain duplicate elements. It can only include inherited methods of Collection interface</p>

            <p><strong>Syntax:</strong></p>

            <ol start="1">
                <li>public&nbsp;interface&nbsp;Set&lt;E&gt;&nbsp;extends&nbsp;Collection&lt;E&gt;&nbsp;&nbsp;</li>
            </ol>

            <p><strong>Queue interface:&nbsp;</strong>Queue (java.util.Queue) interface defines queue data structure,
                which stores the elements in the form FIFO (first in first out).</p>

            <p>&nbsp;</p>

            <p><strong>Syntax:</strong></p>

            <ol start="1">
                <li>public&nbsp;interface&nbsp;Queue&lt;E&gt;&nbsp;extends&nbsp;Collection&lt;E&gt;&nbsp;&nbsp;</li>
            </ol>

            <p><strong>4. Dequeue interface:</strong>&nbsp;it is a double-ended-queue. It allows the insertion and
                removal of elements from both ends. It implants the properties of both Stack and queue so it can perform
                LIFO (Last in first out) stack and FIFO (first in first out) queue, operations.</p>

            <p><strong>Syntax:</strong></p>

            <ol start="1">
                <li>public&nbsp;interface&nbsp;Dequeue&lt;E&gt;&nbsp;extends&nbsp;Queue&lt;E&gt;&nbsp;&nbsp;</li>
            </ol>

            <p><strong>5. Map interface:&nbsp;</strong>A Map (java.util.Map) represents a key, value pair storage of
                elements. Map interface does not implement the Collection interface. It can only contain a unique key
                but can have duplicate elements. There are two interfaces which implement Map in java that are Map
                interface and Sorted Map.</p>

            <hr />
            <h3>4) What is the difference between ArrayList and Vector?</h3>

            <table>
                <tbody>
                    <tr>
                        <th>No.</th>
                        <th>ArrayList</th>
                        <th>Vector</th>
                    </tr>
                    <tr>
                        <td>1)</td>
                        <td>ArrayList is not synchronized.</td>
                        <td>Vector is synchronized.</td>
                    </tr>
                    <tr>
                        <td>2)</td>
                        <td>ArrayList is not a legacy class.</td>
                        <td>Vector is a legacy class.</td>
                    </tr>
                    <tr>
                        <td>3)</td>
                        <td>ArrayList increases its size by 50% of the array size.</td>
                        <td>Vector increases its size by doubling the array size.</td>
                    </tr>
                    <tr>
                        <td>4)</td>
                        <td>ArrayList is not ?thread-safe? as it is not synchronized.</td>
                        <td>Vector list is ?thread-safe? as it?s every method is synchronized.</td>
                    </tr>
                </tbody>
            </table>

            <hr />
            <h3>5) What is the difference between ArrayList and LinkedList?</h3>

            <table>
                <tbody>
                    <tr>
                        <th>No.</th>
                        <th>ArrayList</th>
                        <th>LinkedList</th>
                    </tr>
                    <tr>
                        <td>1)</td>
                        <td>ArrayList uses a dynamic array.</td>
                        <td>LinkedList uses a doubly linked list.</td>
                    </tr>
                    <tr>
                        <td>2)</td>
                        <td>ArrayList is not efficient for manipulation because too much is required.</td>
                        <td>LinkedList is efficient for manipulation.</td>
                    </tr>
                    <tr>
                        <td>3)</td>
                        <td>ArrayList is better to store and fetch data.</td>
                        <td>LinkedList is better to manipulate data.</td>
                    </tr>
                    <tr>
                        <td>4)</td>
                        <td>ArrayList provides random access.</td>
                        <td>LinkedList does not provide random access.</td>
                    </tr>
                    <tr>
                        <td>5)</td>
                        <td>ArrayList takes less memory overhead as it stores only object</td>
                        <td>LinkedList takes more memory overhead, as it stores the object as well as the address of
                            that object.</td>
                    </tr>
                </tbody>
            </table>

            <hr />
            <h3>6) What is the difference between Iterator and ListIterator?</h3>

            <p>Iterator traverses the elements in the forward direction only whereas ListIterator traverses the elements
                into forward and backward direction.</p>

            <p>&nbsp;</p>

            <table>
                <tbody>
                    <tr>
                        <th>No.</th>
                        <th>Iterator</th>
                        <th>ListIterator</th>
                    </tr>
                    <tr>
                        <td>1)</td>
                        <td>The Iterator traverses the elements in the forward direction only.</td>
                        <td>ListIterator traverses the elements in backward and forward directions both.</td>
                    </tr>
                    <tr>
                        <td>2)</td>
                        <td>The Iterator can be used in List, Set, and Queue.</td>
                        <td>ListIterator can be used in List only.</td>
                    </tr>
                    <tr>
                        <td>3)</td>
                        <td>The Iterator can only perform remove operation while traversing the collection.</td>
                        <td>ListIterator can perform ?add,? ?remove,? and ?set? operation while traversing the
                            collection.</td>
                    </tr>
                </tbody>
            </table>

            <hr />
            <h3>7) What is the difference between Iterator and Enumeration?</h3>

            <table>
                <tbody>
                    <tr>
                        <th>No.</th>
                        <th>Iterator</th>
                        <th>Enumeration</th>
                    </tr>
                    <tr>
                        <td>1)</td>
                        <td>The Iterator can traverse legacy and non-legacy elements.</td>
                        <td>Enumeration can traverse only legacy elements.</td>
                    </tr>
                    <tr>
                        <td>2)</td>
                        <td>The Iterator is fail-fast.</td>
                        <td>Enumeration is not fail-fast.</td>
                    </tr>
                    <tr>
                        <td>3)</td>
                        <td>The Iterator is slower than Enumeration.</td>
                        <td>Enumeration is faster than Iterator.</td>
                    </tr>
                    <tr>
                        <td>4)</td>
                        <td>The Iterator can perform remove operation while traversing the collection.</td>
                        <td>The Enumeration can perform only traverse operation on the collection.</td>
                    </tr>
                </tbody>
            </table>

            <hr />
            <h3>8) What is the difference between List and Set?</h3>

            <p>The List and Set both extend the collection interface. However, there are some differences between the
                both which are listed below.</p>

            <ul>
                <li>The List can contain duplicate elements whereas Set includes unique items.</li>
                <li>The List is an ordered collection which maintains the insertion order whereas Set is an unordered
                    collection which does not preserve the insertion order.</li>
                <li>The List interface contains a single legacy class which is Vector class whereas Set interface does
                    not have any legacy class.</li>
                <li>The List interface can allow n number of null values whereas Set interface only allows a single null
                    value.</li>
            </ul>

            <hr />
            <h3>9) What is the difference between HashSet and TreeSet?</h3>

            <p>The HashSet and TreeSet, both classes, implement Set interface. The differences between the both are
                listed below.</p>

            <ul>
                <li>HashSet maintains&nbsp;no order&nbsp;whereas TreeSet maintains&nbsp;ascending order.</li>
                <li>HashSet impended by hash table whereas TreeSet implemented by a Tree structure.</li>
                <li>HashSet performs faster than TreeSet.</li>
                <li>HashSet is backed by HashMap whereas TreeSet is backed by TreeMap.</li>
            </ul>

            <hr />
            <h3>10) What is the difference between Set and Map?</h3>

            <p>The differences between the Set and Map are given below.</p>

            <ul>
                <li>Set contains values only whereas Map contains key and values both.</li>
                <li>Set contains unique values whereas Map can contain unique Keys with duplicate values.</li>
                <li>Set holds a single number of null value whereas Map can include a single null key with n number of
                    null values.</li>
            </ul>

            <hr />
            <h3>11) What is the difference between HashSet and HashMap?</h3>

            <p>The differences between the HashSet and HashMap are listed below.</p>

            <ul>
                <li>HashSet contains only values whereas HashMap includes the entry (key, value). HashSet can be
                    iterated, but HashMap needs to convert into Set to be iterated.</li>
                <li>HashSet implements Set interface whereas HashMap implements the Map interface</li>
                <li>HashSet cannot have any duplicate value whereas HashMap can contain duplicate values with unique
                    keys.</li>
                <li>HashSet contains the only single number of null value whereas HashMap can hold a single null key
                    with n number of null values.</li>
            </ul>

            <hr />
            <h3>12) What is the difference between HashMap and TreeMap?</h3>

            <p>The differences between the HashMap and TreeMap are given below.</p>

            <ul>
                <li>HashMap maintains&nbsp;no order, but TreeMap maintains&nbsp;ascending order.</li>
                <li>HashMap is implemented by hash table whereas TreeMap is implemented by a Tree structure.</li>
                <li>HashMap can be sorted by Key or value whereas TreeMap can be sorted by Key.</li>
                <li>HashMap may contain a null key with multiple null values whereas TreeMap cannot hold a null key but
                    can have multiple null values.</li>
            </ul>

            <hr />
            <h3>13) What is the difference between HashMap and Hashtable?</h3>

            <table>
                <tbody>
                    <tr>
                        <th>No.</th>
                        <th>HashMap</th>
                        <th>Hashtable</th>
                    </tr>
                    <tr>
                        <td>1)</td>
                        <td>HashMap is not synchronized.</td>
                        <td>Hashtable is synchronized.</td>
                    </tr>
                    <tr>
                        <td>2)</td>
                        <td>HashMap can contain one null key and multiple null values.</td>
                        <td>Hashtable cannot contain any null key or null value.</td>
                    </tr>
                    <tr>
                        <td>3)</td>
                        <td>HashMap is not ?thread-safe,? so it is useful for non-threaded applications.</td>
                        <td>Hashtable is thread-safe, and it can be shared between various threads.</td>
                    </tr>
                    <tr>
                        <td>4)</td>
                        <td>4) HashMap inherits the AbstractMap class</td>
                        <td>Hashtable inherits the Dictionary class.</td>
                    </tr>
                </tbody>
            </table>

            <hr />
            <h3>14) What is the difference between Collection and Collections?</h3>

            <p>The differences between the Collection and Collections are given below.</p>

            <ul>
                <li>The Collection is an interface whereas Collections is a class.</li>
                <li>The Collection interface provides the standard functionality of data structure to List, Set, and
                    Queue. However, Collections class is to sort and synchronize the collection elements.</li>
                <li>The Collection interface provides the methods that can be used for data structure whereas
                    Collections class provides the static methods which can be used for various operation on a
                    collection.</li>
            </ul>

            <hr />
            <h3>15) What is the difference between Comparable and Comparator?</h3>

            <table>
                <tbody>
                    <tr>
                        <th>No.</th>
                        <th>Comparable</th>
                        <th>Comparator</th>
                    </tr>
                    <tr>
                        <td>1)</td>
                        <td>Comparable provides only one sort of sequence.</td>
                        <td>The Comparator provides multiple sorts of sequences.</td>
                    </tr>
                    <tr>
                        <td>2)</td>
                        <td>It provides one method named compareTo().</td>
                        <td>It provides one method named compare().</td>
                    </tr>
                    <tr>
                        <td>3)</td>
                        <td>It is found in java.lang package.</td>
                        <td>It is located in java.util package.</td>
                    </tr>
                    <tr>
                        <td>4)</td>
                        <td>If we implement the Comparable interface, The actual class is modified.</td>
                        <td>The actual class is not changed.</td>
                    </tr>
                </tbody>
            </table>

            <hr />
            <h3>16) What do you understand by BlockingQueue?</h3>

            <p>BlockingQueue is an interface which extends the Queue interface. It provides concurrency in the
                operations like retrieval, insertion, deletion. While retrieval of any element, it waits for the queue
                to be non-empty. While storing the elements, it waits for the available space. BlockingQueue cannot
                contain null elements, and implementation of BlockingQueue is thread-safe.</p>

            <p><strong>Syntax:</strong></p>

            <ol start="1">
                <li>public&nbsp;interface&nbsp;BlockingQueue&lt;E&gt;&nbsp;extends&nbsp;Queue&nbsp;&lt;E&gt;&nbsp;&nbsp;
                </li>
            </ol>

            <hr />
            <h3>17) What is the advantage of Properties file?</h3>

            <p>If you change the value in the properties file, you don&#39;t need to recompile the java class. So, it
                makes the application easy to manage. It is used to store information which is to be changed frequently.
                Consider the following example.</p>

            <ol start="1">
                <li>import&nbsp;java.util.*;&nbsp;&nbsp;</li>
                <li>import&nbsp;java.io.*;&nbsp;&nbsp;</li>
                <li>public&nbsp;class&nbsp;Test&nbsp;{&nbsp;&nbsp;</li>
                <li>public&nbsp;static&nbsp;void&nbsp;main(String[]&nbsp;args)throws&nbsp;Exception{&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;FileReader&nbsp;reader=new&nbsp;FileReader(&quot;db.properties&quot;);&nbsp;&nbsp;
                </li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;Properties&nbsp;p=new&nbsp;Properties();&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;p.load(reader);&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(p.getProperty(&quot;user&quot;));&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(p.getProperty(&quot;password&quot;));&nbsp;&nbsp;</li>
                <li>}&nbsp;&nbsp;</li>
                <li>}&nbsp;&nbsp;</li>
            </ol>

            <p><strong>Output</strong></p>

            <pre>
system
oracle
</pre>

            <hr />
            <h3>18) What does the hashCode() method?</h3>

            <p>The hashCode() method returns a hash code value (an integer number).</p>

            <p>The hashCode() method returns the same integer number if two keys (by calling equals() method) are
                identical.</p>

            <p>However, it is possible that two hash code numbers can have different or the same keys.</p>

            <p>If two objects do not produce an equal result by using the equals() method, then the hashcode() method
                will provide the different integer result for both the objects.</p>

            <hr />
            <h3>19) Why we override equals() method?</h3>

            <p>The equals method is used to check whether two objects are the same or not. It needs to be overridden if
                we want to check the objects based on the property.</p>

            <p>For example, Employee is a class that has 3 data members: id, name, and salary. However, we want to check
                the equality of employee object by the salary. Then, we need to override the equals() method.</p>

            <hr />
            <h3>20) How to synchronize List, Set and Map elements?</h3>

            <p>Yes, Collections class provides methods to make List, Set or Map elements as synchronized:</p>

            <table>
                <tbody>
                    <tr>
                        <td>public static List synchronizedList(List l){}</td>
                    </tr>
                    <tr>
                        <td>public static Set synchronizedSet(Set s){}</td>
                    </tr>
                    <tr>
                        <td>public static SortedSet synchronizedSortedSet(SortedSet s){}</td>
                    </tr>
                    <tr>
                        <td>public static Map synchronizedMap(Map m){}</td>
                    </tr>
                    <tr>
                        <td>public static SortedMap synchronizedSortedMap(SortedMap m){}</td>
                    </tr>
                </tbody>
            </table>

            <hr />
            <h3>21) What is the advantage of the generic collection?</h3>

            <p>There are three main advantages of using the generic collection.</p>

            <ul>
                <li>If we use the generic class, we don&#39;t need typecasting.</li>
                <li>It is type-safe and checked at compile time.</li>
                <li>Generic confirms the stability of the code by making it bug detectable at compile time.</li>
            </ul>

            <hr />
            <h3>22) What is hash-collision in Hashtable and how it is handled in Java?</h3>

            <p>Two different keys with the same hash value are known as hash-collision. Two separate entries will be
                kept in a single hash bucket to avoid the collision. There are two ways to avoid hash-collision.</p>

            <ul>
                <li>Separate Chaining</li>
                <li>Open Addressing</li>
            </ul>

            <hr />
            <h3>23) What is the Dictionary class?</h3>

            <p>The Dictionary class provides the capability to store key-value pairs.</p>

            <hr />
            <h3>24) What is the default size of load factor in hashing based collection?</h3>

            <p>The default size of load factor is&nbsp;<strong>0.75</strong>. The default capacity is computed as
                initial capacity * load factor. For example, 16 * 0.75 = 12. So, 12 is the default capacity of Map.</p>

            <hr />
            <h3>25) What do you understand by fail-fast?</h3>

            <p>The Iterator in java which immediately throws ConcurrentmodificationException, if any structural
                modification occurs in, is called as a Fail-fast iterator. Fail-fats iterator does not require any extra
                space in memory.</p>

            <hr />
            <h3>26)&nbsp;<a href="https://www.javatpoint.com/array-vs-arraylist-in-java">What is the difference between
                    Array and ArrayList?</a></h3>

            <p>The main differences between the Array and ArrayList are given below.</p>

            <table>
                <tbody>
                    <tr>
                        <th>SN</th>
                        <th>Array</th>
                        <th>ArrayList</th>
                    </tr>
                    <tr>
                        <td>1</td>
                        <td>The Array is of fixed size, means we cannot resize the array as per need.</td>
                        <td>ArrayList is not of the fixed size we can change the size dynamically.</td>
                    </tr>
                    <tr>
                        <td>2</td>
                        <td>Arrays are of the static type.</td>
                        <td>ArrayList is of dynamic size.</td>
                    </tr>
                    <tr>
                        <td>3</td>
                        <td>Arrays can store primitive data types as well as objects.</td>
                        <td>ArrayList cannot store the primitive data types it can only store the objects.</td>
                    </tr>
                </tbody>
            </table>

            <hr />
            <h3>27)&nbsp;<a
                    href="https://www.javatpoint.com/difference-between-length-of-array-and-size-of-arraylist-in-java">What
                    is the difference between the length of an Array and size of ArrayList?</a></h3>

            <p>The length of an array can be obtained using the property of length whereas ArrayList does not support
                length property, but we can use size() method to get the number of objects in the list.</p>

            <p><strong>Finding the length of the array</strong></p>

            <ol start="1">
                <li>Int&nbsp;[]&nbsp;array&nbsp;=&nbsp;new&nbsp;int[4];&nbsp;&nbsp;</li>
                <li>System.out.println(&quot;The&nbsp;size&nbsp;of&nbsp;the&nbsp;array&nbsp;is&nbsp;&quot;&nbsp;+&nbsp;array.length);&nbsp;&nbsp;
                </li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</li>
            </ol>

            <p><strong>Finding the size of the ArrayList</strong></p>

            <ol start="1">
                <li>ArrayList&lt;String&gt;&nbsp;list=new&nbsp;ArrayList&lt;String&gt;();&nbsp;&nbsp;&nbsp;&nbsp;</li>
                <li>list.add(&quot;ankit&quot;);&nbsp;&nbsp;&nbsp;&nbsp;</li>
                <li>list.add(&quot;nippun&quot;);&nbsp;&nbsp;</li>
                <li>System.out.println(list.size());&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</li>
            </ol>

            <hr />
            <h3>28)&nbsp;<a
                    href="https://www.javatpoint.com/how-to-convert-arraylist-to-array-and-array-to-arraylist-in-java">How
                    to convert ArrayList to Array and Array to ArrayList?</a></h3>

            <p>We can convert an Array to ArrayList by using the asList() method of Arrays class. asList() method is the
                static method of Arrays class and accepts the List object. Consider the following syntax:</p>

            <ol start="1">
                <li>Arrays.asList(item)&nbsp;&nbsp;</li>
            </ol>

            <p>We can convert an ArrayList to Array using toArray() method of the ArrayList class. Consider the
                following syntax to convert the ArrayList to the List object.</p>

            <ol start="1">
                <li>List_object.toArray(new&nbsp;String[List_object.size()])&nbsp;&nbsp;</li>
            </ol>

            <hr />
            <h3>29)&nbsp;<a href="https://www.javatpoint.com/how-to-make-java-arraylist-read-only">How to make Java
                    ArrayList Read-Only?</a></h3>

            <p>We can obtain java ArrayList Read-only by calling the Collections.unmodifiableCollection() method. When
                we define an ArrayList as Read-only then we cannot perform any modification in the collection through
                &nbsp;add(), remove() or set() method.</p>

            <hr />
            <h3>30)&nbsp;<a href="https://www.javatpoint.com/how-to-remove-duplicates-from-arraylist-in-java">How to
                    remove duplicates from ArrayList?</a></h3>

            <p>There are two ways to remove duplicates from the ArrayList.</p>

            <ul>
                <li><strong>Using HashSet:</strong>&nbsp;By using HashSet we can remove the duplicate element from the
                    ArrayList, but it will not then preserve the insertion order.</li>
                <li><strong>Using LinkedHashSet:</strong>&nbsp;We can also maintain the insertion order by using
                    LinkedHashSet instead of HashSet.</li>
            </ul>

            <p>The Process to remove duplicate elements from ArrayList using the LinkedHashSet:</p>

            <ul>
                <li>Copy all the elements of ArrayList to LinkedHashSet.</li>
                <li>Empty the ArrayList using clear() method, which will remove all the elements from the list.</li>
                <li>Now copy all the elements of LinkedHashset to ArrayList.</li>
            </ul>

            <hr />
            <h3>31)&nbsp;<a href="https://www.javatpoint.com/how-to-reverse-arraylist-in-java">How to reverse
                    ArrayList?</a></h3>

            <p>To reverse an ArrayList, we can use reverse() method of Collections class. Consider the following
                example.</p>

            <ol start="1">
                <li>import&nbsp;java.util.ArrayList;&nbsp;&nbsp;</li>
                <li>import&nbsp;java.util.Collection;&nbsp;&nbsp;</li>
                <li>import&nbsp;java.util.Collections;&nbsp;&nbsp;</li>
                <li>import&nbsp;java.util.Iterator;&nbsp;&nbsp;</li>
                <li>import&nbsp;java.util.List;&nbsp;&nbsp;</li>
                <li>public&nbsp;class&nbsp;ReverseArrayList&nbsp;{&nbsp;&nbsp;</li>
                <li>public&nbsp;static&nbsp;void&nbsp;main(String[]&nbsp;args)&nbsp;{&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;List&nbsp;list&nbsp;=&nbsp;new&nbsp;ArrayList&lt;&gt;();&nbsp;&nbsp;
                </li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;list.add(10);&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;list.add(50);&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;list.add(30);&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Iterator&nbsp;i&nbsp;=&nbsp;list.iterator();&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(&quot;printing&nbsp;the&nbsp;list....&quot;);&nbsp;&nbsp;
                </li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;while(i.hasNext())&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(i.next());&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Iterator&nbsp;i2&nbsp;=&nbsp;list.iterator();&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Collections.reverse(list);&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(&quot;printing&nbsp;list&nbsp;in&nbsp;reverse&nbsp;order....&quot;);&nbsp;&nbsp;
                </li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;while(i2.hasNext())&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(i2.next());&nbsp;&nbsp;
                </li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</li>
                <li>}&nbsp;&nbsp;</li>
            </ol>

            <p><strong>Output</strong></p>

            <pre>
printing the list....
10
50
30
printing list in reverse order....
30
50
10
</pre>

            <hr />
            <h3>32)&nbsp;<a href="https://www.javatpoint.com/how-to-sort-java-arraylist-in-descending-order">How to sort
                    ArrayList in descending order?</a></h3>

            <p>To sort the ArrayList in descending order, we can use the reverseOrder method of Collections class.
                Consider the following example.</p>

            <ol start="1">
                <li>import&nbsp;java.util.ArrayList;&nbsp;&nbsp;</li>
                <li>import&nbsp;java.util.Collection;&nbsp;&nbsp;</li>
                <li>import&nbsp;java.util.Collections;&nbsp;&nbsp;</li>
                <li>import&nbsp;java.util.Comparator;&nbsp;&nbsp;</li>
                <li>import&nbsp;java.util.Iterator;&nbsp;&nbsp;</li>
                <li>import&nbsp;java.util.List;&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;</li>
                <li>public&nbsp;class&nbsp;ReverseArrayList&nbsp;{&nbsp;&nbsp;</li>
                <li>public&nbsp;static&nbsp;void&nbsp;main(String[]&nbsp;args)&nbsp;{&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;List&nbsp;list&nbsp;=&nbsp;new&nbsp;ArrayList&lt;&gt;();&nbsp;&nbsp;
                </li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;list.add(10);&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;list.add(50);&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;list.add(30);&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;list.add(60);&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;list.add(20);&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;list.add(90);&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Iterator&nbsp;i&nbsp;=&nbsp;list.iterator();&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(&quot;printing&nbsp;the&nbsp;list....&quot;);&nbsp;&nbsp;
                </li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;while(i.hasNext())&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(i.next());&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;Comparator&nbsp;cmp&nbsp;=&nbsp;Collections.reverseOrder();&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;Collections.sort(list,cmp);&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(&quot;printing&nbsp;list&nbsp;in&nbsp;descending&nbsp;order....&quot;);&nbsp;&nbsp;
                </li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Iterator&nbsp;i2&nbsp;=&nbsp;list.iterator();&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;while(i2.hasNext())&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(i2.next());&nbsp;&nbsp;
                </li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</li>
                <li>}&nbsp;&nbsp;</li>
                <li>}&nbsp;&nbsp;</li>
            </ol>

            <p><strong>Output</strong></p>

            <pre>
printing the list....
10
50
30
60
20
90
printing list in descending order....
90
60
50
30
20
10
</pre>

            <hr />
            <h3>33)&nbsp;<a href="https://www.javatpoint.com/how-to-synchronize-arraylist-in-java">How to synchronize
                    ArrayList?</a></h3>

            <p>We can synchronize ArrayList in two ways.</p>

            <ul>
                <li>Using Collections.synchronizedList() method</li>
                <li>Using CopyOnWriteArrayList&lt;T&gt;</li>
            </ul>

            <hr />
            <h3>34)&nbsp;<a href="https://www.javatpoint.com/when-to-use-arraylist-and-linkedlist-in-java">When to use
                    ArrayList and LinkedList?</a></h3>

            <p>LinkedLists are better to use for the update operations whereas ArrayLists are better to use for the
                search operations.</p>

        </div>

        <div class="box-prem">
            <h1>JDBC Interview Questions</h1>

            <p>A list of top frequently asked JDBC interview questions and answers is given below.</p>

            <hr />
            <h3>1) What is JDBC?</h3>

            <p>JDBC is a Java API that is used to connect and execute the query to the database. JDBC API uses JDBC
                drivers to connect to the database. JDBC API can be used to access tabular data stored into any
                relational database.</p>

            <p><img alt="JDBC (Java Database Connectivity) "
                    src="https://www.javatpoint.com/images/core/jdbc.png" />&nbsp;<a
                    href="https://www.javatpoint.com/jdbc-tutorial">More details.</a></p>

            <hr />
            <h3>2) What is JDBC Driver?</h3>

            <p>JDBC Driver is a software component that enables Java application to interact with the database. There
                are 4 types of JDBC drivers:</p>

            <ol>
                <li><strong>JDBC-ODBC bridge driver:</strong>&nbsp;The JDBC-ODBC bridge driver uses the ODBC driver to
                    connect to the database. The JDBC-ODBC bridge driver converts JDBC method calls into the ODBC
                    function calls. This is now discouraged because of the thin driver. It is easy to use and can be
                    easily connected to any database.</li>
                <li><strong>Native-API driver (partially java driver):</strong>&nbsp;The Native API driver uses the
                    client-side libraries of the database. The driver converts JDBC method calls into native calls of
                    the database API. It is not written entirely in Java. Its performance is better than JDBC-ODBC
                    bridge driver. However, the native driver must be installed on each client machine.</li>
                <li><strong>Network Protocol driver (fully java driver):</strong>&nbsp;The Network Protocol driver uses
                    middleware (application server) that converts JDBC calls directly or indirectly into the
                    vendor-specific database protocol. It is entirely written in Java. There is no requirement of the
                    client-side library because of the application server that can perform many tasks like auditing,
                    load balancing, logging, etc.</li>
                <li><strong>Thin driver (fully java driver):</strong>&nbsp;The thin driver converts JDBC calls directly
                    into the vendor-specific database protocol. That is why it is known as the thin driver. It is
                    entirely written in Java language. Its performance is better than all other drivers however these
                    drivers depend upon the database.</li>
            </ol>

            <p><a href="https://www.javatpoint.com/jdbc-driver">More details.</a></p>

            <hr />
            <h3>3) What are the steps to connect to the database in java?</h3>

            <p>The following steps are used in database connectivity.</p>

            <p>&nbsp;</p>

            <p>Competitive questions on Structures in Hindi</p>

            <p>Keep Watching</p>

            <p>&nbsp;</p>

            <p>The forName() method of the Class class is used to register the driver class. This method is used to load
                the driver class dynamically. Consider the following example to register OracleDriver class.</p>

            <ol start="1">
                <li>Class.forName(&quot;oracle.jdbc.driver.OracleDriver&quot;);&nbsp;&nbsp;</li>
            </ol>

            <p>The getConnection() method of DriverManager class is used to establish the connection with the database.
                The syntax of the getConnection() method is given below.</p>

            <ol start="1">
                <li>1)&nbsp;public&nbsp;static&nbsp;Connection&nbsp;getConnection(String&nbsp;url)throws&nbsp;SQLException&nbsp;&nbsp;
                </li>
                <li>2)&nbsp;public&nbsp;static&nbsp;Connection&nbsp;getConnection(String&nbsp;url,String&nbsp;name,String&nbsp;password)&nbsp;&nbsp;
                </li>
                <li>throws&nbsp;SQLException&nbsp;&nbsp;</li>
            </ol>

            <p>Consider the following example to establish the connection with the Oracle database.</p>

            <ol start="1">
                <li>Connection&nbsp;con=DriverManager.getConnection(&nbsp;&nbsp;</li>
                <li>&quot;jdbc:oracle:thin:@localhost:1521:xe&quot;,&quot;system&quot;,&quot;password&quot;);&nbsp;&nbsp;
                </li>
            </ol>

            <p>The createStatement() method of Connection interface is used to create the Statement. The object of the
                Statement is responsible for executing queries with the database.</p>

            <ol start="1">
                <li>public&nbsp;Statement&nbsp;createStatement()throws&nbsp;SQLException&nbsp;&nbsp;</li>
            </ol>

            <p>consider the following example to create the statement object</p>

            <p>&nbsp;</p>

            <ol start="1">
                <li>Statement&nbsp;stmt=con.createStatement();&nbsp;&nbsp;</li>
            </ol>

            <p>The executeQuery() method of Statement interface is used to execute queries to the database. This method
                returns the object of ResultSet that can be used to get all the records of a table.</p>

            <p>Syntax of executeQuery() method is given below.</p>

            <p>&nbsp;</p>

            <ol start="1">
                <li>public&nbsp;ResultSet&nbsp;executeQuery(String&nbsp;sql)throws&nbsp;SQLException&nbsp;&nbsp;</li>
            </ol>

            <p>Example to execute the query</p>

            <p>&nbsp;</p>

            <ol start="1">
                <li>ResultSet&nbsp;rs=stmt.executeQuery(&quot;select&nbsp;*&nbsp;from&nbsp;emp&quot;);&nbsp;&nbsp;</li>
                <li>while(rs.next()){&nbsp;&nbsp;</li>
                <li>System.out.println(rs.getInt(1)+&quot;&nbsp;&quot;+rs.getString(2));&nbsp;&nbsp;</li>
                <li>}&nbsp;&nbsp;</li>
            </ol>

            <p>However, to perform the insert and update operations in the database, executeUpdate() method is used
                which returns the boolean value to indicate the successful completion of the operation.</p>

            <p>By closing connection, object statement and ResultSet will be closed automatically. The close() method of
                Connection interface is used to close the connection.</p>

            <p>Syntax of close() method is given below.</p>

            <p>&nbsp;</p>

            <ol start="1">
                <li>public&nbsp;void&nbsp;close()throws&nbsp;SQLException&nbsp;&nbsp;</li>
            </ol>

            <p>Consider the following example to close the connection.</p>

            <ol start="1">
                <li>con.close();&nbsp;&nbsp;</li>
            </ol>

            <ul>
                <li><strong>Registering the driver class:</strong></li>
                <br />
                <li><strong>Creating connection:</strong></li>
                <br />
                <li><strong>Creating the statement:</strong></li>
                <br />
                <li><strong>Executing the queries:</strong></li>
                <li><strong>Closing connection:</strong></li>
            </ul>

            <p><a href="https://www.javatpoint.com/steps-to-connect-to-the-database-in-java">More details.</a></p>

            <hr />
            <h3>4) What are the JDBC API components?</h3>

            <p>The java.sql package contains following interfaces and classes for JDBC API.</p>

            <p><strong>Interfaces:</strong></p>

            <ul>
                <li><strong>Connection:</strong>&nbsp;The Connection object is created by using getConnection() method
                    of DriverManager class. DriverManager is the factory for connection.</li>
                <br />
                <li><strong>Statement:</strong>&nbsp;The Statement object is created by using createStatement() method
                    of Connection class. The Connection interface is the factory for Statement.</li>
                <br />
                <li><strong>PreparedStatement:</strong>&nbsp;The PrepareStatement object is created by using
                    prepareStatement() method of Connection class. It is used to execute the parameterized query.</li>
                <br />
                <li><strong>ResultSet:</strong>&nbsp;The object of ResultSet maintains a cursor pointing to a row of a
                    table. Initially, cursor points before the first row. The executeQuery() method of Statement
                    interface returns the ResultSet object.</li>
                <br />
                <li><strong>ResultSetMetaData:</strong>&nbsp;The object of ResultSetMetaData interface cotains the
                    information about the data (table) such as numer of columns, column name, column type, etc. The
                    getMetaData() method of ResultSet returns the object of ResultSetMetaData.</li>
                <br />
                <li><strong>DatabaseMetaData:</strong>&nbsp;DatabaseMetaData interface provides methods to get metadata
                    of a database such as the database product name, database product version, driver name, name of the
                    total number of tables, the name of the total number of views, etc. The getMetaData() method of
                    Connection interface returns the object of DatabaseMetaData.</li>
                <br />
                <li><strong>CallableStatement:</strong>&nbsp;CallableStatement interface is used to call the stored
                    procedures and functions. We can have business logic on the database through the use of stored
                    procedures and functions that will make the performance better because these are precompiled. The
                    prepareCall() method of Connection interface returns the instance of CallableStatement.</li>
                <br />
                <br />
                &nbsp;
            </ul>

            <p><strong>Classes:</strong></p>

            <ul>
                <li><strong>DriverManager:</strong>&nbsp;The DriverManager class acts as an interface between the user
                    and drivers. It keeps track of the drivers that are available and handles establishing a connection
                    between a database and the appropriate driver. It contains several methods to keep the interaction
                    between the user and drivers.</li>
                <br />
                <li><strong>Blob:</strong>&nbsp;Blob stands for the binary large object. It represents a collection of
                    binary data stored as a single entity in the database management system.</li>
                <br />
                <li><strong>Clob:</strong>&nbsp;Clob stands for Character large object. It is a data type that is used
                    by various database management systems to store character files. It is similar to Blob except for
                    the difference that BLOB represent binary data such as images, audio and video files, etc. whereas
                    Clob represents character stream data such as character files, etc.</li>
                <br />
                <li><strong>SQLException</strong>&nbsp;It is an Exception class which provides information on database
                    access errors.</li>
            </ul>

            <hr />
            <h3>5) What are the JDBC statements?</h3>

            <p>In JDBC, Statements are used to send SQL commands to the database and receive data from the database.
                There are various methods provided by JDBC statements such as execute(), executeUpdate(), executeQuery,
                etc. which helps you to interact with the database.</p>

            <p>There is three type of JDBC statements given in the following table.</p>

            <table>
                <tbody>
                    <tr>
                        <th>Statements</th>
                        <th>Explanation</th>
                    </tr>
                    <tr>
                        <td>Statement</td>
                        <td>Statement is the factory for resultset. It is used for general purpose access to the
                            database. It executes a static SQL query at runtime.</td>
                    </tr>
                    <tr>
                        <td>PreparedStatement</td>
                        <td>The PreparedStatement is used when we need to provide input parameters to the query at
                            runtime.</td>
                    </tr>
                    <tr>
                        <td>CallableStatement</td>
                        <td>CallableStatement is used when we need to access the database stored procedures. It can also
                            accept runtime parameters.</td>
                    </tr>
                </tbody>
            </table>

            <hr />
            <h3>6) What is the return type of Class.forName() method?</h3>

            <p>The Class.forName() method returns the object of java.lang.Class object.</p>

            <h3>7) What are the differences between Statement and PreparedStatement interface?</h3>

            <table>
                <tbody>
                    <tr>
                        <th>Statement</th>
                        <th>PreparedStatement</th>
                    </tr>
                    <tr>
                        <td>The Statement interface provides methods to execute queries with the database. The statement
                            interface is a factory of ResultSet; i.e., it provides the factory method to get the object
                            of ResultSet.</td>
                        <td>The PreparedStatement interface is a subinterface of Statement. It is used to execute the
                            parameterized query.</td>
                    </tr>
                    <tr>
                        <td>In the case of Statement, the query is compiled each time we run the program.</td>
                        <td>In the case of PreparedStatement, the query is compiled only once.</td>
                    </tr>
                    <tr>
                        <td>The Statement is mainly used in the case when we need to run the static query at runtime.
                        </td>
                        <td>PreparedStatement is used when we need to provide input parameters to the query at runtime.
                        </td>
                    </tr>
                </tbody>
            </table>

            <p><a href="https://www.javatpoint.com/PreparedStatement-interface">More details.</a></p>

            <hr />
            <h3>8) How can we set null value in JDBC PreparedStatement?</h3>

            <p>By using setNull() method of PreparedStatement interface, we can set the null value to an index. The
                syntax of the method is given below.</p>

            <ol start="1">
                <li>void&nbsp;setNull(int&nbsp;parameterIndex,&nbsp;int&nbsp;sqlType)&nbsp;throws&nbsp;SQLException&nbsp;&nbsp;
                </li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</li>
            </ol>

            <hr />
            <h3>9) What are the benefits of PreparedStatement over Statement?</h3>

            <p>The benefits of using PreparedStatement over Statement interface is given below.</p>

            <p>&nbsp;</p>

            <ul>
                <li>The PreparedStatement performs faster as compare to Statement because the Statement needs to be
                    compiled everytime we run the code whereas the PreparedStatement compiled once and then execute only
                    on runtime.</li>
                <li>PreparedStatement can execute Parameterized query whereas Statement can only run static queries.
                </li>
                <li>The query used in PreparedStatement is appeared to be similar every time. Therefore, the database
                    can reuse the previous access plan whereas, Statement inline the parameters into the String,
                    therefore, the query doesn&#39;t appear to be same everytime which prevents cache reusage.</li>
            </ul>

            <hr />
            <h3>10) What are the differences between execute, executeQuery, and executeUpdate?</h3>

            <table>
                <tbody>
                    <tr>
                        <th>execute</th>
                        <th>executeQuery</th>
                        <th>executeUpdate</th>
                    </tr>
                    <tr>
                        <td>The execute method can be used for any SQL statements(Select and Update both).</td>
                        <td>The executeQuery method can be used only with the select statement.</td>
                        <td>The executeUpdate method can be used to update/delete/insert operations in the database.
                        </td>
                    </tr>
                    <tr>
                        <td>The execute method returns a boolean type value where true indicates that the ResultSet s
                            returned which can later be extracted and false indicates that the integer or void value is
                            returned.</td>
                        <td>The executeQuery() method returns a ResultSet object which contains the data retrieved by
                            the select statement.</td>
                        <td>The executeUpdate() method returns an integer value representing the number of records
                            affected where 0 indicates that query returns nothing.</td>
                    </tr>
                </tbody>
            </table>

            <hr />
            <h3>11) What are the different types of ResultSet?</h3>

            <p>ResultSet is categorized by the direction of the reading head and sensitivity or insensitivity of the
                result provided by it. There are three general types of ResultSet.</p>

            <table>
                <tbody>
                    <tr>
                        <td>Type</td>
                        <td>Description</td>
                    </tr>
                    <tr>
                        <td>ResultSet.TYPE_Forward_ONLY</td>
                        <td>The cursor can move in the forward direction only.</td>
                    </tr>
                    <tr>
                        <td>ResultSet.TYPE_SCROLL_INSENSITIVE</td>
                        <td>The cursor can move in both the direction (forward and backward). The ResultSet is not
                            sensitive to the changes made by the others to the database.</td>
                    </tr>
                    <tr>
                        <td>ResultSet.TYPE_SCROLL_SENSITIVE</td>
                        <td>The cursor can move in both the direction. The ResultSet is sensitive to the changes made by
                            the others to the database.</td>
                    </tr>
                </tbody>
            </table>

            <hr />
            <h3>12) What are the differences between ResultSet and RowSet?</h3>

            <table>
                <tbody>
                    <tr>
                        <td>ResultSet</td>
                        <td>RowSet</td>
                    </tr>
                    <tr>
                        <td>ResultSet cannot be serialized as it maintains the connection with the database.</td>
                        <td>RowSet is disconnected from the database and can be serialized.</td>
                    </tr>
                    <tr>
                        <td>ResultSet object is not a JavaBean object</td>
                        <td>ResultSet Object is a JavaBean object.</td>
                    </tr>
                    <tr>
                        <td>ResultSet is returned by the executeQuery() method of Statement Interface.</td>
                        <td>Rowset Interface extends ResultSet Interface and returned by calling the
                            RowSetProvider.newFactory().createJdbcRowSet() method.</td>
                    </tr>
                    <tr>
                        <td>ResultSet object is non-scrollable and non-updatable by default.</td>
                        <td>RowSet object is scrollable and updatable by default.</td>
                    </tr>
                </tbody>
            </table>

            <hr />
            <h3>13) How can we execute stored procedures using CallableStatement?</h3>

            <p>Following are the steps to create and execute stored procedures. Here, we are creating a table user420 by
                using a stored procedure and inserting values into it.</p>

            <p>To call the stored procedure, you need to create it in the database. Here, we are assuming that the
                stored procedure looks like this.</p>

            <ol start="1">
                <li>create&nbsp;or&nbsp;replace&nbsp;procedure&nbsp;&quot;INSERTR&quot;&nbsp;&nbsp;</li>
                <li>(id&nbsp;IN&nbsp;NUMBER,&nbsp;&nbsp;</li>
                <li>name&nbsp;IN&nbsp;VARCHAR2)&nbsp;&nbsp;</li>
                <li>is&nbsp;&nbsp;</li>
                <li>begin&nbsp;&nbsp;</li>
                <li>insert&nbsp;into&nbsp;user420&nbsp;values(id,name);&nbsp;&nbsp;</li>
                <li>end;&nbsp;&nbsp;</li>
                <li>/&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</li>
            </ol>

            <p>The table structure is given below:</p>

            <ol start="1">
                <li>create&nbsp;table&nbsp;user420(id&nbsp;number(10),&nbsp;name&nbsp;varchar2(200));&nbsp;&nbsp;</li>
            </ol>

            <ol start="1">
                <li>Class.forName(&quot;oracle.jdbc.driver.OracleDriver&quot;);&nbsp;&nbsp;</li>
                <li>Connection&nbsp;con=DriverManager.getConnection(&nbsp;&nbsp;</li>
                <li>&quot;jdbc:oracle:thin:@localhost:1521:xe&quot;,&quot;system&quot;,&quot;oracle&quot;);&nbsp;&nbsp;
                </li>
            </ol>

            <ol start="1">
                <li>CallableStatement&nbsp;stmt=con.prepareCall(&quot;{call&nbsp;insertR(?,?)}&quot;);&nbsp;&nbsp;</li>
            </ol>

            <ol start="1">
                <li>stmt.setInt(1,1011);&nbsp;&nbsp;</li>
                <li>stmt.setString(2,&quot;Amit&quot;);&nbsp;&nbsp;</li>
                <li>stmt.execute();&nbsp;&nbsp;</li>
            </ol>

            <ol start="1">
                <li>import&nbsp;java.sql.*;&nbsp;&nbsp;</li>
                <li>public&nbsp;class&nbsp;Proc&nbsp;{&nbsp;&nbsp;</li>
                <li>public&nbsp;static&nbsp;void&nbsp;main(String[]&nbsp;args)&nbsp;throws&nbsp;Exception{&nbsp;&nbsp;
                </li>
                <li>&nbsp;&nbsp;</li>
                <li>Class.forName(&quot;oracle.jdbc.driver.OracleDriver&quot;);&nbsp;&nbsp;</li>
                <li>Connection&nbsp;con=DriverManager.getConnection(&nbsp;&nbsp;</li>
                <li>&quot;jdbc:oracle:thin:@localhost:1521:xe&quot;,&quot;system&quot;,&quot;oracle&quot;);&nbsp;&nbsp;
                </li>
                <li>&nbsp;&nbsp;</li>
                <li>CallableStatement&nbsp;stmt=con.prepareCall(&quot;{call&nbsp;insertR(?,?)}&quot;);&nbsp;&nbsp;</li>
                <li>stmt.setInt(1,1011);&nbsp;&nbsp;</li>
                <li>stmt.setString(2,&quot;Amit&quot;);&nbsp;&nbsp;</li>
                <li>stmt.execute();&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;</li>
                <li>System.out.println(&quot;success&quot;);&nbsp;&nbsp;</li>
                <li>}&nbsp;&nbsp;</li>
                <li>}&nbsp;&nbsp;</li>
            </ol>

            <ul>
                <li><strong>Create the procedure in the database.</strong></li>
                <br />
                <li><strong>Establish a network connection.</strong></li>
                <br />
                <li><strong>Create the Object of CallableStatement.</strong></li>
                <br />
                <li><strong>Provide the values and execute the query by using the following syntax.</strong></li>
                <br />
                <li><strong>Check the database; the values will be found there. However, the complete code will look
                        like the following.</strong></li>
            </ul>

            <hr />
            <h3>14) What is the role of the JDBC DriverManager class?</h3>

            <p>The DriverManager class acts as an interface between user and drivers. It keeps track of the drivers that
                are available and handles establishing a connection between a database and the appropriate driver. The
                DriverManager class maintains a list of Driver classes that have registered themselves by calling the
                method DriverManager.registerDriver().</p>

            <p><a href="https://www.javatpoint.com/DriverManager-class">More details.</a></p>

            <hr />
            <h3>15) What are the functions of the JDBC Connection interface?</h3>

            <p>The&nbsp;<strong>Connection interface</strong>&nbsp;maintains a session with the database. It can be used
                for transaction management. It provides factory methods that return the instance of Statement,
                PreparedStatement, CallableStatement, and DatabaseMetaData.</p>

            <p><a href="https://www.javatpoint.com/Connection-interface">More details.</a></p>

            <hr />
            <h3>16) What does the JDBC ResultSet interface?</h3>

            <p>The ResultSet object represents a row of a table. It can be used to change the cursor pointer and get the
                information from the database. By default, ResultSet object can move in the forward direction only and
                is not updatable. However, we can make this object to move the forward and backward direction by passing
                either TYPE_SCROLL_INSENSITIVE or TYPE_SCROLL_SENSITIVE in createStatement(int, int) method.</p>

            <p>&nbsp;</p>

            <p><a href="https://www.javatpoint.com/ResultSet-interface">More details.</a></p>

            <hr />
            <h3>17) What does the JDBC ResultSetMetaData interface?</h3>

            <p>The ResultSetMetaData interface returns the information of table such as the total number of columns,
                column name, column type, etc.</p>

            <p><a href="https://www.javatpoint.com/ResultSetMetaData-interface">More details.</a></p>

            <hr />
            <h3>18) What does the JDBC DatabaseMetaData interface?</h3>

            <p>The DatabaseMetaData interface returns the information of the database such as username, driver name,
                driver version, number of tables, number of views, etc. Consider the following example.</p>

            <ol start="1">
                <li>import&nbsp;java.sql.*;&nbsp;&nbsp;</li>
                <li>class&nbsp;Dbmd{&nbsp;&nbsp;</li>
                <li>public&nbsp;static&nbsp;void&nbsp;main(String&nbsp;args[]){&nbsp;&nbsp;</li>
                <li>try{&nbsp;&nbsp;</li>
                <li>Class.forName(&quot;oracle.jdbc.driver.OracleDriver&quot;);&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;</li>
                <li>Connection&nbsp;con=DriverManager.getConnection(&nbsp;&nbsp;</li>
                <li>&quot;jdbc:oracle:thin:@localhost:1521:xe&quot;,&quot;system&quot;,&quot;oracle&quot;);&nbsp;&nbsp;
                </li>
                <li>DatabaseMetaData&nbsp;dbmd=con.getMetaData();&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;</li>
                <li>System.out.println(&quot;Driver&nbsp;Name:&nbsp;&quot;+dbmd.getDriverName());&nbsp;&nbsp;</li>
                <li>System.out.println(&quot;Driver&nbsp;Version:&nbsp;&quot;+dbmd.getDriverVersion());&nbsp;&nbsp;</li>
                <li>System.out.println(&quot;UserName:&nbsp;&quot;+dbmd.getUserName());&nbsp;&nbsp;</li>
                <li>System.out.println(&quot;Database&nbsp;Product&nbsp;Name:&nbsp;&quot;+dbmd.getDatabaseProductName());&nbsp;&nbsp;
                </li>
                <li>System.out.println(&quot;Database&nbsp;Product&nbsp;Version:&nbsp;&quot;+dbmd.getDatabaseProductVersion());&nbsp;&nbsp;
                </li>
                <li>&nbsp;&nbsp;</li>
                <li>con.close();&nbsp;&nbsp;</li>
                <li>}catch(Exception&nbsp;e){&nbsp;System.out.println(e);}&nbsp;&nbsp;</li>
                <li>}&nbsp;&nbsp;</li>
                <li>}&nbsp;&nbsp;</li>
            </ol>

            <p><strong>Output</strong></p>

            <p>&nbsp;</p>

            <pre>
Driver Name: Oracle JDBC Driver
Driver Version: 10.2.0.1.0XE
Database Product Name: Oracle
Database Product Version: Oracle Database 10g Express Edition Release 10.2.0.1.0 -Production
</pre>

            <p><a href="https://www.javatpoint.com/DatabaseMetaData-interface">More details.</a></p>

            <hr />
            <h3>19) Which interface is responsible for transaction management in JDBC?</h3>

            <p>The&nbsp;<strong>Connection interface</strong>&nbsp;provides methods for transaction management such as
                commit(), rollback() etc.</p>

            <p><a href="https://www.javatpoint.com/transaction-management-in-jdbc">More details.</a></p>

            <hr />
            <h3>20) What is batch processing and how to perform batch processing in JDBC?</h3>

            <p>By using the batch processing technique in JDBC, we can execute multiple queries. It makes the
                performance fast. The java.sql.Statement and java.sql.PreparedStatement interfaces provide methods for
                batch processing. The batch processing in JDBC requires the following steps.</p>

            <ul>
                <li>Load the driver class</li>
                <li>Create Connection</li>
                <li>Create Statement</li>
                <li>Add query in the batch</li>
                <li>Execute the Batch</li>
                <li>Close Connection</li>
            </ul>

            <p>Consider the following example to perform batch processing using the Statement interface.</p>

            <ol start="1">
                <li>import&nbsp;java.sql.*;&nbsp;&nbsp;</li>
                <li>class&nbsp;FetchRecords{&nbsp;&nbsp;</li>
                <li>public&nbsp;static&nbsp;void&nbsp;main(String&nbsp;args[])throws&nbsp;Exception{&nbsp;&nbsp;</li>
                <li>Class.forName(&quot;oracle.jdbc.driver.OracleDriver&quot;);&nbsp;&nbsp;</li>
                <li>Connection&nbsp;con=DriverManager.getConnection(&quot;jdbc:oracle:thin:@localhost:1521:xe&quot;,&quot;system&quot;,&quot;oracle&quot;);&nbsp;&nbsp;
                </li>
                <li>con.setAutoCommit(false);&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;</li>
                <li>Statement&nbsp;stmt=con.createStatement();&nbsp;&nbsp;</li>
                <li>stmt.addBatch(&quot;insert&nbsp;into&nbsp;user420&nbsp;values(190,&#39;abhi&#39;,40000)&quot;);&nbsp;&nbsp;
                </li>
                <li>stmt.addBatch(&quot;insert&nbsp;into&nbsp;user420&nbsp;values(191,&#39;umesh&#39;,50000)&quot;);&nbsp;&nbsp;
                </li>
                <li>&nbsp;&nbsp;</li>
                <li>stmt.executeBatch();//executing&nbsp;the&nbsp;batch&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;</li>
                <li>con.commit();&nbsp;&nbsp;</li>
                <li>con.close();&nbsp;&nbsp;</li>
                <li>}}&nbsp;&nbsp;</li>
            </ol>

            <p><a href="https://www.javatpoint.com/batch-processing-in-jdbc">More details.</a></p>

            <hr />
            <h3>21) What are CLOB and BLOB data types in JDBC?</h3>

            <p><strong>BLOB:</strong>&nbsp;Blob can be defined as the variable-length, binary large object which is used
                to hold the group of Binary data such as voice, images, and mixed media. It can hold up to 2GB data on
                MySQL database and 128 GB on Oracle database. BLOB is supported by many databases such as MySQL, Oracle,
                and DB2 to store the binary data (images, video, audio, and mixed media).</p>

            <p><strong>CLOB:</strong>&nbsp;Clob can be defined as the variable-length, character-large object which is
                used to hold the character-based data such as files in many databases. It can hold up to 2 GB on MySQL
                database, and 128 GB on Oracle Database. A CLOB is considered as a character string.</p>

            <hr />
            <h3>22) What are the different types of lockings in JDBC?</h3>

            <p>A lock is a certain type of software mechanism by using which, we can restrict other users from using the
                data resource. There are four type of locks given in JDBC that are described below.</p>

            <ul>
                <li><strong>Row and Key Locks:</strong>&nbsp;These type of locks are used when we update the rows.</li>
                <li><strong>Page Locks:</strong>&nbsp;These type of locks are applied to a page. They are used in the
                    case, where a transaction remains in the process and is being updated, deleting, or inserting some
                    data in a row of the table. The database server locks the entire page that contains the row. The
                    page lock can be applied once by the database server.</li>
                <li><strong>Table locks:</strong>&nbsp;Table locks are applied to the table. It can be applied in two
                    ways, i.e., shared and exclusive. Shared lock lets the other transactions to read the table but not
                    update it. However, The exclusive lock prevents others from reading and writing the table.</li>
                <li><strong>Database locks:</strong>&nbsp;The Database lock is used to prevent the read and update
                    access from other transactions when the database is open.</li>
            </ul>

            <hr />
            <h3>23) How can we store and retrieve images from the database?</h3>

            <p>By using the PreparedStatement interface, we can store and retrieve images. Create a table which contains
                two columns namely NAME and PHOTO.</p>

            <ol start="1">
                <li>CREATE&nbsp;TABLE&nbsp;&nbsp;&quot;IMGTABLE&quot;&nbsp;&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;(&nbsp;&nbsp;&nbsp;&nbsp;&quot;NAME&quot;&nbsp;VARCHAR2(4000),&nbsp;&nbsp;&nbsp;
                </li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&quot;PHOTO&quot;&nbsp;BLOB&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;)&nbsp;&nbsp;</li>
            </ol>

            <p>Consider the following example to store the image in the database.</p>

            <ol start="1">
                <li>import&nbsp;java.sql.*;&nbsp;&nbsp;</li>
                <li>import&nbsp;java.io.*;&nbsp;&nbsp;</li>
                <li>public&nbsp;class&nbsp;InsertImage&nbsp;{&nbsp;&nbsp;</li>
                <li>public&nbsp;static&nbsp;void&nbsp;main(String[]&nbsp;args)&nbsp;{&nbsp;&nbsp;</li>
                <li>try{&nbsp;&nbsp;</li>
                <li>Class.forName(&quot;oracle.jdbc.driver.OracleDriver&quot;);&nbsp;&nbsp;</li>
                <li>Connection&nbsp;con=DriverManager.getConnection(&nbsp;&nbsp;</li>
                <li>&quot;jdbc:oracle:thin:@localhost:1521:xe&quot;,&quot;system&quot;,&quot;oracle&quot;);&nbsp;&nbsp;
                </li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</li>
                <li>PreparedStatement&nbsp;ps=con.prepareStatement(&quot;insert&nbsp;into&nbsp;imgtable&nbsp;values(?,?)&quot;);&nbsp;&nbsp;
                </li>
                <li>ps.setString(1,&quot;sonoo&quot;);&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;</li>
                <li>FileInputStream&nbsp;fin=new&nbsp;FileInputStream(&quot;d:\\g.jpg&quot;);&nbsp;&nbsp;</li>
                <li>ps.setBinaryStream(2,fin,fin.available());&nbsp;&nbsp;</li>
                <li>int&nbsp;i=ps.executeUpdate();&nbsp;&nbsp;</li>
                <li>System.out.println(i+&quot;&nbsp;records&nbsp;affected&quot;);&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</li>
                <li>con.close();&nbsp;&nbsp;</li>
                <li>}catch&nbsp;(Exception&nbsp;e)&nbsp;{e.printStackTrace();}&nbsp;&nbsp;</li>
                <li>}&nbsp;&nbsp;</li>
                <li>}&nbsp;&nbsp;</li>
            </ol>

            <p>Consider the following example to retrieve the image from the table.</p>

            <p>&nbsp;</p>

            <ol start="1">
                <li>import&nbsp;java.sql.*;&nbsp;&nbsp;</li>
                <li>import&nbsp;java.io.*;&nbsp;&nbsp;</li>
                <li>public&nbsp;class&nbsp;RetrieveImage&nbsp;{&nbsp;&nbsp;</li>
                <li>public&nbsp;static&nbsp;void&nbsp;main(String[]&nbsp;args)&nbsp;{&nbsp;&nbsp;</li>
                <li>try{&nbsp;&nbsp;</li>
                <li>Class.forName(&quot;oracle.jdbc.driver.OracleDriver&quot;);&nbsp;&nbsp;</li>
                <li>Connection&nbsp;con=DriverManager.getConnection(&nbsp;&nbsp;</li>
                <li>&quot;jdbc:oracle:thin:@localhost:1521:xe&quot;,&quot;system&quot;,&quot;oracle&quot;);&nbsp;&nbsp;
                </li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</li>
                <li>PreparedStatement&nbsp;ps=con.prepareStatement(&quot;select&nbsp;*&nbsp;from&nbsp;imgtable&quot;);&nbsp;&nbsp;
                </li>
                <li>ResultSet&nbsp;rs=ps.executeQuery();&nbsp;&nbsp;</li>
                <li>if(rs.next()){//now&nbsp;on&nbsp;1st&nbsp;row&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</li>
                <li>Blob&nbsp;b=rs.getBlob(2);//2&nbsp;means&nbsp;2nd&nbsp;column&nbsp;data&nbsp;&nbsp;</li>
                <li>byte&nbsp;barr[]=b.getBytes(1,(int)b.length());//1&nbsp;means&nbsp;first&nbsp;image&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</li>
                <li>FileOutputStream&nbsp;fout=new&nbsp;FileOutputStream(&quot;d:\\sonoo.jpg&quot;);&nbsp;&nbsp;</li>
                <li>fout.write(barr);&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</li>
                <li>fout.close();&nbsp;&nbsp;</li>
                <li>}//end&nbsp;of&nbsp;if&nbsp;&nbsp;</li>
                <li>System.out.println(&quot;ok&quot;);&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</li>
                <li>con.close();&nbsp;&nbsp;</li>
                <li>}catch&nbsp;(Exception&nbsp;e)&nbsp;{e.printStackTrace();&nbsp;&nbsp;}&nbsp;&nbsp;</li>
                <li>}&nbsp;&nbsp;</li>
                <li>}&nbsp;&nbsp;</li>
            </ol>

            <p><a href="https://www.javatpoint.com/storing-image-in-oracle-database">More details.</a></p>

            <hr />
            <h3>24) How can we store the file in the Oracle database?</h3>

            <p>The setCharacterStream() method of PreparedStatement interface is used to set character information into
                the parameterIndex. For storing the file into the database, CLOB (Character Large Object) datatype is
                used in the table. For example:</p>

            <ol start="1">
                <li>CREATE&nbsp;TABLE&nbsp;&nbsp;&quot;FILETABLE&quot;&nbsp;&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;(&nbsp;&nbsp;&nbsp;&nbsp;&quot;ID&quot;&nbsp;NUMBER,&nbsp;&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&quot;NAME&quot;&nbsp;CLOB&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;)&nbsp;&nbsp;</li>
            </ol>

            <p><strong>Java Code</strong></p>

            <ol start="1">
                <li>import&nbsp;java.io.*;&nbsp;&nbsp;</li>
                <li>import&nbsp;java.sql.*;&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;</li>
                <li>public&nbsp;class&nbsp;StoreFile&nbsp;{&nbsp;&nbsp;</li>
                <li>public&nbsp;static&nbsp;void&nbsp;main(String[]&nbsp;args)&nbsp;{&nbsp;&nbsp;</li>
                <li>try{&nbsp;&nbsp;</li>
                <li>Class.forName(&quot;oracle.jdbc.driver.OracleDriver&quot;);&nbsp;&nbsp;</li>
                <li>Connection&nbsp;con=DriverManager.getConnection(&nbsp;&nbsp;</li>
                <li>&quot;jdbc:oracle:thin:@localhost:1521:xe&quot;,&quot;system&quot;,&quot;oracle&quot;);&nbsp;&nbsp;
                </li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</li>
                <li>PreparedStatement&nbsp;ps=con.prepareStatement(&nbsp;&nbsp;</li>
                <li>&quot;insert&nbsp;into&nbsp;filetable&nbsp;values(?,?)&quot;);&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</li>
                <li>File&nbsp;f=new&nbsp;File(&quot;d:\\myfile.txt&quot;);&nbsp;&nbsp;</li>
                <li>FileReader&nbsp;fr=new&nbsp;FileReader(f);&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</li>
                <li>ps.setInt(1,101);&nbsp;&nbsp;</li>
                <li>ps.setCharacterStream(2,fr,(int)f.length());&nbsp;&nbsp;</li>
                <li>int&nbsp;i=ps.executeUpdate();&nbsp;&nbsp;</li>
                <li>System.out.println(i+&quot;&nbsp;records&nbsp;affected&quot;);&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</li>
                <li>con.close();&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</li>
                <li>}catch&nbsp;(Exception&nbsp;e)&nbsp;{e.printStackTrace();}&nbsp;&nbsp;</li>
                <li>}&nbsp;&nbsp;</li>
                <li>}&nbsp;&nbsp;</li>
            </ol>

            <hr />
            <h3>25) How can we retrieve the file in the Oracle database?</h3>

            <p>The getClob() method of PreparedStatement is used to get file information from the database. Let&#39;s
                see the table structure of the example to retrieve the file.</p>

            <ol start="1">
                <li>CREATE&nbsp;TABLE&nbsp;&nbsp;&quot;FILETABLE&quot;&nbsp;&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;(&nbsp;&nbsp;&nbsp;&nbsp;&quot;ID&quot;&nbsp;NUMBER,&nbsp;&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&quot;NAME&quot;&nbsp;CLOB&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;)&nbsp;&nbsp;</li>
            </ol>

            <p>The example to retrieve the file from the Oracle database is given below.</p>

            <ol start="1">
                <li>import&nbsp;java.io.*;&nbsp;&nbsp;</li>
                <li>import&nbsp;java.sql.*;&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;</li>
                <li>public&nbsp;class&nbsp;RetrieveFile&nbsp;{&nbsp;&nbsp;</li>
                <li>public&nbsp;static&nbsp;void&nbsp;main(String[]&nbsp;args)&nbsp;{&nbsp;&nbsp;</li>
                <li>try{&nbsp;&nbsp;</li>
                <li>Class.forName(&quot;oracle.jdbc.driver.OracleDriver&quot;);&nbsp;&nbsp;</li>
                <li>Connection&nbsp;con=DriverManager.getConnection(&nbsp;&nbsp;</li>
                <li>&quot;jdbc:oracle:thin:@localhost:1521:xe&quot;,&quot;system&quot;,&quot;oracle&quot;);&nbsp;&nbsp;
                </li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</li>
                <li>PreparedStatement&nbsp;ps=con.prepareStatement(&quot;select&nbsp;*&nbsp;from&nbsp;filetable&quot;);&nbsp;&nbsp;
                </li>
                <li>ResultSet&nbsp;rs=ps.executeQuery();&nbsp;&nbsp;</li>
                <li>rs.next();//now&nbsp;on&nbsp;1st&nbsp;row&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</li>
                <li>Clob&nbsp;c=rs.getClob(2);&nbsp;&nbsp;</li>
                <li>Reader&nbsp;r=c.getCharacterStream();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
                </li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</li>
                <li>FileWriter&nbsp;fw=new&nbsp;FileWriter(&quot;d:\\retrivefile.txt&quot;);&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</li>
                <li>int&nbsp;i;&nbsp;&nbsp;</li>
                <li>while((i=r.read())!=-1)&nbsp;&nbsp;</li>
                <li>fw.write((char)i);&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</li>
                <li>fw.close();&nbsp;&nbsp;</li>
                <li>con.close();&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</li>
                <li>System.out.println(&quot;success&quot;);&nbsp;&nbsp;</li>
                <li>}catch&nbsp;(Exception&nbsp;e)&nbsp;{e.printStackTrace();&nbsp;&nbsp;}&nbsp;&nbsp;</li>
                <li>}&nbsp;&nbsp;</li>
                <li>}&nbsp;&nbsp;</li>
            </ol>

            <hr />
            <h3>26) What are the differences between stored procedure and functions?</h3>

            <p>The differences between stored procedures and functions are given below:</p>

            <table>
                <tbody>
                    <tr>
                        <th>Stored Procedure</th>
                        <th>Function</th>
                    </tr>
                    <tr>
                        <td>Is used to perform business logic.</td>
                        <td>Is used to perform the calculation.</td>
                    </tr>
                    <tr>
                        <td>Must not have the return type.</td>
                        <td>Must have the return type.</td>
                    </tr>
                    <tr>
                        <td>May return 0 or more values.</td>
                        <td>May return only one value.</td>
                    </tr>
                    <tr>
                        <td>The procedure supports input and output parameters.</td>
                        <td>The function supports only input parameter.</td>
                    </tr>
                    <tr>
                        <td>Exception handling using try/catch block can be used in stored procedures.</td>
                        <td>Exception handling using try/catch can&#39;t be used in user-defined functions.</td>
                    </tr>
                </tbody>
            </table>

            <hr />
            <h3>27) How can we maintain the integrity of a database by using JDBC?</h3>

            <p>To maintain the integrity of a database, we need to ensure the ACID properties. ACID properties mean
                Atomicity, Consistency, Isolation, and durability. In JDBC, Connection interface provides methods like
                setAutoCommit(), commit(), and rollback() which can be used to manage transaction. Let&#39;s see an
                example of transaction management in JDBC.</p>

            <ol start="1">
                <li>import&nbsp;java.sql.*;&nbsp;&nbsp;</li>
                <li>class&nbsp;FetchRecords{&nbsp;&nbsp;</li>
                <li>public&nbsp;static&nbsp;void&nbsp;main(String&nbsp;args[])throws&nbsp;Exception{&nbsp;&nbsp;</li>
                <li>Class.forName(&quot;oracle.jdbc.driver.OracleDriver&quot;);&nbsp;&nbsp;</li>
                <li>Connection&nbsp;con=DriverManager.getConnection(&quot;jdbc:oracle:thin:@localhost:1521:xe&quot;,&quot;system&quot;,&quot;oracle&quot;);&nbsp;&nbsp;
                </li>
                <li>con.setAutoCommit(false);&nbsp;&nbsp;</li>
                <li>&nbsp;&nbsp;</li>
                <li>Statement&nbsp;stmt=con.createStatement();&nbsp;&nbsp;</li>
                <li>stmt.executeUpdate(&quot;insert&nbsp;into&nbsp;user420&nbsp;values(190,&#39;abhi&#39;,40000)&quot;);&nbsp;&nbsp;
                </li>
                <li>stmt.executeUpdate(&quot;insert&nbsp;into&nbsp;user420&nbsp;values(191,&#39;umesh&#39;,50000)&quot;);&nbsp;&nbsp;
                </li>
                <li>&nbsp;&nbsp;</li>
                <li>con.commit();&nbsp;&nbsp;</li>
                <li>con.close();&nbsp;&nbsp;</li>
                <li>}}&nbsp;&nbsp;</li>
            </ol>

            <hr />
            <h3>28) What is the JDBC Rowset?</h3>

            <p>JDBC Rowset is the wrapper of ResultSet. It holds tabular data like ResultSet, but it is easy and
                flexible to use. The implementation classes of RowSet interface are as follows:</p>

            <ul>
                <li>JdbcRowSet</li>
                <li>CachedRowSet</li>
                <li>WebRowSet</li>
                <li>JoinRowSet</li>
                <li>FilteredRowSet</li>
            </ul>

            <hr />
            <h3>29) What is the major difference between java.util.Date and java.sql.Date data type?</h3>

            <p>The major difference between java.util.Date and java.sql.Date is that, java.sql.Date represents date
                without time information whereas, java.util.Date represents both date and time information.</p>

            <hr />
            <h3>30) What does JDBC setMaxRows method do?</h3>

            <p>The setMaxRows(int i) method limits the number of rows the database can return by using the query. This
                can also be done within the query as we can use the limit cause in MySQL.</p>

        </div>
    </div>

</body>

</html>